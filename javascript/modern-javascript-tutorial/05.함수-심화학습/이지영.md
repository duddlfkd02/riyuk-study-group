### 4주차 - 함수 심화학습
#### 6-1 재귀와 스택
재귀는 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴이다. <br>
목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀를 사용할 수 있다. <br>
또한 특정 자료구조를 다뤄야 할 때도 재귀가 사용된다. <br>

문제를 해결하다 보면 함수에서 다른 함수를 호출해야 할 때가 있다. <br>
이때 함수가 자기 자신을 호출할 수도 있는데, 이를 재귀라고 부른다. <br>

#### 두 가지 사고방식
재귀의 간단한 예시
x를 n제곱해 주는 함수 pow(x,n)를 만들어보자 
<br>
구현하는 방법은 두 가지가 있다
1. 반복적인 사고를 통한 방법: for 루프
```jsx
   function pow(x, n) {
       let result = 1;
       // 반복문을 돌면서 x를 n번 곱함
        for(let i = 0; i < n; i ++) {
          result *= x;
        }
      return result;
   }
alert ( pow (2,3) ) // 8
```

2. 재귀적인 사고를 통한 방법: 작업을 단순화하고 자기 자신을 호출함
```jsx
function pow(x,n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow( x, n-1);
  }
}
```

재귀 사용한 예시와 반복문을 사용한 예시와 어떤 부분에서 차이가 있는지 알아보자
1. n == 1일 때 : 모든 절차가 간단해진다. 명확한 결괏값을 즉시 도출하므로 이를 재귀의 베이스 라고한다.
2. n == 1이 아닐 때: pow(x,n)은 x * pow (x, n-1) 로 표현할 수 있다. 이를 재귀단계라고 부른다.
   즉, pow는 n == 1이 될 때가지 재귀적으로 자신을 호출한다.<br>
   이렇게 재귀를 이용하면 함수 호출의 결과가 명확해질 때까지 함수 호출을 더 간단한 함수 호출로 계속 줄일 수 있다. <br>
   또한 재귀를 사용한 코드는 반복적 사고에 근거하여 작성한 코드보다 대게 짧다. <br>
   ```jsx
    function pow (x,n) {
      return (n == 1) ? x : (x * pow(x , n-1));
   }
   ```
중첩 호출의 최대 개수는 재귀 깊이라고 한다. pow(x,n)의 재귀 깊이는 n이다. <br>
자바스크립트 엔진은 최대 재귀 깊이를 제한한다.
만개 정도 까지는 확실히 허용하고, 십만까지는 다루지 못한다.
이러한 재귀 깊이 제한 떄문에 재귀를 실제 적용하는데 제약이 있긴 하지만, 재귀는 여전히 광범위하게 사용되고있다.
재귀를 사용함녀 간결하고 유지보수가 쉬운 코드를 만들 수 있기 때문이다.

### 실행 컨텍스트와 스택 
실제 재귀 호출이 어떻게 동작하는지 알아보자 <br>
실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트(execution context)에 저장된다.
실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다.  <br> 
함수 호출 일 회당 하나의 실행 컨텍스트가 생성된다. <br>
함수 내부에 중첩 호출이 있을 때는 아래와 같은 절차가 수행된다.
- 현재 함수의 실행이 일시 중지된다.
- 중지된 함수와 연관된 실행 컨텍스트는 실행 컨텍스트 스택 이라는 특별한 자료구조에 저장된다.
- 중첩 호출이 실행된다
- 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.

```jsx
function pow(x,n) {
  if ( n == 1 ) {
    return x;
  } else {
    return x * pow(x, n-1);
  }
}
```

pow(2,1)의 실행 컨텍스트
Context : {x: 2, n:1, 첫 번째 줄}  <br>
Context: {x:2, n:2, 다섯 번째 줄}  <br>
Context: {x:2, n:3, 다섯 번째 줄}  <br>

위에서부터 차례차례 스택의 컨텍스트를 꺼내서 실행한다. <br>
지금 본 예시의 재귀의 깊이는 3이다.  <br>

반복문을 상용해 만든 함수 pow
```jsx
function pow(x,n) {
  let result = 1;
  for(let i = 0; i < n; i ++ ){
    result *= x
  }
  return result;
}
```
반복문을 사용해 pow를 만듦녀 컨텍스트를 하나만 사용한다. 이 컨텍스트에서 i와 result가 변경된다.  <br>
실행 컨텍스트가 하나이기 때문에 n에 의존적이지 않고, 필요한 메모리가 적다. 사용 메모리 공간도 고정된다.  <br>
**반복문을 사용하면 대개 함수 호출의 비용(메모리 사용)이 절약된다. <br>

하지만 재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있다. <br>
모든 곳에서 메모리 최적화르 ㄹ신경써서 코드를 작성해야하는 것은 아니다 <br>
우리가 필요한것은 좋은 코드이다. 이런 이유 때문에 재귀를 사용한다. <br>

### 연결 리스트
객체를 정렬하여 어딘가에 저장하고 싶을 때
```jsx
let arr = [obj1, obj2, obj3];
```
하지만 배열은 요소 삭제와 삽입에 들어가는 비용이 많이 든다는 문제가 있다.(unshift, shift) <br>
빠르게 삽입 혹은 삭제를 해야할 때는 배열 대신 연결 리스트라 불리는 자료 구조를 사용할 수 있다. <br>
연결 리스트의 요소는 객체와 아래 프로퍼티들을 조합해 정의할 수 있다.
- value
- next: 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 땐 null이된다.

```jsx
  let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  }
```

아래처럼 코드를 작성해도 동일한 연결리스트가 된다.
```jsx
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list next.next.next = { value: 4 };
list.next.next.next.next = null;
```
연결 리스트를 사용하면 전체 리스트를 여러 부분으로 쉽게 나눌 수 있고, 다시 합치는 것도 가능하다.
```jsx
let secondList = list.next.next;
list.next.next = null;
```
그리고 쉽게 요소를 추가하거나 삭제할 수 있다.
리스트의 처음 객체를 바꾸면 리스트 맨 앞에 새로운 값을 추가할 수 있다.

#### 과제
주어진 숫자까지의 모든 숫자 더하기 
숫자 1 + 2 + .. + n을 계산하는 함수 sumTo (n)을 만들어보세요

1. for 반복문 사용하기
2. 재귀 사용하기
3. 등차수열 사용하기
```jsx
function sumTo(n) {
  let sum = 0;
  for(let i = n; i >= 1; i-- ) {
    sum += n;
  }
  return sum;
}
```
```jsx
function sumTo(n) {
  let sum = 0;
  if(n==1) {
    return 1;
  } else {
    return n + sumTo(n-1)
  }
}
```
```jsx
function sumTo(n) {
  return n * (n + 1) / 2;
}
```

등차수열의 합공식을 사용하는 방법이 가장 빠르고, 두 번째로는 반복을 사용하는 방법이다. 
재귀를 사용하는 방법은 중첩 호출과 실행 스택 관리가 추가로 필요하기 떄문에 더 많은 자원을 소비한다.
따라서 속도가 더 느리다. 

<br>

팩토리얼 계산하기 
n이 자연수일 때, 1부터 n까지의 모든 자연수의 곱을 의미
n팩토리얼은 n!으로 표시

```jsx
n! = n * (n-1) * (n - 2) * ... * 1
```
재귀를 사용하여 n!을 계산하는 함수 factorial(n)을 만들어보세요
```jsx
function factorial(n) {
  if(n == 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
```

단일 연결 리스트 출력하기
재귀와 스택에서 설명한 바 있는 단일 연결 리스트가 있다고 가정해봅시다.
```jsx
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```
리스트 내 항목을 차례대로 하나씩 출력해주는 함수 printList(list)를 만들어보세요
반복문과 재귀를 사용한 답안 각각을 만들어봅시다.
그리고 재귀를 사용한 것과 재귀를 사용하지 않은 것 중 어떤 게 더 좋은 코드인지 생각해보자
<br>
해답
```jsx
function printList(list) {
  let tmp = list;
  while(tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }
}
```
또다른 답
```jsx
function printList(list) {
  while(list) {
    alert(list.value);
    list = list.next;
  }
}
```
하지만 매개변수 list를 바로 사용하는 건 그다지 현명한 선택은 아니다. <br>
나중에 함수를 확장할 때 list를 가지고 뭔가 해야하는 경우가 생길 수 있기 때문이다. <br>
while문 앞에서 list가 변경되면 위의 코드느 제대로 동작하지 않을것이다. <br>

좋은 변수 명이 무엇인가를 생각해 봤을 때도 리스트를 임시 변수 tmp에 저장하는 게 좋다. <br>
list 에는 그 리스트 그 자체가 저장되어 있는게 좋다. <br>
tmp는 리스트를 순회하기 위한 용도로 쓰였기 떄문에 tmp라고 명명해는게 좋다. for문의 i처럼 <br>

재귀를 기반으로 한 답 
```jsx
function printList(list) {
  alert(list.value) // 현재 요소를 출력
  if(list.next) {
    printList(list.next); // 같은 방법을 사용해 나머지 요소를 출력
  }
}
```

### 나머지 매개변수와 전개 구문
상당수의 자바스크립트 내장 함수는 인수의 개수에 제약을 두지 않는다. <br>
예시:
- Math.max(arg1,arg2,...,argN) : 인수 중 가장 큰 수를 반환
- Object.assign(dest, src1, ..., srcN) : src1..N의 프로퍼티를 dest로 복사한다.

### 나머지 매개변수 ...
함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수엔 제약이 없다.
```jsx
function sum(a,b) {
  return a + b; 
}
alert( sum (1,2,3,4,5) );
```

함수를 정의할 땐 인수를 두 개만 받도록 하고, 실제 함수를 호출할 땐 이보다 더 많은 여분의 인수를 전달했지만, 에러가발생하지 않았다. <br> 
다만 반환 값은 처음 두 개의 인수만을 사용해 계산된다. <br>

이렇게 여분의 매개변수는 그 값들을 담을 배열 이름을 마침표 세 개 ...뒤에 붙여주면 함수 선언부에 포함시킬 수 있다. <br>
이때 마침표 세개 ...는 "남아있는 매개변수들을 한데 모아 배열에 집어넣어라." 는 것을 의미한다. <br>

나머지 매개변수는 항상 마지막에 있어야한다.

### arguments 객체
유사 배열 객체인 arguments를 사용하면 인덱스를 사용해 인수에 접근할 수 있다. <br>
또한 arguments 는 이터러블 객체이기 때문에 for(let arg of arguments) alert(arg)를 사용해 인수를 펼칠 수 있다. <br>
arguments는 유사 배열 객체이면서 이터러블(반복 가능한)객체이다. <br>
하지만 배열은 아니다 따라서 배열 메서드를 사용할 수 없다는 단점이 있다 <br>
또한 인수 전체를 담기 때문에 나머지 매개변수처럼 인수의 일부만 사용할 수 없다는 단점도 있다. <br>
따라서 배열 메서드를 사용하거나 인수 일부만 사용할 때는 나머지 매개변수를 사용하는 것이 좋다. <br>
또한 화살표 함수는 arguments 객체를 지원하지 않는다. <br>
접근하면, 외부에 있는 일반 함수의 arguments객체를 가져온다. 

### 스프레드 문법
개발을 하다보면 배열을 통째로 매개변수에 넘겨주는 기능이 필요할때가 있다. <br>
예를들어 내장함수 Matn.max는 인수로 받은 숫자 중 가장 큰 숫자를 반환한다. 
```jsx
alert(Matn.max(3,5,1)); // 5
```
배열 [3,5,1]이 있고 이 배열을 대상으로 Matn.max를 호출하고 싶다고 가정해보자 <br>
아무런 조작 없이 배열을 있는 그대로 넘기면 원하는 대로 동작하지 않는다. (결과는 NaN)<br> 
Math.max는 배열이 아닌 숫자 목록을 인수로 받기 때문이다. <br>
Math.max(arr[0],arr[1],arr[2]) 처럼 배열 요소를 수동으로 나열하는 방법도 있긴 한데, 배열 길이를 알 수 없을 때는 이마저도 불가능하다. <br>
스크립트가 돌아갈 때 넘어오는 배열의 길이는 아주 길 수도 있고, 아예 빈 배열일 수도 있기 때문이다. <br>

전개 구문(spread syntax, 스프레드 구문)은 이럴 떄 사용하기 위해 만들어졌다.<br>
...를 사용하기 때문에 나머지 매개변수와 비슷해보이지만 전개 구문은 나머지 매개변수와 반대 역할을 한다. <br>

함수를 호출할 때 ...arr을 사용하면, 이터러블 객체 arr이 인수 목록으로 '확장'된다.
```jsx
let arr = [3,5,1];
alert( Math.max(...arr) ) // 5 (전개 구문이 배열을 인수 목록으로 바꿔주었음.) 
```

아래와 같이 이터러블 객체 여러 개를 전달하는 것도 가능하다.
```jsx
let arr1 = [1,-2,3,4];
let arr2 = [8,3,-8,1];
alert(Math.max(...arr1,...arr2); // 8
```
스프레드 문법을 평범한 값과 혼합해 사용하는 것도 가능히다.
```jsx
let arr1 = [1,-2,3,4];
let arr2 = [8,3,-8,1];
alert(Math.max(1,...arr1, 2, ...arr2, 25); // 25
````
전개 구문은 배열을 합칠 때도 활용할 수 있다.
```jsx
let arr = [3,5,1];
let arr2 = [8,9,15];
let merged = [0, ...arr, 2, ...arr2];
alert(merged); // 0,arr,2,arr2순서로 합쳐진다.
```

앞선 예시들에선 배열을 대상으로 전개 구문이 어떻게 동작하는지를 살펴보았다.
그런데 배열이 아니더라도 이터러블 객체이면 전개 구문을 사용할 수 있다.

스프레드 문법을 사용해 문자열을 문자 배열로 변환시켜보자
```jsx
let str = "Hello";
alert([...str]; // H,e,l,l,o
```

전개 구문은 for..of와 같은 방식으로 내부에서 이터레이터(iterator, 반복자)를 사용해 요소를 수집한다.
문자열에 for..of를 사용하면 문자열을 구성하는 문자가 반환된다.
...str도 H,e,l,l,o 가 되는데 이 문자 목록은 배열 초기자(array initializer) [...str]로 전달된다.

메서드 Array.from은 이터러블 객체인 문자열을 배열로 바꿔주기 때문에 Array.from을 사용해도 동일한 작업을 할 수 있다.
```jsx
let str = "Hello";
// Array.from은 이터러블을 배열로 바꿔준다.
alert(Array.from(str)); // H,e,l,l,o
```

[...str]과 동일한 결과가 출력되는 것을 확인할 수 있다.
그런데 Array.from(obj)와 [...obj]는 다음과 같은 미묘한 차이가 있다.
- Array.from은 유사 배열 객체와 이터러블 객체 둘 다에 사용할 수 있다.
- 스프레드 문법은 이터러블 객체에만 사용할 수 있다.
이런 이유 떄문에 무언가를 배열로 바꿀 떄는 전개 구문보다 Array.from이 보편적으로 사용된다.

#### 배열과 객체의 복사본 만들기 
참조에 의한 객체 복사 챕터에서 Object.assign()을 사용해 객체를 복사했다.
Object.assign()말고도 스프레드 문법을 사용하면 배열과 객체를 복사할 수 있다.

```jsx
let arr = [1,2,3];
let arrCopy = [...arr] // 배열을 펼쳐서 각 요소를 분리 후, 매개변수 목록으로 만든 다음
                        // 매개변수 목록을 새로운 배열에 할당함

// 배열 복사본의 요소가 기존 배열 요소와 같을까?
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열은 같을까?
alert(arr = arrCopy); // false(참조가 다름)

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않는다.
arr.push(4);
alert(arr); // 1,2,3,4
alert(arrCopy); // 1,2,3
```

이번엔 객체를 복사하는 예시를 살펴보자
```jsx
let obj = { a: 1, b: 2, c: 3 };
let objCopy = {...obj}; // 객체를 펼쳐서 각 요소를 분리한 후, 매개변수 목록으로 만든 다음에
                        // 매개변수 목록을 새로운 객체에 할당함

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 같을까?
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같을까?
alert(obj === objCopy); // false (참조가 다름)

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않습니다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a": 1, "b": 2, "c": 3, "d": 4}
alert(JSON.stringify(objCopy); // {"a": 1, "b": 2, "c": 3}
```

이렇게 전개 구문을 사용하면 <br>
let objCopy = Object.assgin({},obj); <br> 
let arrCopy = Objet.assign([],arr) <br>
보다 더 짧은 코드로 배열이나 객체를 복사할 수 있어서 사람들은 이 방법을 더 선호한다.

### Sammary
"..."은 나머지 매개변수나 스프레드 문법으로 사용할 수 있다.
나마지 매개변수와 전개 구문은 아래의 방법으로 구분할 수 있다.
- ...이 함수 매개변수의 끝에 있으면 인수 목록의 나머지를 배열로 모아주는 "나머지 매개변수"이다.
- ...이 함수 호출 시 사용되거나 기타 경우엔 배열을 목록으로 확장해주는 스프레드 문법이다.

사용 패턴:
- 인수 개수에 제한이 없는 함수를 만들 때 나머지 배개변수를 사용한다.
- 다수의 인수를 받는 함수에 배열을 전달할 때 전개 구문을 사용한다.

둘을 함께 사용하면 매개변수 목록과 배열 간 전환을 쉽게 할 수 있다.
조금 오래된 방법이긴 하지만 arguments라는 반복가능한 유사 배열 객체를 사용해도 인수 모두를 사용할 수 있다. 

### 변수의 유효범위와 클로저
자바스크립트는 함수 지향 언어이다.
이런 특징은 개발자에게 많은 자유를 준다.
함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 
생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문이다.

함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다
그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까?
함수는 호출되는 곳을 기준으로 외부 변수에 접근할까?

### 코드블록
코드블록 {...}안에서 선언한 변수는 블록 안에서만 사용할 수 있다.
이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용할 수 있다. 
블록 안엔 작업 수행에만 필요한 변수가 들어간다. 

```jsx
{
   let message = "안녕";
   alert(message);
};
{
   let message = "잘가";
   alert(message);
}
```

블록이 없으면 에러가 발생하낟.
이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 let으로 선언하면 에러가 발생한다. <br>
if, for, while등에서도 마찬가지로 {...}안에서 선언한 변수는 오직 블록 안에서만 접근 가능하다.

### 중첩함수 
함수 내부에서 선언한 함수는 중첩(nested)함수라고 부른다.
자바스크립트에선 손쉽게 중첩 함수를 만들 수 있다.
중첩 함수는 아래와 같이 코드를 정돈하는데 사용할 수 있다.
```jsx
function sayHiBye(firstName, lastName) {
   // 헬퍼(helper) 중첩 함수
   function getFullName() {
      return firstName + " " + lastName;
   }
   alert("Hello, " + getFullName() );
   alert("Bye, " + getFullName() );
}

위 예시에서 외부 변수에 접근해 이름 전체를 반환해주는 중첩함수 getFullName()은 편의상 만든 함수이다
이렇게 자바스크립트에서는 중첩 함수가 흔히 사용된다.
중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다는 점에서 흥미롭다.
이렇게 반환된 중첩함수는 어디서든 호출해 사용할 수 있다.
물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함없다.
아래 함수 makeCounter는 호출될 떄마다 다음 숫자를 반환해주는 카운터 함수를 만든다.

```jsx
function makeCounter() {
   let count = 0;
   return function () {
      return count ++;
   }
}
let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```

예시의 makeCounter는 아주 단순하지만 여기에 약간의 변형을 가하면 난수 생성기 같은 실용성 있는 함수를 만들 수 있다. 
그런데 makeCounter를 살펴보다 보면 counter를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까?
함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까 라는 의문이 들 수 있다.

#### 단계 1. 변수
자바스크립트에서는 실행 중인 함수, 코드 블록 {...}, 스크립트 전체는 렉시컬 환경이라 불리는 재부 숨김 연관 객체를 갖는다.
렉시컬 환경 객체는 두 부분으로 구성된다.
1. 환경 레코드: 모든 지역 변수를 프로퍼티로 저장하고 있는 객체 this값과 같은 기타 정보도 여기에 저장된다.
2. 외부 렉시컬 환경에 대한 참조: 외부 코드와 연관됨

변수는 특수 내부 객체인 환경 레코드의 프로퍼티일 뿐이다. 변수를 가져오거나 변경하는 것은 환경 레코드으 ㅣ프로퍼티를 가져오거나 변경함을 의미힌다. 

아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재한다. 

<img width="532" alt="스크린샷 2025-01-11 오후 8 52 18" src="https://github.com/user-attachments/assets/afb46538-97de-4e9e-9ca2-589787d7f894" />

이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경이라고 한다.
 위 그림에서 네모상자는 변수가 저장되는 환경 레코드를 나타내고 네모 상자 옆, 오른쪽을 향하는 화살표는 외부 렉시컬 환경에 대한 참조를 나타낸다.
 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 null을 가리킨다. 

 코드가 실행되고 실행 흐름이 이어져 나가면서 렉시컬 환경은 변화한다.
 좀 더 긴 코드를 살펴보자

 <img width="574" alt="스크린샷 2025-01-11 오후 8 54 55" src="https://github.com/user-attachments/assets/8775422f-5bb2-48ba-891a-b35f6b9e1e7a" />

우측의 네모 상자들은 코드가 한 줄, 한 줄 실행될 때마다 전역 렉시컬 환경이 어떻게 변화하는지 보여준다. 
1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다.
   - 이때 변수의 상태는 특수내부상태인 uninitialized가 된다. 자바스크립트 엔진은 uninitialized상태의 변수를 인지하긴 하지만, let을 만나기 전까진 이 변수를 참조할 수 없다.
2. let phrase가 나타난 후, 아직 값을 할당하기 전이기 때문에 프로퍼티의 값은 undefined이다. phrase는 이 시점 이후부터 사용할 수 있따.
3. Pharse에 값이 할당되었다.
4. Pharse의 값이 변경되었다.

지금까지 배운 내용을 요약해보면 
- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티이다. 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있다.
- 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.
또한 변수는 이론상의 객체이다 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능하다.

#### 단계 2. 함수 선언문
함수는 변수와 마찬가지로 값이다.
다만 함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다는 점에서 차이가 있다.
변수는 let을 만나 선언이 될 때까지 사용할 수 없지만, 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다.
선언되기 전에도 함수를 사용할 수 있는 것은 바로 이 때문이다.
아래 그림은 스크립트에 함수를 추가했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변하는지 보여준다. 

<img width="655" alt="스크린샷 2025-01-11 오후 9 05 04" src="https://github.com/user-attachments/assets/795eec42-b08a-447e-b934-4bf7fa5b9c77" />

이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용된다. 
함수를 변수에 할당한 함수 표현식은 해당하지 않는다.

#### 단계 3. 내부와 외부 렉시컬 환경
함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 
이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다. 
say("john")을 호출하면 아래와 같은 내부 변화가 일어난다(현재 실행 흐름은 함수 내부, 화살표로 표시한 줄(alert문)에 멈춰있는 상황이다. 

<img width="778" alt="스크린샷 2025-01-11 오후 9 09 12" src="https://github.com/user-attachments/assets/f8ca74a6-f1ed-4852-80d9-a2e653db5635" />

함수 호출 중엔 호출 중인 함수를 위하 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경 총 2개의 렉시컬 환경을 갖게된다.
- 예시의 내부 렉시컬 환경은 ㅎ녀재 실행 중인 함수인 say에 상응하고, 내부 렉시컬 환경엔 함수의 인자인 name으로부터 유래한 프로퍼티 하나만 있다.
  say ("John")을 호출했기 때문에, name의 값을 John이 된다.
- 예시의 외부 렉시컬 환경은 전역 렉시컬 환경이다. 전역 렉시컬 환경은 pharse와 함수 say를 프로퍼티로 갖는다.
그리고 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖는다.

코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다.
내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다.
이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 떄까지 반복된다.

전역 렉시컬 환경에 도달할 때까지 변수를 찾지 못하면 엄격 모드에선 에러가 발생한다.
참고로 비 엄격 모드에선 정의도지 않은 변수에 값을 할당하려고 하면 에러가 발생하는 대신 새로운 전역 변수가 만들어지는데, 이는 하위 호환성을 위해 남아있는 기능이다.

예시와 그림을 보면서 변수 검색이 어떻게 진행되는지 정리해부자
- 함수 say내부의 alert에서 변수 name에 접근할땐, 먼저 내부 렉시컬 환경을 살펴본다. 내부 렉시컬 환경에서 변수 name을 찾았다.
- alert에서 변수 pharse에 접근하려는데 pharse에 상응하는 프로퍼티가 내부 렉시컬 환경엔 없다. 따라서 검색 범위는 외부 렉시컬 환경으로 확장된다.
외부 렉시컬 환경에서 pharse를 찾았다.

<img width="778" alt="스크린샷 2025-01-11 오후 11 02 07" src="https://github.com/user-attachments/assets/f55f226c-008b-4044-905c-a5e15e4cdfdf" />

#### 단계 4. 함수를 반환하는 함수
makeCounter 예시로 돌아가보자
```jsx
function makeCounter() {
   let count = 0;
   return function() {
      return count ++;
   }
}
let counter = makeCounter();
```

makeCounter() 를 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어지고 여기에 makeCounter를 실행하는데 필요한 변수들이 저장된다.
위쪽에서 살펴본 say("John")예시와 마찬가지로 makeCounter()를 호출할 떄도 두 개의 렉시컬 환경이 만들어진다.

<img width="778" alt="스크린샷 2025-01-11 오후 11 04 13" src="https://github.com/user-attachments/assets/9611296d-6e0e-4472-af7e-9ec5473b12e4" />

그런데 위쪽에서 살표번 say함수 예시와 makeCounter()함수 예시에는 차이점이 있다.
makeCOunter()가 실행되는 도중엔 본문이 한줄 짜리인 중첩 함수가 만들어진다는 점이다
현재는 중첩함수가 생성되기만 하고 실행은 되지 않은 상태이다.
여기서 중요한 사실은 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다는 점이다. 함수는 [[Environment]]라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다.

<img width="822" alt="스크린샷 2025-01-11 오후 11 07 56" src="https://github.com/user-attachments/assets/43f806e4-7020-4100-be6d-70a1931acc10" />

따라서 counter.[[Environment]]엔 {count:0} 이 있는 레깃컬 환경에 대한 참조가 저장된다.
호출 장소오 ㅏ상관 없이 함수가 자신이 태어난 곳을 기억할 수 있는건 바로 이 Environment 프로퍼티 덕분이다.
[[Environment]]는 함수가 생성될 때 딱 한번 값이 세팅되고 영원히 변하지 않는다.

count() 를 호출하면 각 호출마다 새로운 렉시컬 환경이 생성된다. 그리고 이 렉시컬 환경은 counter.[[Environement]]에 저장되 ㄴ렉시컬 환경을 외부 렉시컬 환경으로서 참조한다.

<img width="822" alt="스크린샷 2025-01-11 오후 11 10 49" src="https://github.com/user-attachments/assets/8cdc4d67-7419-4cfd-bdc0-6dab3edd9f0f" />

실행 흐름이 중첩 함수의 본문으로 넘어오면 count 변수가 필요한데 먼저 자케 렉시컬 환경에서 변수를 찾는다.
익명 중첩 함수엔 지역변수가 없기 떄문에 이 렉시컬 환경은 비어있는 상황이다. 이제 counter()의 렉시컬 환경이 참조하는 외부 렉시컬 환경에서 count를 찾는다.
이제 count++가 실행되면서 count값이 1증가해야하는데, **변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄진다.**

따라서 실행이 종료된 후의 상태는 아래와 같다.

<img width="822" alt="스크린샷 2025-01-11 오후 11 14 06" src="https://github.com/user-attachments/assets/e3b2dabd-d3d1-4c66-80f2-4bd3128664f2" />

counter()를 여러 번 호출하면 count변수가 2,3으로 증가하는 이유가 바로 여기 있다. 

#### 클로저
클로저(closure)는 개발자라면 알고 있어야 할 프로그래밍 용어이다.
클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미한다.
자바스크립트에서는 모든 함수가 자연스럽게 클로저가 된다.

자바스크립트의 함수는 숨김 프로퍼티인 [[Environment]]를 이용해 자신이 어디서 만들어졌는지를 기억한다.
함수 본문에선 [[Environment]]를 사용해 외부 변수에 접근한다.

#### 가비지 컬렉션
함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다.
함수와 관련된 변수들은 이떄 모두 사라진다. 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유가 이떄문이다.
자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지된다.

그런데 호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 
이때는 중첩함수의 [[Environment]]프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다. 도달 가능한 상태가 되는 것이다.
함수 호출은 끝났지만 렉시컬 환경이 메모리에 유지되는 이유는 바로 이 때문이다. 

예시
```jsx
function f() {
   let value = 123;
   return function () {
      alert(value);
   }
}
leg g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장된다.

그런데 이렇게 중첩함수를 사용할 때는 주의할 점이 있다. f()를 여러 번 호출하고 그 결과를 어딘가에 저장하는 경우, 호출 시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지된다는 점이다.
아래 예시를 실행하면 3개의 렉시컬 환경이 만들어지는데, 각 렉시컬 환경은 메모리에서 삭제되지 않는다.


```jsx
function f() {
   let value = Math.randon();
   return function () { alert(value) };
}
// 배열 안의 세 함수는 각각 ()를 호출할 때 생성된 렉시컬 환경과 연관 관계를 맺는다. 
let arr = [f(),f(),f()];
```

렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제된다. 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다.
아래 예시 같이 중첩 함수가 메모리에서 삭제되고 난 후에야, 이를 감싸는 렉시컬 환경(그리고 그 안에 변수인 value)도 메모리에서 제거된다.

```jsx
function f() {
   let value = 123;
   return function() {
      alert(value);
   }
}
let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있다.
g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제된다.
```

### 최적화 프로세스
앞에서 보았듯이, 함수가 살아있는 동안엔 이론상으론 모든 외부 변수 역시 메모리에 유지된다.
그러나 실제로는 자바스크립트 엔진이 이를 지속해서 최적화한다. 
자바스크립트 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거한다.
디버깅 시 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8엔진의 주요 부작용이다.

### 과제 
#### 함수가 최신 변경사항을 반영할까?
함수 sayHi는 외부 변수 name을 사용하고 있는데, 함수가 실행될 떄 두 외부 변수 name 중 어떤 값이 사용될까?
```jsx
let name = "보라";
function sayHi() {
   alert(name + "님, 안녕하세요.");
}
name = "지민";
sayHi(); // 보라, 지민 중 무엇이 출력될까?
```

정답은 지민이다. 
함수는 외부 변수의 현재 값 즉, 가장 최신의 값을 사용한다.
이전 값은 어디에도 저장되지 않는다. 함수에서 변숫값을 사용할 땐 해당 함수의 렉시컬 환경 또는 외부 렉시컬 환경에서 해당 변숫값을 찾는다. 

#### 클로저를 이용하여 합 구하기
sum(a)(b)= a+b와 같은 연산을 해주는 함수 sum을 만들어 보세요

정답:
```jsx
function sum (a) {
   return function (b) {
      return a+b
   }
}
```

#### 변수가 보일까요? 
다음 코드를 실행했을 때, 어떤 값이 출력될까요?
```jsx
let x = 1;
function func() {
   console.log(x);
   let x = 2;
}
func();
```

정답: 에러가 발생한다. 
코드 블록 실행에 들어가는 순간 그 안의 변수는 초기화되지 않은 상태가 된다. 그리고 let을 만날 때까지 해당 상태가 유지된다.
엔진은 함수가 시작될 때 로컬 변수 x의 존재를 알고있지만 let 문이 실행될 때까지 x는 초기화되지 않은 상태(dead zone)이기 떄문에 
에러가 발생한다.

실제 초기화가 일어나기 전 변수를 일시적으로 사용하지 못하는 구간(코드 블록의 시작부터 let이 나올때까지)을 데드존(dead zone)이라고 부른다.

#### 함수를 이용해 원하는 값만 걸러내기
배열에 사용할 수 있는 내장 메서드 arr.filter(f)는 함수 f의 반환 값을 true로 만드는 모든 요소를 배열로 반환해줍니다.
filter에 넘겨서 사용할 수 있는 함수 두 가지를 만들어봅시다.
- inBetween(a, b) – a 이상 b 이하
- inArray([...]) – 배열 안에 있는 값인가
위 함수를 활용하면 다음과 같은 결과가 나와야 합니다.
- arr.filter(inBetween(3,6)) – 3과 6 사이에 있는 값만 반환함
- arr.filter(inArray([1,2,3])) – [1,2,3] 안에 있는 값과 일치하는 값만 반환함
예시:
```jsx
/* ... 여기에 두 함수 inBetween과 inArray을 만들어주세요 ...*/
let arr = [1, 2, 3, 4, 5, 6, 7];

alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6

alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
```

#### 정답
```jsx
function inBetween(a,b) {
   return function(x) {
      return x > = a && x <= b;
   }
}
function inArray(arr) {
   return function(x){
      return arr.includes(x);
   }
}
```

#### 필드를 기준으로 정렬하기

객체가 담긴 배열을 정렬해야 한다고 가정해봅시다.

<img width="675" alt="스크린샷 2025-01-12 오전 12 15 22" src="https://github.com/user-attachments/assets/c2c23ef6-83a6-4c2c-880f-dc0547035f8c" />

#### 정답
```jsx
function byField(fieldName) {
   return (a,b) => a[fieldName] > b[fieldName];
}
```

여기서 a.fieldName b.fieldName 형태로 써도 될까? <br>
답은 아니다. <br>
이유는 fieldName은 문자열로 "name"이나 "age"등 다양한 값이 될 수 있다. 따라서 a[fieldName]과 같은 형태로 동적으로 속성을 접근해야한다.

### 오래된 var
var을 let으로 바꿀 때 var에 대해 제대로 알아두지 않으면 예상치 못한 에러는 만날 수 있다.

#### var은 블록 스코프가 없다.
var로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프이다. 
블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근이 가능하다.

코드 블록이 함수 안에 있다면 var은 레벨 변수가 된다. 

```jsx
function sayHi() {
  if (true) {
    var phrase = "Hello";
  }

  alert(phrase); // 제대로 출력됩니다.
}

sayHi();
alert(phrase); // Error: phrase is not defined
```

위와 같이 var는 if, for등의 코드 블록을 관통한다. 
또한 var은 변수의 중복 선언을 허용한다.  

#### 선언하기 전 사용할 수 있는 var
var선언은 함수가 시작될 떄 처리된다. 전역에서 선언한 변수라면 스크립트가 시작될 떄 처리된다.
함수 본문 내에서 var로 선언한 변수는 선언 위치와 상관없이 함수 본문이 시작되는 지점에서 정의된다. (단 변수가 중첩 함수 내에서 정의되지 않아야 이 규칙이 적용된다.) 

```jsx
function sayHi() {
  phrase = "Hello";

  alert(phrase);

  var phrase;
}
sayHi();
```

아래에 var phrase가 선언되었지만 끌어올려져서 사용할 수 있다.
이렇게 변수가 끌어올려 지는 현상을 호이스팅이라고 부른다.
var로 선언한 모든 변수는 함수의 최상위로 끌어올려지기 때문이다. 

또한 변수 선언은 함수 실행이 시작될 떄 처리되지만(호이스팅) 할당은 호이스팅 되지 않기 떄문에 할당 관련 ㅗㅋ드에서 처리된다. 
따라서 아래 예제는 undefined가 출력된다. 

```jsx
function sayHi() {
  var phrase; // 선언은 함수 시작 시 처리됩니다.
  alert(phrase); // undefined
  phrase = "Hello"; // 할당은 실행 흐름이 해당 코드에 도달했을 때 처리됩니다.
}
sayHi();
```

이처럼 모든 var선언은 함수 시작 시 처리되기 떄문에 var로 선언한 변수는 어디서든 참조할 수 있다. 하지만 변수에 무언가를 할당하기 전까진 값이 undefined이다. 

### 전역 객체 
전역 객체를 사용하면 어디서나 사용 가능한 변수나 함수를 만들 수 있다.
전역 객체는 언어 자체나 호스트 환경에 기본 내장되어 있는 경우가 많다. 

브라우저 환경에서는 전역 객체를 window, Node.js환경에선 global이라고 부르는데 각 호스트 환경마다 부르는 이름은 다르다.
전역 객체의 이름을 globalThis로 표준화하자는 내용이 최근에 자바스크립트 명세에 추가되었기 떄문에 모든 호스트 환경이 이를 따라야한다.
Chrominum기반이 아닌 몇몇 브라우저는 아직 globalThis를 지원하지 않지만 이에 대한 폴리필을 쉽게 만들 수 있다.

브라우저에서 let 이나 const 가 아닌 var로 선언한 전역 함수나 전역 변수는 전역 객체의 프로퍼티가 된다
```jsx
var gVar = 5;
alert(window.gVar); // 5 (var로 선언한 변수는 전역 객체 window의 프로퍼티가 된다)
```
하지만 let으로 선언된 변수는 window객체를 통해 변수에 접근할 수 없다. 

중요한 변수라서 모든 곳에 사용할 수 있게 하려면, 아래와 같이 전역 객체에 직접 프로퍼티를 추가해주면 된다.
```jsx
window.currentUser = {
   name: "John"
};
alert(currentUser.name); // John
alert(window.currentUser.name); // John
```

전역 변수는 되도록 사용하지 않는 것이 좋다. 함수를 만들 땐 외부 변수나 전역변수를 사용하는 것보다 인풋 변수를 받고 이를 이용해 아웃풋을 만들어내게 해야 테스트도 쉽고 에러도 덜 만들어낸다. 

### 폴리필 사용하기
전역 객체를 이용해 현재 사용중인 브라우저가 최신 자바스크립트 기능을 지원하는지 여부를 확인할 수 있다.
내장 객체 Promise를 지원하는지 여부를 아래와 같이 테스트할 수 있다.
구식 브라우저는 Promise객체를 지원하지 않기 때문에 alert창이 뜬다.

```jsx
if(!window.Promise) {
   alert("구식 브라우저 사용중");
}
```

명세에 있는 기능이지만 해당 기능을 지원하지 않는 오래된 브라우저를 사용하고 있다면 직접 함수를 만들어 전역 객체에 추가하는 방식으로
폴리필을 만들 수 있다.
```jsx
if(!windowPromise) {
   window.Promise = ... // 모던 자바스크립트에서 지원하는 기능을 직접 구현
}
```

### Summary
- 전역 객체를 사용하면 어디서든 접근 가능한 변수를 만들 수 있다. 전역 객체엔 Array와 같은 내장객체, window.innerHeight같은 브라우저 환경 전용 변수 등이 저장되어 있다.
- 전역 객체는 globalThis라는 보편적인 이름으로 불린다.
  하지만 브라우저에서는 window, Node.js에서는 global라는 이름으로 불릴때가 많다. 또한 globalTHis는 추가된지 얼마 안 된 기능이기 때문에 비 크로미움 기반 브라우저에선 지원하지 않는다.
- 프로젝트 전체에서 꼭 필요한 변수만 전역 객체에 저장하고, 전역 변수는 가능한 한 최소한으로 사용하자
- 브라우저에서 var로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다.
- 이해하기 쉽고 요구사항 변경에 쉽게 대응할 수 있는 코드를 구현하려면 window.x처럼 전역 객체의 프로퍼티에 직접 접근하자.

### 객체로서의 함수와 기명 함수 표현식
자바스크립트에서 함수는 값으로 취급된다. 
모든 값은 자료형을 가지고 있다 함수의 자료형은 객체이다.
함수는 호출 가능한 행동 객체라고 이해하면 쉽다. 우리는 함수를 호출할 수 있을 뿐만 아니라 객체처럼 함수에
프로퍼티를 추가 제거하거나 참조를 통해 전달할 수도 있다.

#### name 프로퍼티
함수 객체에는 몇 가지 쓸만한 프로퍼티가 있따.
name 프로퍼티를 사용하면 함수 이름을 가져올 수 있다.
```jsx
fucntion sayHi(){
   alert('Hi);
}
alert(sayHi.name); // sayHi
```

함수 객체에 이름을 할당해주는 로직은 아주 똑똑해서 익명 함수라도 자동으로 이름이 할당된다
```jsx
let sayHi = function () {
   alert("Hi")
};
alert(sayHi.name); sayHi
```

기본 값을 사용해 이름을 할당한 경우에도 마찬가지다.
```jsx
function f(sayHi = function() {}){
   alert(sayHi.name); // sayHi
}
```

자바스크립트 명세서에 정의된 이 기능을 contextual name이라고 부른다.
이름이 없는 함수의 이름을 지정할 떈 컨텍스트에서 이름을 가져온다.

객체 메서드의 이름도 name 프로퍼티를 이용해서 가져올 수 있다.

```jsx
let user = {
   sayHi() {
      // ...
   },
   sayBye: function() {
      //...
   }
}
alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```

배열 안에서 함수를 생성하는 경우 
```jsx
let arr = [function() {}];
alert(arr[0].name); // 빈문자열
// 엔진이 이름을 설정할 수 없어서 name 프로퍼티의 값이 빈 문자열이 된다.
```

### length프로퍼티
내장 프로퍼티 length는 함수 매개변수의 개수를 반환한다. 
```jsx
function f1 (a) {};
function f2 (a,b) {};
function many(a,b,...more) {}

alert(f1.length); //1
alert(f2.length); //2
alert(many.length); //2
```
위처럼 나머지 매개변수는 개수에 포함되지 않는다.
한편, lenth프로퍼티는 다른 함수 안에서 동작하난 함수의 타입을 검사할 때도 종종 사용된다. 

#### 기명 함수 표현식
기명 함수 표현식은 이름이 있는 함수 표현식을 나타내는 용어이다.
먼저 일반 함수 표현식을 살펴보자
```jsx
let sayHi = function(who) {
   alert(`Hello, ${who}`);
}
여기에 이름을 붙여보자.
```jsx
let sayHi = function func(who) {
   alert(`Hello, ${who}`);
}
```

#### 이름을 붙인다고 해서 뭐가 달라질까? 어떤 경우에 func라는 이름을 붙일까?

먼저 이렇게 이름을 붙여줘도 위 함수는 여전히 함수 표현식이다. <br>
func라는 이름을 붙이더라도 여전히 표현식을 할당한 형태를 유지하기 때문에 함수 선언문으로 바뀌지 않는다. <br>
이름을 추가한다고 해서 기존에 동작하던 기능이 동작하지 않는 일은 발생하지 않는다. <br>
sayHi()로 호출하는 것도 여전히 가능하다.  <br>
대신 func와 같은 이름을 붙이면 두 가지 변화가 생긴다. 이 두 변화 때문에 기명 함수 표현식을 사용한다.
1. 일므을 사용해 함수 표현식 내부에서 자기 자신을 참조할 수 있다.
2. 기명 함수 표현식 외부에선 그 이름을 사용할 수 없다.

함수 sayHi()를 예시로 이에 대해 살펴보자.
함수 sayHi는 who에 값이 없는 경우, 인수 "Guest"를 받고 자기 자신을 호출한다.
```jsx
let sayHi = function func(who) {
   if (who) {
      alert(`Hello, ${who}`);
   } else {
      func("Guest"); // func를 사용해서 자기 자신을 호출한다.
   }
}
sayHi(); // Hello, Guest

// 하지만 아래와 같이 func를 호출하는 건 불가능하다.
func(); // Error, func is not defined(기명 함수 표현식 밖에서는 그 이름에 접근할 수 없다.)

그런데 여기서 왜 중첩을 호출할 때 sayHi대신 func를 사용할까? <br>
대부분의 개발자는 아래와 같이 코드를 작성한다
```jsx
let sayHi = function(who) {
   if(who) {
      alert(`Hello, ${who}`);
   } else {
      sayHi("Guest");
   }
}
```

하지만 이렇게 코드를 작성하면 외부 코드에 의해 sayHi가 변경될 수 있다는 문제가 생긴다. 
함수 표현식을 새로운 변수에 할당하고, 기존 변수에 null을 할당하면 에러가 발생한다. 

```jsx
let welcome = sayHi;
sayHi = null;

welcome(); // 중첩 sayHi호출은 더 이상 불가능!
```
에러는 함수가 sayHi르 ㄹ자신의 외부 렉시컬 환경에서 가지고 오기 때문에 발생한다. <br>
지역 렉시컬 환경엔 sayHi가 없기 때문에 외부 렉시컬 환경에서 sayHi를 찾는데 <br>
함수 호출 시점에 외부 렉시컬 환경의 sayHi엔 null이 저장되어 있기 떄문에 에러가 발생한다. <br>

함수 표현식에 이름을 붙여주면 이런 문제를 해결할 수 있다.
```jsx
let sayHi = function func(who) {
   if(who) {
      alert(`Hello, ${who}`);
   } else {
      func("Guest"); // 원하는 값이 제대로 출력된다
   }
}
let welcome = sayHi;
sayHi = null;
welcome(); 
```

func라는 이름은 함수 지역수준에 존재하므로 외부 렉시컬 환경에서 찾지 않아도 된다. 외부 렉시컬 환경에서는 보이지도 않는다.
함수 표현식에 붙인 이름은 현재 함수만 참조하도록 명세서에 정의되어 있기 때문이다.

이렇게 기명 함수 표현식을 이용하면 sayHi나 welcome같은 외부 변수의 변경과 관계없이 func이라는 내부 함수 이름을 사용해
언제든 함수 표현식 내부에서 자기 자신을 호출할 수 있다. 

#### 함수 선언문엔 내부 이름을 지정할 수 없다.
지금까지 살펴본 내부 이름은 함수 표현식에서만 사용할 수 있고, 함수 선언문엔 사용할 수 없다. 함수 선언문엔 내부 이름을 지정할 수 있는 문법이 없다. 
개발을 하다 보면 믿을만한 내부 이름이 필요할 떄가 생기곤 한다. 이 때 바로 함수 선언문을 기명 함수 표현식으로 다시 정의하면 된다.

### summary
함수는 객체이다.
객체로서의 함수에서 사용할 수 있는 프로퍼티 두 가지
- name: 함수의 이름이 저장, 대개는 함수 선언부에서 이름을 가져오는데, 선언부에 이름이 없는 경우엔 자바스크립트 엔진이 컨텍스트(할당 등)을 통해 이름을 추론한다.
- length: 함수 선언부에 있는 인수의 수로 나머지 매개변수는 포함되지 않는다.

함수 표현식으로 함수를 정의하였는데 이름이 있다면 이를 기명 함수 표현식이라 부른다.
기명 함수 표현식의 이름은 재귀 호출과 같이 함수 내부에서 자기 자신을 호출하고자할 때 사용할 수 있다.

함수엔 다양한 프로퍼티를 추가할 수 있다. 널리 쓰이는 자바스크립트 라이브러리 상당수에서 이런 커스텀 프로퍼티를 잘 활용하고 있다.

이런 라이브러리들은 주요 함수 하나를 만들고 여기에 다양한 헬퍼 함수를 붙이는 식으로 구성된다.

이렇게 객체로서의 함수 특징을 이용해 커스텀 프로퍼티를 만들면 함수는 자기 자신을 이용해 원하는 일을 수행할 수 있고, 함수 자기 자신에 딸린 프로퍼티의 기능도 사용할 수 있다는 장점이 있다.

### 과제
#### 숫자 설정과 감소가 가능한 counter 만들기
다음 makeCounter()코드를 수정해서 카운터가 감소하고 숫자를 설정하게 해보세요
- counter()는 다음 숫자를 반환해야 합니다.
- counter.set(value)는 counter를 value로 설정해야 합니다.
- counter.decrease()는 counter를 1 감소시켜야 합니다.

#### 정답
```jsx
function makeCounter() {
    let count = 0;
    function counter () {
      return count ++;
    }
    counter.set = (value) => count = value;
    counter.decrease = () => count --;
    return counter;
  }
```

#### 임의의 수만큼 있는 괄호를 이용해 합계 구하기
다음과 같이 작동하는 함수 sum을 만들어보세요
```jsx
sum(1)(2) == 3; // 1 + 2
sum(1)(2)(3) == 6; // 1 + 2 + 3
sum(5)(-1)(2) == 6
sum(6)(-1)(-2)(-3) == 0
sum(0)(1)(2)(3)(4)(5) == 15
```

#### 정답
```jsx
function sum(a) {
   let sum = a;
   function f(b) {
      sum += b;
      return f;
   }
   f.toString = function () {
      return sum;
   }
   return f;
}
```

이 문제에서 자세히 살펴봐야할 점은 
f() 가 아니라 f를 리턴한다는 것이다.

f는 호출 없이 자기 자신을 그대로 반환한다.
이렇게 자기 자신을 호출하지 않고 반환만 하면 다음 호출에서 함수 f를 사용할 수 있고 
자기 자신을 또다시 반환해 원하는 만큼 이 과정을 반복할 수 있다. 
toString은 sum을 반환해주므로 반환된 함수(객체)를 숫자 혹은 문자열로도 사용할 수 있다. 

------------------

### new Function 문법
함수 표현식과 함수 선언문 이외에 함수를 만들 수도 있는 방법이 하나 더 있다.
잘 사용하는 방법은 아니지만 이 방법 외에는 대안이 없을 떄 사용한다.

### 문법
new Function 문법을 사용하면 함수를 만들 수 있다.
```jsx
let func = new Function ([arg1, arg2, ...argN],functionBody);
```
새로 만들어지는 함수는 인수 arg1...argN과 함수 본문 functionBody로 구성된다.
인수 두 개가 있는 함수를 직접 만들어보면서 이해해보자 

```jsx
let sum = new Function ('a', 'b', 'return a+b');
alert( sum(1,2) ); // 3
```

인수가 없고 함수 본문만 있는 함수도 있다.
```jsx
let sayHi = new Function('alert("Hello")');
sayHi(); // Hello
```

기존에 사용하던 방법과 new Function을 사용해 함수를 만드는 방법의 가장 큰 차이는 
런타임에 받은 문자열을 사용해 함수를 만들 수 있다는 점이다.

함수 표현식과 함수 선언문은 개발자가 직접 스크립트를 작성해야만 함수를 만들 수 있다.

그러나 new FUnction이라는 문법을 사용하면 어떤 문자열도 함수로 바꿀 수 있다.
서버에서 전달받은 문자열을 이용해 새로운 함수를 만들고 이를 실행하는 것도 가능하다.

```jsx
let str = ...서버에서 동적으로 전달받은 문자열(코드 형태)...
let func = new Function(str);
func();
```

여기서 의문?
왜 new Function을 사용해 함수를 만드는건가? <br>
new Function을 사용하면 문자열 형태로 전달받은 코드를 실행할 수 있는 함수 객체를 생성할 수 있다. <br>
예시 
```jsx
// 서버에서 받은 데이터
// 서버에서 동적으로 생성된 코드 조각
let serverData = "return a+b;";

// new Function을 사용하여 함수를 생성
let dynamicFunction = new Function ('a','b', serverData);

// 생성된 함수 실행
let result = dynamicFunction(5,3);
console.log(result); // 8 출력된다.
```

이 방식은 동적으로 생성된 코드를 실행할 때 유용하지만, 보안상의 이유롷 사용에 주의해야한다.
신뢰할 수 없는 데이터를 실행하면 코드 인젝션 공격에 노출될 수 있으니 조심해야한다. 

### 클로저
함수는 틀별한 프로퍼티 [[Environment]]에 저장된 정보를 이용해 자기 자신이 태어난 곳을 기억한다.
[[Environment]]는 함수가 만들어진 렉시컬 환경을 참조한다.

그런데 new Function을 이용해 함수를 만들면 [[Environment]] 프로퍼티가 현재 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 된다.

따라서 new Function을 이용해 만든 함수는 외부 변수에 접근할 수 없고 오직 전역 변수에만 접근할 수 있다.
지금 당장은 new Function이 제공하는 특수한 기능이 익숙하지 않을 수 있는데, 실무에서는 이 기능이 아주 유용하게 쓰인다.

new Function을 이용해 만든 함수의 [[Environment]]는 외부 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하므로 외부 변수를 사용할 수 없다. 단점 같아 보이는 특징이긴 하지만 에러를 에방해 준다는 관점에선 장점이 되기도 한다. 구조상으로는 매개변수를 사용해 값을 받는게 더 낫다. 압축기에 의한 에러도 방지할 수 있다.

### setTimeout과 setInterval을 이용한 호출 스케줄링
일정 시간이 지난 후에 원하는 함수를 예약 실행(호출)할 수 있게 하는 것을 '호출 스케줄링'이라고 한다.
호출 스케줄링을 구현하는 방법은 두 가지가 있다.
- setTimeout을 이용해 일정 시간이 지난 후에 함수를 실행하는 방법
- setInterval을 이용해 일정 시간 간격을 두고 함수를 실행하는 방법

### setTimeout
```jsx
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```

매개변수: <br>
func|code <br>
실행하고자 하는 코드로 <br>
함수 또는 문자열 형태이다. 
대개는 이 자리에 함수가 들어간다. 하위 호환성을 위해 문자열도 받을 수 있게 해놨지만 추천하진 않는다.

delay 
실행 전 대기 시간으로, 단위는 밀리초(millisecond, 1000밀리초 = 1초)이며 기본값은 0이다.

arg1, arg2
함수에 전달할 인수들로 IE9 이하에서는 지원하지 않는다.

아래 예시를 통해 setTimeout 사용법을 알아보자. 

```jsx
function sayHi(){
   alert('안녕하세요');
}
setTimeout(sayHi, 1000);

// 또는
function sayHi(who, phrase) {
   alert(who + ' 님' + phrase)
}
setTimeout(sayHi, 1000, "홍길동", "안녕하세요"); // 홍길동 님 안녕하세요
```

setTimeout의 첫 번째 인수가 문자열이면 자바스크립트는 이 문자열을 이용해 함수를 만든다.
아래 예시가 정상적으로 동작하는 이유이다.
```jsx
setTimeout("alert('안녕')",1000);
```
하지만 이렇게 문자열을 사용하는 방식은 추천하지 않는다 되도록 다음 예시와 같이 익명 화살표 함수를 사용해라
```jsx
setTimeout(() => alert('안녕하세요'),1000);
```

#### 함수를 실행하지 말고 넘겨라
```jsx
// 잘못된 코드
setTimeout(sayHi(),1000);
```
setTimeout은 함수의 참조 값을 받도록 정의되어 있는데 sayHi()를 인수로 전달하면 함수 실행 결과가 전달되어버린다. 
그런데 sayHi()에는 반환문이 없다. 호출 결과는 undefined가 된다.
따라서 setTimeout은 스케줄링할 대상을 찾지 못해 원하는 대로 코드가 동작하지 않는다.

### clearTimeout으로 스케줄링 취소하기
setTimeout을 호출하면 타이머 식별자가 반환된다. 스케줄링을 취소하고 싶을 땐 이 식별자를 사용하면 된다.
```jsx
let timerId = setTimeout(...);
clearTimeout(timerId);
```

아래 예시는 함수 실행을 계획해 놓았다가 중간에 마음이 바꾸어 계획해 놓았던 것을 취소한 상황을 코드로 표현하고 있다.

```jsx
let timerId = setTimeout(()=>alert("아무 일도 일어나지 않는다."),1000)
alert(timerId);

clearTimeout(timerId);
alert(timerId); // 취소 후에도 식별자의 값은 null이 되지 않고 위의 값과 동일하게 알럿창이 실행된다.
```
참고로 Node.js에서 setTimeout을 실행하면 타이머 객체가 반환된다.

### setInterval
setTimeout과 동일한 문법을 사용한다. 인수 역시 동일하다
다만 setTimeout이 함수를 단 한번만 실행하는 것과 달리 setInterval은 함수를 주기적으로 실행하게 만든다.

함수 호출을 준단하려면 clearInterval(timerId)를 사용하면된다.

다음 예시를 실행하면 메시지가 2초 간격으로 보이다가 5초 이후에는 더 이상 메시지가 보이지 않는다. 

```jsx
let timerId = setInterval(()=>alert('째깍'),2000);

// 5초 후에 정지
setTimeout(()=>clearInterval(timerId),5000)
```

#### alert창이 떠있더라도 타이머는 멈추지 않는다. 

### 중첩 setTimeout
무언가를 일정 간격을 두고 실행하는 방법에는 크게 2가지가 있다.
하나는 setInterval을 이용하는 방법이고 다른 하나는 중첩 setTimeout을 이용하는 방법이다.

```jsx
let timerId = setTimeout(function tick(){
   alert('째깍');
   timerId = setTimeout(tick,2000);
},2000)
```
중첩 setTimeout을 이용하면 setInterval을 사용하는 방법보다 유연하다.
호출 결과에 따라 다음 호출을 원하는 방식으로 조정해 스케줄링 할 수 있기 떄문이다.

5초 간격으로 서버에 요청을 보내 데이터를 얻는다고 가정해보자
서버가 과부하 상태라면 요청 간격을 10초 20초 40초 등으로 증가시켜주는게 좋다.

```jsx
let delay = 5000;
let timerId = setTimeout(function request(){
   ...요청 보내기...
   if(서버 과부하로 인한 요청 실패)
   delay *=2;
   timerId = setTimeout(request,delay);
},delay)
```

CPU소모가 많은 작업을 주기적으로 실행하는 경우에도 setTimeout을 재귀 실행하는 방법이 유용하다.
작업에 걸리는 시간에 따라 다음 작업을 유동적으로 계획할 수 있기 떄문이다.

중첩 setTimeout을 이용하는 방법은 지연 간격을 보장하짐나 setInterval은 이를 보장하지 않는다.
setInterval은 func를 실행하는데 소모되는 시간도 지연 간격에 포함시킨다.
따라서 func를 실행하는 데 걸리는 시간이 명시한 지연 간격보다 길 때
func의 실행이 종료될때까지 기다려준다.
실행이 종료되면 엔지는 스케줄러를 확인하고 지연 시간이 지났으면 다음 호출을 바로 시작한다.
따라서 함수 호출에 걸리는 시간이 매번 delay밀리초보다 길면 모든 함수가 쉼 없이 계속 연속 호출을 한다.

한편 중첩 setTimeout을 이용하면
명시한 지연시간이 보장된다.
이렇게 지연 간격이 보장되는 이유는 이전 함수의 실행이 종료된 이후에 다음 함수 호출에 대한 계획이 세워지기 떄문이다.


#### 가비지 컬렉션과 setInterval setTimeout
setInterval이나 setTimeout에 함수를 넘기면, 함수에 대한 내부 참조가 새롭게 만들어지고 이 참조 정보는 스케줄러에 저장된다. 따라서 해당 함수를 참조하는 것이 없어도 setInterval 과 setTimeout에 넘긴 함수는
가비지 컬렉션의 대상이 되지 않는다.

setTimeout은 스케줄러가 함수를 호출할때까지 함수는 메모리에 유지된다. <br>
setInterval의 경우는 clearInterval이 호출되기 전까지 함수에 대한 참조가 메모리에 유지된다. <br>

그런데 이런 동작 방식에는 부작용이 있는데, <br>
외부 렉시컬 환경을 참조하는 함수가 있다고 가정했을 때 이 함수가 메모리에 남아있는 동안엔 외부 변수 역시 메모리에 남아있기 마련이다. 그런데 이렇게 되면 실제 함수가 차지했어야 하는 공간보다 더 많은 메모리 공간이 사용된다.

이런 부작용을 방지하고 싶다면 스케줄링 할 필요가 없어진 함수는 아무리 작더라도 취소해야한다

### 대기시간이 0인 setTimeout
이렇게 대기 시간을 0으로 설정하면 func를 가능한 한 빨리 실행할 수 있다.
다만, 이떄 스케줄러는 현재 실행 중인 스크립트의 처리가 종료된 이후에 스케줄링한 함수를 실행한다.
이런 특징을 이용하면 현재 스크립트의 실행이 종료된 직후에 원하는 함수가 실행될 수 있게 할 수 있다. 

#### 브라우저 환경에서 실제 대기 시간은 0이 아니다
브라우저는 HTML5 표준에서 정한 중첩 타이머 실행 간격 제약을 준수한다.
해당 표준에는 다섯 번째 중첩 타이머 이후엔 대기 시간을 최소 4밀리미초 이상으로 강제해야 한다 라는 제약이 있다.

이런 제약은 setTImeout뿐만 아니라 setInterval에도 적용된다.
setInterval(f)도 처음 몇 번은 함수 f를 지연 없이 실행하지만 
나중엔 지연 간격을 4밀리초 이상으로 늘려버린다.

한편 서버 측엔 이런 제약이 없다. node.js의 prcess.nextTick과 setImmediate를 이용하면 
비동기 작업을 지연 없이 실행 할 수 있다.

위에서 언급된 제약은 브라우저에 한정된다.

### summary
- setInterval(func, delay, ...args)과 setTimeout(func, delay, ...args)은
  delay 밀리초 후에 func를 규칙적으로 또는 한 번 실행하도록 해준다.
- setInterval, setTimeout을 호출하고 반환받은 값을 clearInterval, clearTimeout에 넘겨주면 스케줄링을 취소할 수 있다.
- 중첩 setTimeout을 사용하면 setInterval을 사요한 것보다 유연하게 코드를 작성할 수 있다. 여기에 더하여 지연 간격 보장이라는 장점도 있다.
- 대기 시간이 0인 setTimeout을 사용함녀 현재 스크립트의 실행이 완료된 후 가능한 빠르게 원하는 함수를 호출할 수 있다.
- 지연 없이 중첩 setTimeout을 5회 이상 호출하거나 지연 없는 setInterval 에서 호출이 5회 이상 이루어지면 4밀리초 이상의 지연 간격이 강제로 더해진다. 이는 브라우저에만 적용되는 사항이며 하위 호환성을 위해 유지되고 있다.

스케줄링 메서드를 사용할 땐 명시한 지연 간격이 보장되지 않을 수 있다는 점에 유의해야한다.
아래와 같은 상황에서 브라우저 내 타이머가 느려지면 지연 간격이 보장되지 않는다
- CPU가 과부하 상태인 경우
- 브라우저 탭이 백그라운드 모드인 경우
- 노트북이 배터리에 의존해서 구동 중인 경우
  이러한 상황에서 타이머의 최소 지연 시간은 300밀리초에서 심하면 1000밀리초까지 늘어난다.
  연장 시간은 브라우저나 구동중인 운영체제의 성능 설정에 따라 다르다.

### 과제
#### 일초 간격으로 숫자 출력하기
```jsx
function printNumbers(from,to){
   let current = from;
   let timerId = setInterval(function(){
      alert(current);
      if(current == to{
         clearInterval(timerId)
      }
      current ++
   },1000)
}
PrintNumbers(5,10)

function printNumbers(from,to){
   let current = from;
   let timerId = setTimout(function go(){
      alert(current);
      if(current < to){
         setTimeout(go,1000)
      }
      current ++;
   },1000)
}
```
두 방법 모두에서 최초 호출 이전에(첫 알럿창이 뜨기 전에) 1000ms의 지연 간격을 두고있다
초기 지연 없이 함수를 바로 실행하려면 아래와 같이 별도의 줄에서 함수를 호출해줘야한다.
```jsx
function printNumbers(from,to){
   let current = from;
   function go(){
      alert(current);
      if(current == to) {
         clearInterver(timerId)
      }
   go();
   let timerId = setInterval(go,1000);
   }
}
```

### call/apply와 데코레이터, 포워딩
자바스크립트는 함수를 다룰 때 탁월한 유연성을 제공한다. 함수는 이곳저곳 정달될 수 있고 
객체로도 사용될 수 있다. 이번 챕터에선 함수 간에 호출을 어떻게 포워딩 하는지 함수를 어떻게 데코레이팅 하는지에 대해 알아보겠다. 

### 코드 변경 없이 캐싱 기능 추가하기
CPU를 많이 잡아먹지만 결과는 안정적인 함수 slow(x)가 있다고 가정해보자.
결과가 안정적이라는 말은 x가 같으면 호출 결과도 같다는 것을 의미한다.
slow(x)가 자주 호출된다면 결과를 어딘가에 저장(캐싱)해 재연산에 걸리는 시간을 줄이고 싶을 것이다.
아래 예시에서는 slow()안에 캐싱 관련 코드를 추가하는 대신, 래퍼 함수를 만들어 캐싱 기능을 추가할 에정이다.
곧 정리하겠지만 이렇게 래퍼 함수를 만들면 여러 가지 이점이 있다.

```jsx
function slow(x) {
   // CPU 집약적인 작업
   alert(`slow${x} 츨 호출함`);
   return x;
}

function cachingDecorator(func) {
   let cache = new Map();
   
   return function(x) {
      if (cache.has(x)) {
         return cache.get(x); // 대응하는 값을 cache에서 읽어옵니다.
      }   
      let result = func(x); // 그렇지 않은 경우엔 func를 호출하고,

      cache.set(x, result); // 그 결과를 캐싱(저장)합니다. 
      return result;
   }
}
```

cachingDecorator같이 인수로 받은 함수의 행동을 변경시켜주는 함수를 데코레이터라고 부른다.

모든 함수를 대상으로 cachingDecorator를 호출할 수 있는데 이때 반환되는 것은 캐싱 래퍼이다.
함수에 cachingDecorator을 적용하기만 하면 캐싱이 가능한 함수를 원하는 만큼 구현할 수 있기 때문이다.
데코레이터 함수는 아주 유용하게 사용된다.
캐싱 관련 코드를 함수 코드와 분리할 수 있기 때문에 함수의 코드가 간결해진다는 장점도 있다.

아래 그림에서 볼 수 있듯 cachingDecorator(func)를 호출하면 래퍼(wrapper), function(x)이 반환된다. 
래퍼 function(x)는 func(x)의 호출 결과를 캐싱 로직으로 감싼다. 

바깥 코드에서 봤을 때 함수 slow는 래퍼로 감싼 이전이나 이후나 동일한 일을 수행한다.
행동 양식에 캐싱 기능이 추가된 것 뿐이다.

slow본문을 수정하는 것보다 독립된 래퍼 함수를 사용할 때 생기는 이점을 정리하면 다음과 같다.
- cahingDecorator를 재사용할 수 있다. 원하는 함수 어디에든 cachingDecorator를 적용할 수 있다.
- 캐싱 로직이 분리되어 slow자체의 복잡성이 증가하지 않는다.
- 필요하다면 여러 개의 데코레이터를 조합해서 사용할 수도 있다.(추가 데코레이터는 cachingDecorator뒤를 따른다)

### `func.call`를 사용해 컨텍스트 지정하기
위에서 구현한 캐싱 데코레이터는 **객체 메서드**에 사용하기엔 적합하지 않다.
객체 메서드 worker.slow()는 데코레이터 적용 후 제대로 동작하지 않는다.

원인은 `let result = func(x)`이부분에서
래퍼가 기존함수 func(x)를 하면 this가 undefined가 되기 때문이다. 

래퍼가 기존 메서드 호출 결과를 전달하려했지만 this의 컨텍스트가 사라졌기 때문에 에러가 발생하는 것이다.

먼저, this를 명시적으로 고정해 함수를 호출할 수 있게 해주는 특별한 내장 함수 메서드에 대해 알아보자.

문법은 `func.call(context, arg1, arg2,...)`
메서드를 호출하면 첫 번째 인수가 this, 이어지는 인수가 func의 인수가 된 후, func가 ㅗ출된다.

아래 함수와 메서드를 호출하면 거의 동일한 일이 발생한다.
```jsx
func(1,2,3);
func.call(obj, 1,2,3)
```
둘 다 인수로 1,2,3을 받는다 유일한 차이점은 func.call에서는 this가 obj로 고정된다는 점이다. 

다른 컨텍스트(다른 객체)하에 sayHi를 호출하는 예시를 살펴보자.
sayHi.call(user)를 호출하면 sayHi의 컨텍스트가 this=user로, sayHi.call(admin)을 호출하면 sayHi의 컨텍스트가 this = admin으로 설정된다. 

```jsx
function sayHi() {
   alert(this.name);
}
let user = { name: "John" };
let admin = { name: "Admin" };

// call 을 사용해 원하는 객체가 this가 되도록 하자
sayHi.call( user ); // this = John
sayHi.call( admin ); // this = Admin
```

아래 예시에선 call을 사용해 컨텍스트와 phrase에 원하는 값을 지정해 보았다.

```jsx
function say(phrase) P{
   alert(this.name + ':' + phrase);
}
let user = { name: "John" };

// this엔 user가 고정되고, "Hello"는 메서드의 첫 번째 인수가 된다.
say.call( user, "Hello" )// John: Hello
```

래퍼 안에서 call을 사용해 컨텍스트를 원본 함수로 전달하면 에러가 발생하지 않는다.

```jsx
let worker = {
   someMethod(){
      retunrn 1;
   },
   slow(x) {
      alert(`slow${x} 를 호출함`);
      return x * this.someMethod();
   }
};

fucntion cachingDecorator(func){
   let cache = new Map();
   return function(x) {
      if(cache.has(x)){
         return cache.get(x);
      }
      let result = func.call(this,x) // 이젠 this가 제대로 전달된다.
      cache.set(x,result);
      return result;
   }
}

worker.slow(cachingDecorator(worker.slow); // 캐싱 데코레이터 적용

alert(worker.slow(2)); //제대로 동작
```

이제 에러 없이 모든게 정상적으로 동작한다.
명확한 이해를 위해 this가 어떤 과정을 거쳐 전달되는지 자세히 살펴보자.
1. 데코레이터를 적용한 후에 worker.slow는 래퍼 function(x) {...}가 된다.
2. worker.slow(2)를 실행하면 래퍼는 2를 인수로 받고 this = worker가 된다.
3. 결과가 캐시되지 않은 상황이라면 func.call(this,x)에서 현재 this(=worker)와 인수(=2)를 원본 메서드에 전달한다.

### 여러 인수 전달하기
cachingDecorator를 좀 더 다채롭게 해보자.
지금 상태로는 인수가 하나뿐인 함수에만 cachingDecorator을 적용할 ㅅ 있따.

복수 인수를 가진 worker.slow를 캐싱하려면 어떻게 해야할지 생각해보자.

let worker = {
   slow(min, max) {
      return min + max; // CPU를 많이 쓰는 작업으로 가정
   }
};

worker.slow = cachingDecoraotr(worker.slow);

지금까지는 인수가 x하나 뿐이었기 때문에 cache.set(x,result)로 결과를 저장하고
cache.get(x)으로 저장된 결과를 불러오기만 하면 됐다.
그런데 이제부턴 (min, max)같이 인수가 여러 개이고, 이 인수들을 넘겨 호출한 결과를 기억해야 한다.

해결 방법은 여러 가지이다.
1. 복수 키를 지원하는 맵과 유사한 자료 구조 구현하기
2. 중첩 맵을 사용하기.(max,result)쌍 저장은 cache.set(nim)으로, result는 cache.get(min).get(max)를 사용해 얻는다.
3. 두 값을 하나로 합치기. 맵의 키로 문자열 "min,max"를 사용한다.
   여러 값을 하나로 합치는 코드는 해싱 함수에 구현해 유연성을 높인다.

세 번째 방법만으로 충분하기 때문에 이 방법으로 코드를 수정해보자.
여기에 더하여 func.call(this,x)를 func.call(this,...arguments)로 교체해
래퍼 함수로 감싼 함수가 호출될 때 복수 인수로 넘길 수 있도록 해보겠다.

```jsx
let worker = {
   slow(min, max) {
      alert(`slow(${min},${max})을/를 호출함`);
       return min + max;
   }
}
function cachingDecorator(func, hash) {
   let cache = new Map();
   return function () {
      let key = hash(arguments);
      if(cache.has(key)) {
         return cache.get(key);
      }
      let result = func.call(this, ...arguments); // (**)

      cache.set(key,result);
      return result;
   }
}

function hash(args) {
   return args[0] + `,` + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3,5) ); // 제대로 동작한다.
alert("다시 호출: " + worker.slow(3,5)); // 동일한 결과 출력(캐시된 결과 출력)

```

이제 인수의 개수에 관계없이 래퍼가 잘 동작한다.
하지만 해시 함수가 두 개의 인수로만 동작한다. 이를 가능하게 해주는 방법은 아래서 정리하겠다.

개선 후 바뀐 것은 두 가지이다.
- hash가 호출되면서 arguments를 사용한 단일 키가 만들어진다. 여기선 간달한 결합 함수로 인수(3,5)를 키 "3,5"로 바꿨는데 좀 더 복잡한 경우라면 또 다른 해싱 함수가 필요할 수 있다.
- (**)로 표시한 줄에선 func.call(this, ...arguments)를 사용해 컨텍스트(this)와 래퍼가 가진 인수 전부(...arguments)를 기존 함수에 전달했다.

  ### func.apply
  그런데 여기서 func.call(this, ...arguments)대신 func.apply(this,arguments)를 사용해되된다.

```jsx
func.apply(context,args)
```

apply는 func의 this를 context로 고정해주고, 유사 배열 객체인 args를 인수로 사용할 수 있게 해준다. 

call과 apply의 문법적 차이는 call이 복수 인수를 따로따로 받는 대신 apply는 인수를 유사 배열 객체로 받는다는 점 뿐이다.

따라서 아래 코드 두 줄은 거의 같은 역할을 한다.

```jsx
   func.call(context, ...args);
   func.apply(context, args);
```
그런데 약간의 차이가 있긴 하다.
- 전개 구문 ...은 이터러블 args를 분해해 call에 전달할 수 있도록 해준다.
- apply는 오직 유사 배열 형태의 args만 받는다.

이 차이만 빼면 두 메서드는 완전히 동일하게 동작한다. 인수가 이터러블 형태라면 call을, 유사 배열 형태라면 apply를 사용하면 된다.

배열같이 이터러블이면서 유사 배앨인 객체엔 둘 다를 사용할 수 있는데, 대부분의 자바스크립트 엔진은 내부에서 apply를 최적화 하기 때문에 apply를 사용하는 게 좀 더 빠르긴 하다. 

이렇게 컨텍스트와 함꼐 인수 전체를 다른 함수에 전달하는 것을 콜 포워딩이라고 한다. 

가장 간단한 형태의 콜 포워딩은 다음과 같다
```jsx
let wrapper = function() {
   return func.apply(this, arguments);
};
```

이런 식으로 외부에서 wrapper를 호출하면, 기존 함수인 func를 호출하는 것과 명확하게 구분할 수 없다.

### 메서드 빌리기 
위에서 구현한 해싱 함수를 개선해보자
```jsx
function hash(args){
   return args[0] + ',' + args[1];
}
```

지금 상태에선 인수 두 개만 다룰 수 있다. 
args의 요소 개수에 상관없이 요소들을 합칠 수 있으면 좋겠다.
가장 자연스러운 해결책은 배열 메서드 arr.join을 사용하는 것이다.

```jsx
function hasn(args) {
   return args.join();
}
```
그런데 아쉽게도 이 방법은 동작하지 않는다. hash(arguments)를 호출할 때 인수로 넘겨주는 arguments는 진짜 배열이 아니고 이터러블 객체나 유사 배열 객체이기 때문이다.

배열이 아닌 것에 join을 호출하면 에러가 발생한다.

```jsx
function hash() {
   alert(arguments.join()); Error: arguments.join is not a function
}
hash(1,2);
```

그런데 아래와 같은 방법을 사용하면 배열 메서드 join을 사용할 수 있다.
```jsx
function hash() {
   alert( [].join.call(arguments) ); 
}
hash(1,2)
```

일반 배열에서 join메서드를 빌려오고([].join), [].join.call를 사용해 arguments를 컨텍스트로 고정한 후 join메서드를 호출하는 방법이다.

내부 알고리즘이 구현되어 있기 떄문에 어떤 유사 배열이던 this가 될 수 있다.
상당수의 메서드가 이런 관습을 따르고 있다.

### 데코레이터와 함수 프로퍼티
함수 또는 메서드를 데코레이터로 감싸 대체하는 것은 대체적으로 안전하다.
그런데 원본 함수에 func.calledCount등의 프로퍼티가 있으면 데코레이터를 적용한 함수에선
프로퍼티를 사용할 수 없으므로 안전하지 않는다.
함수에 프로퍼티가 있는 경우엔 데코레이터 사용에 주의해야한다.

위 예시에서 함수 slow에 프로퍼티가 있었다면 cachingDecorator(slow)호출 결과인 
래퍼엔 프로퍼티가 없을 것이다.
즉, 데코레이터를 적용하면 원본 함수의 프로퍼티에 접근할 수 없으므로, 함수에 프로퍼티가 있는 경우에는 데코레이터 사용에 주의해야한다.

몇몇 데코레이터는 자신만의 프로퍼티를 갖기도 한다.
데코레이터 함수가 얼마나 많이 호출되었는지 세거나 호출시 얼마나 많은 시간이 소모되었는지 등의 정보를 래퍼의 프로퍼티에 저장할 수 있다

함수 프로퍼티에 접근할 수 있게 해주는 데코레이터를 만드는 방법도 있다.
그런데 이걸 구현하려면 Proxy라는 특별한 객체를 사용해 함수를 감싸야한다.

### Summary
데코레이터는 함수를 감싸는 래퍼로 함수의 행동을 변화시킨다.
주요 작업은 여전히 함수에서 처리힌다.
데코레이터는 함수에 추가도니 기능 혹은 '상(aspect)'정도로 보면된다.
하나 혹은 여러 개의 데코레이터를 추가해도 함수의 코드는 변경되지 않는다.

cachingDecorator는 아래와 같은 메서드를 사용해 구현하였다. 
- func.call(context, arg1, arg2...): 주어진 컨텍스트오 ㅏ인수를 사용해 func를 호출한다.
- func.apply(context,args) : this에 context가 할당되고 유사 배열 args가 인수로 전달되어 func가 호출된다.

콜 포워딩은 대게 apply를 사용해 구현한다.
```jsx
let wrapper = function () {
   return original.apply(this,arguments);
}
```
특정 객체에서 메서드를 가져오고, 다른 객체를 컨텍스트로 고정한 후 함수를 호출(call)하는 형태인 메서드 빌리기에 대한 예제도 살펴보았다.
메서드 빌리기는 배열 메서드를 빌려서 이를 arguments에 적용할 때 흔히 사용된다.
나머지 매개변수와 배열을 함께 사용하면 유사한 기능을 구현할 수 있다.

### 하수 바인딩
setTimeout에 메세드를 전달할 때처럼, 객체 메서드를 콜백으로 전달할 때 
this정보가 사라지는 문제가 생긴다.

### 사라진 'this'
앞서 다양한 예제를 통해 this정보가 사라지는 문제를 경험해보았다.
객체 메서드가 객체 내부가 아닌 다른 곳에 전달되어 호출되면 this가 사라진다.

setTimeout을 사용한 아래 예시에서 this가 어떻게 사라지는지 살펴보자
```jsx
let suer = {
   firstName: "John",
   sayHi(){
      alert(`Hello, ${this.firstName}!`);
   }
};

setTimeout(user.sayHi,1000); // Hello, undefined!
```

this.firstName이 'John'이 되어야 하는데 얼럿창엔 undefined가 출력된다.
이렇게 된 이유는 setTimeout에 객체에서 분리된 함수인 user.sayHi가 전달되기 때문이다.

```jsx
let f = user.sayHi;
setTimeout(f,1000); // user컨텍스트를 잃어버림
```

브라우저 환경에서 setTimeout메서드는 조금 특별한 방식으로 동작한다.
인수로 전달받은 함수를 호출할 때, this에 window를 할당한다.
(Node.js환경에서는 this가 타이머 객체가 되는데 여기선 중요하지 않음)
따라서 위 예시의 this.firstName은 window.firstName가 되는데
window객체엔 firstName이 없으므로 undefined가 출력된다.
다른 유사한 사례에서도 대부분 this는 undefined가 된다.

객체 메서드를 실제 메서드가 호출되는 곳(예시에선setTimeout스케줄러)으로 전달하는 것은 아주 흔하다.
이렇게 메서드를 전달할 때 컨텍스트도 제대로 유지하려면 어떻게 해야할까?

### 방법 1: 래퍼
가장 간단한 해결책은 래퍼 함수를 사용하는 것이다. 
```jsx
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Hello, John!
}, 1000);
```

위 예시가 의도한 대로 동작하는 이유는 외부 렉시컬 환경에서 user를 받아서 보통 때처럼
메서드를 호출했기 떄문이다. 

또한 아래와 같이 바꿀 수 있다.
```jsx
setTimeout(() => user.sayHi(), 1000); // Hello, John!
```

이렇게 코드를 작성하면 간결해져서 보기는 좋지만 약간의 취약성이 생긴다.
setTimeout이 트리거 되기 전에(1초가 지나기 전에) user가 변경되면 변경된 객체의 메서드를 호출하게된다. 

### 방법 2: bind
모든 함수는 this를 수정하게 해주는 내장 메서드 bind를 제공한다.
기본 문법은 다음과 같다.
let boundFunc = func.bind(context);

func.bind(context)는 함수처럼 호출 가능한 특수 객체를 반환한다.
이 객체를 호출하면 this가 context로 고정된 함수 func가 반환된다.

따라서 boundFunc를 호출하면 this가 고정된 func를 호출하는 것과 동일한 효과를 본다.

아래 funcUser에는 this가 user로 고정된 func이 할당된다.

```jsx
let user = {
   firstName: "John"
};

function func() {
   alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // John
```

여기서 func.bind(user)는 func의 this를 user로 바인딩한 변형이라고 생각하면 된다.
인수는 원본 함수 func에 그대로 전달된다. 

객체 메서드에 bind를 적요해보자.
```jsx
let user = {
   firstName: "John",
   sayHi() {
      alert(`Hello, ${this.firstName}!`);
   }
}
let sayHi = user.sayHi.bind(user); (*)

// 이제 객체 없이도 객체 메서드를 호출할 수 있다.
sayHi(); // Hello, John!

setTimeou(sayHi, 1000); //  Hello, John!

// 1초 이내에 user값이 변화해도
// sayHi는 기존 값을 사용한다.

user = {
   sayHi() {alert("또 다른 사용자!")}
}
```
(*)로 표시한 줄에서 메서드 user.sayHi를 가져오고, 메서드에 suer를 바인딩한다.
sayHi는 이제 묶인(bound)함수가 되어 단독으로 호출할 수 있고 setTimeout에 전달하여 호출할 수도 있다. 어떤 방식이던 컨텍스트는 원하는대로 고정된다.

아래 예시를 실행하면 인수는 그대로 전달되고 bind에 의해 this만 고정된다. 

```jsx
let uer = {
   fistName: "John",
   say(phrase) {
      alert(`${phrase}, ${this.firstName}!`);
   }
}
let say = user.say.bind(user);

say("Hello"); Hello, John
say("Bye");  Bye, John
```

#### bindAll로 메서드 전체 바인딩하기
객체에 복수의 메서드가 있고 이 메서드 전체를 전달하려 할 땐, 반복문을 사용해 메서드를 바인딩할 수 있다.

```jsx
for(let key in user) {
   if(typeof user[key] == 'function'){
      user[key] = user[key].bind(user);
   }
}
```

### 부분 적용
지금까진 this바인딩에 대해서만 이야기해보았다. 
this뿐만 아니라 인수도 바인딩이 가능하다.
인수 바인딩은 잘 쓰이진 않지만 가끔 유용할 때가 있따.

bind의 전체 문법은 다음과 같다.

```jsx
let bound = func.bind(context,[arg1],[arg2],...);
```
bind는 컨테스트를 this로 고정하는 것 뿐만 아니라 함수의 인수도 고정해준다.

```jsx
function mul (a,b){
   return a * b;
}

let double = mul.bind(null, 2);

alert(double(3));  // 6
alert(double(4)); // 8
```

mul.bind(null,2)를 호출하면 새로운 함수 double이 만들어진다.
double엔 컨텍스트가 null, 첫 번째 인수는 2인 mul의 호출 결과가 전달된다.
추가 인수는 그대로 전달된다.

이러한 방식을 부분 적용이라고 부른다.
부분 적용을 사용하면 기존 함수의 매개변수를 고정하여 새로운 함수를 만들 수 있따.

위 예시에선 this를 사용하지 않았다는 점에 주목
bind엔 컨텍스트를 항상 넘겨줘야 하므로 null을 사용했다.

부본 적용을 사용해 3을 곱해주는 함수 triple을 만들어 보자

```jsx
function mul (a,b) {
   return a*b;
}
let triple = mu.bind(null,3);
alert( triple(3) ); // = mul(3, 3) = 9
alert( triple(4) ); // = mul(3, 4) = 12
```

그런데 부분 함수는 왜 만드는걸까?
가독성이 좋은 이름( double, triple ) 을 가진 독립 함수를 만들 수 있다는 이점 떄문이다.
게다가 bind를 사용해 첫 번째 인수를 고정할 수 있기 때문에 매번 인수를 전달할 필요도 없어진다.

이 외에도 부분 적용은 매우 포괄적인 함수를 기반으로 덜 포괄적인 변형 함수를 만들 수 있다는 점에서 유용하다.

함수 send(from, to, text)가 있다고 가정해보자
객체 user안에서 부분 적용을 활용하면 전송 주체가 현재 사용자인 함수 sendTo(to, text)를 구현할 수 있다.

### 컨텍스트 없는 부분 적용
인수 일부는 고정하고 컨텍스트 this는 고정하고 싶지 않다면? <br>
네이티브 bind만으로는 컨텍스트를 생략하고 인수로 바로 뛰어넘지 못한다.
다행히도 인수만 바인딩해주는 헬퍼함수 partial를 구현하는 건 쉽다.

```jsx
function partial(func, ...argsBound){
   return function (...args) {
      return func.call(this, ...argsBound, ...args);
   }
}
// 사용법
let user = {
   firstName : "John",
   say(time, phrase) {
      alert(`[${time}] ${this.firstName}: ${phrase}!`);
   }
}

// 시간을 고정한 부분 메서드를 추가
user.sayNow = partial(user.say, new Date().getHours());

user.sayNow("Hello"); // [10] John: Hello!
```

### 화살표 함수 다시 살펴보기
화살표 함수는 단순히 함수를 짧게 쓰기 위한 용도로 사용되지 않는다. <br>
화살표 함수는 몇 가지 독특하고 유용한 기능을 제공한다.

자바스크립트를 사용하다 보면 저 멀리 동떨어진 곳에서 실행도리 작은 함수를 작성해야 하는 상황을 자주 만나게 된다.

ex) 
- arr.forEach(func) - func는 forEach가 호출될 때 배열 arr의 요소 전체를 대상으로 실행된다.
- setTimeout(func) - func는 내장 스케줄러에 의해 실행된다.
- 기타 등등...

이처럼 자바스크립트에선 함수를 생성하고 그 함수를 어딘가에 전달하는 것이 아주 자연스럽다.
그런데 어딘가에 함수를 전달하게 되면 함수의 컨텍스트를 잃을 수 있다. 
이럴 때 화살표 함수를 사용하면 현재 컨텍스트를 잃지 않아 편리하다.

#### 화살표 함수에는 'this'가 없다.
화살표 함수 본문에서 this에 접근하면 외부에서 값을 가져온다.
이런 특징은 객체의 메서드(showList())안에서 동일 객체의 포로퍼티(studuents)를 대상으로 순회를 하는 데 사용할 수 있다.

```jsx
let group = {
   title: "1모둠",
   students: ["보라", "호진", "지민"],
   showList() {
      this.students.forEach(
         student => alert(this.title + ':' + student)
      )
   }
}
group.showList();
```

예시의 forEach에서 화살표 함수를 사용했기 때문에 화살표 함수 본문에 있는 this.title은 화살표 함수 바깥에 있는 메서드인 showList가 가리키는 대상과 동일해진다.
즉, this.title은 group.title과 같다.

위 예시에서 화살표 함수 대신 '일반'함수를 사용했다면 에러가 발생했을 것이다.
에러는 forEach에 전달되는 함수의 this가 undefined 이어서 발생했다. 

화살표 함수는 this자체가 없기 때문에 이런 에러가 발생하지 않는다.

#### 화살표 함수는 `new`와 함께 실행할 수 없다.
this가 없기 때문에 화살표 함수는 생성자 함수로 사용할 수 없다는 제약이 있다.
화살표 함수는 new와 함께 호출할 수 없다.

#### 화살표 함수 vs bind
화살표 함수와 일반 함수를 .bind(this)를 사용해서 호출하는 것 사이에는 미묘한 차이가 있다.
- .bind(this)는 함수의 한정된 버전을 만든다.
- 화살표 함수는 어떤 것도 바인딩시키지 않는다. 화살표 함수엔 단지 this가 없을 뿐이다. 화살표 함수에서 this를 사용하면 일반 변수 서칭과 마찬가지로 this의 값을 외부 렉시컬 환경에서 찾는다.

#### 화살표 함수엔 arguments가 없다. 
화살표 함수에는 일반 함수와는 다르게 모든 인수에 접근할 수 있게 해주는 유사 배열 객체 arguments를 지원하지 않는다.
이런 특징은 현재 this값과 arguments정보를 함께 실어 호출을 포워딩해주는 데코레이터를 만들 때 유용하게 사용된다.

아래 예시에서 데코레이터 defer(f,ms)는 함수를 인자로 받고 이 함수를 래퍼로 감싸 반환하는데, 
함수 f는 ms초 후에 호출된다.

```jsx
function defer(f,ms){
   return function () {
      setTimeout(()=> f.apply(this, arguments), ms)
   }
}
function sayHi(who) {
   alert('안녕, ' + who);
}
let sayHiDeferred = defer(sayHi, 2000);
satGuDeferred("철수"); // 2초 뒤 안녕, 철수 가 출력된다.
```

화살표 함수를 사용하지 않고 동일한 기능을 하는 데코레이터 함수를 만들면 다음과 같다
```jsx
function defer(f,ms) {
   return function(...args){
      let ctx = this;
      setTimeout(function(){
         return f.apply(ctx,args);
      },ms)
   }
}
```
일반 함수에선 setTimeout에 넘겨주는 콜백함수에서 사용할 변수 ctx와 args를 반드시 만들어줘야한다.

### Summary 
화살표 함수가 일반 함수와 다른 점은 다음과 같다.
- this를 가지지 않는다.
- arguments를 지원하지 않는다.
- new와 함께 호출할 수 없다.
- 이 외에도 화살표 함수는 super가 없다는 특징도 있다.
화살표 함수는 컨텍스트가 있는 긴 코드보다는 자체 컨텍스트가 없는 짧은 코드를 담을 용도로 만들어졌따.
그리고 이 목적에 잘 들어맞는 특징을 보인다.
