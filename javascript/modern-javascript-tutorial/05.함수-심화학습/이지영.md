### 4주차 - 함수 심화학습
#### 6-1 재귀와 스택
재귀는 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴이다. <br>
목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀를 사용할 수 있다. <br>
또한 특정 자료구조를 다뤄야 할 때도 재귀가 사용된다. <br>

문제를 해결하다 보면 함수에서 다른 함수를 호출해야 할 때가 있다. <br>
이때 함수가 자기 자신을 호출할 수도 있는데, 이를 재귀라고 부른다. <br>

#### 두 가지 사고방식
재귀의 간단한 예시
x를 n제곱해 주는 함수 pow(x,n)를 만들어보자 
<br>
구현하는 방법은 두 가지가 있다
1. 반복적인 사고를 통한 방법: for 루프
```jsx
   function pow(x, n) {
       let result = 1;
       // 반복문을 돌면서 x를 n번 곱함
        for(let i = 0; i < n; i ++) {
          result *= x;
        }
      return result;
   }
alert ( pow (2,3) ) // 8
```

2. 재귀적인 사고를 통한 방법: 작업을 단순화하고 자기 자신을 호출함
```jsx
function pow(x,n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow( x, n-1);
  }
}
```

재귀 사용한 예시와 반복문을 사용한 예시와 어떤 부분에서 차이가 있는지 알아보자
1. n == 1일 때 : 모든 절차가 간단해진다. 명확한 결괏값을 즉시 도출하므로 이를 재귀의 베이스 라고한다.
2. n == 1이 아닐 때: pow(x,n)은 x * pow (x, n-1) 로 표현할 수 있다. 이를 재귀단계라고 부른다.
   즉, pow는 n == 1이 될 때가지 재귀적으로 자신을 호출한다.<br>
   이렇게 재귀를 이용하면 함수 호출의 결과가 명확해질 때까지 함수 호출을 더 간단한 함수 호출로 계속 줄일 수 있다. <br>
   또한 재귀를 사용한 코드는 반복적 사고에 근거하여 작성한 코드보다 대게 짧다. <br>
   ```jsx
    function pow (x,n) {
      return (n == 1) ? x : (x * pow(x , n-1));
   }
   ```
중첩 호출의 최대 개수는 재귀 깊이라고 한다. pow(x,n)의 재귀 깊이는 n이다. <br>
자바스크립트 엔진은 최대 재귀 깊이를 제한한다.
만개 정도 까지는 확실히 허용하고, 십만까지는 다루지 못한다.
이러한 재귀 깊이 제한 떄문에 재귀를 실제 적용하는데 제약이 있긴 하지만, 재귀는 여전히 광범위하게 사용되고있다.
재귀를 사용함녀 간결하고 유지보수가 쉬운 코드를 만들 수 있기 때문이다.

### 실행 컨텍스트와 스택 
실제 재귀 호출이 어떻게 동작하는지 알아보자 <br>
실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트(execution context)에 저장된다.
실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다.  <br> 
함수 호출 일 회당 하나의 실행 컨텍스트가 생성된다. <br>
함수 내부에 중첩 호출이 있을 때는 아래와 같은 절차가 수행된다.
- 현재 함수의 실행이 일시 중지된다.
- 중지된 함수와 연관된 실행 컨텍스트는 실행 컨텍스트 스택 이라는 특별한 자료구조에 저장된다.
- 중첩 호출이 실행된다
- 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.

```jsx
function pow(x,n) {
  if ( n == 1 ) {
    return x;
  } else {
    return x * pow(x, n-1);
  }
}
```

pow(2,1)의 실행 컨텍스트
Context : {x: 2, n:1, 첫 번째 줄}  <br>
Context: {x:2, n:2, 다섯 번째 줄}  <br>
Context: {x:2, n:3, 다섯 번째 줄}  <br>

위에서부터 차례차례 스택의 컨텍스트를 꺼내서 실행한다. <br>
지금 본 예시의 재귀의 깊이는 3이다.  <br>

반복문을 상용해 만든 함수 pow
```jsx
function pow(x,n) {
  let result = 1;
  for(let i = 0; i < n; i ++ ){
    result *= x
  }
  return result;
}
```
반복문을 사용해 pow를 만듦녀 컨텍스트를 하나만 사용한다. 이 컨텍스트에서 i와 result가 변경된다.  <br>
실행 컨텍스트가 하나이기 때문에 n에 의존적이지 않고, 필요한 메모리가 적다. 사용 메모리 공간도 고정된다.  <br>
**반복문을 사용하면 대개 함수 호출의 비용(메모리 사용)이 절약된다. <br>

하지만 재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있다. <br>
모든 곳에서 메모리 최적화르 ㄹ신경써서 코드를 작성해야하는 것은 아니다 <br>
우리가 필요한것은 좋은 코드이다. 이런 이유 때문에 재귀를 사용한다. <br>

### 연결 리스트
객체를 정렬하여 어딘가에 저장하고 싶을 때
```jsx
let arr = [obj1, obj2, obj3];
```
하지만 배열은 요소 삭제와 삽입에 들어가는 비용이 많이 든다는 문제가 있다.(unshift, shift) <br>
빠르게 삽입 혹은 삭제를 해야할 때는 배열 대신 연결 리스트라 불리는 자료 구조를 사용할 수 있다. <br>
연결 리스트의 요소는 객체와 아래 프로퍼티들을 조합해 정의할 수 있다.
- value
- next: 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 땐 null이된다.

```jsx
  let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  }
```

아래처럼 코드를 작성해도 동일한 연결리스트가 된다.
```jsx
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list next.next.next = { value: 4 };
list.next.next.next.next = null;
```
연결 리스트를 사용하면 전체 리스트를 여러 부분으로 쉽게 나눌 수 있고, 다시 합치는 것도 가능하다.
```jsx
let secondList = list.next.next;
list.next.next = null;
```
그리고 쉽게 요소를 추가하거나 삭제할 수 있다.
리스트의 처음 객체를 바꾸면 리스트 맨 앞에 새로운 값을 추가할 수 있다.

#### 과제
주어진 숫자까지의 모든 숫자 더하기 
숫자 1 + 2 + .. + n을 계산하는 함수 sumTo (n)을 만들어보세요

1. for 반복문 사용하기
2. 재귀 사용하기
3. 등차수열 사용하기
```jsx
function sumTo(n) {
  let sum = 0;
  for(let i = n; i >= 1; i-- ) {
    sum += n;
  }
  return sum;
}
```
```jsx
function sumTo(n) {
  let sum = 0;
  if(n==1) {
    return 1;
  } else {
    return n + sumTo(n-1)
  }
}
```
```jsx
function sumTo(n) {
  return n * (n + 1) / 2;
}
```

등차수열의 합공식을 사용하는 방법이 가장 빠르고, 두 번째로는 반복을 사용하는 방법이다. 
재귀를 사용하는 방법은 중첩 호출과 실행 스택 관리가 추가로 필요하기 떄문에 더 많은 자원을 소비한다.
따라서 속도가 더 느리다. 

<br>

팩토리얼 계산하기 
n이 자연수일 때, 1부터 n까지의 모든 자연수의 곱을 의미
n팩토리얼은 n!으로 표시

```jsx
n! = n * (n-1) * (n - 2) * ... * 1
```
재귀를 사용하여 n!을 계산하는 함수 factorial(n)을 만들어보세요
```jsx
function factorial(n) {
  if(n == 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
```

단일 연결 리스트 출력하기
재귀와 스택에서 설명한 바 있는 단일 연결 리스트가 있다고 가정해봅시다.
```jsx
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
```
리스트 내 항목을 차례대로 하나씩 출력해주는 함수 printList(list)를 만들어보세요
반복문과 재귀를 사용한 답안 각각을 만들어봅시다.
그리고 재귀를 사용한 것과 재귀를 사용하지 않은 것 중 어떤 게 더 좋은 코드인지 생각해보자
<br>
해답
```jsx
function printList(list) {
  let tmp = list;
  while(tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }
}
```
또다른 답
```jsx
function printList(list) {
  while(list) {
    alert(list.value);
    list = list.next;
  }
}
```
하지만 매개변수 list를 바로 사용하는 건 그다지 현명한 선택은 아니다. <br>
나중에 함수를 확장할 때 list를 가지고 뭔가 해야하는 경우가 생길 수 있기 때문이다. <br>
while문 앞에서 list가 변경되면 위의 코드느 제대로 동작하지 않을것이다. <br>

좋은 변수 명이 무엇인가를 생각해 봤을 때도 리스트를 임시 변수 tmp에 저장하는 게 좋다. <br>
list 에는 그 리스트 그 자체가 저장되어 있는게 좋다. <br>
tmp는 리스트를 순회하기 위한 용도로 쓰였기 떄문에 tmp라고 명명해는게 좋다. for문의 i처럼 <br>

재귀를 기반으로 한 답 
```jsx
function printList(list) {
  alert(list.value) // 현재 요소를 출력
  if(list.next) {
    printList(list.next); // 같은 방법을 사용해 나머지 요소를 출력
  }
}
```

### 나머지 매개변수와 전개 구문
상당수의 자바스크립트 내장 함수는 인수의 개수에 제약을 두지 않는다. <br>
예시:
- Math.max(arg1,arg2,...,argN) : 인수 중 가장 큰 수를 반환
- Object.assign(dest, src1, ..., srcN) : src1..N의 프로퍼티를 dest로 복사한다.

### 나머지 매개변수 ...
함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수엔 제약이 없다.
```jsx
function sum(a,b) {
  return a + b; 
}
alert( sum (1,2,3,4,5) );
```

함수를 정의할 땐 인수를 두 개만 받도록 하고, 실제 함수를 호출할 땐 이보다 더 많은 여분의 인수를 전달했지만, 에러가발생하지 않았다. <br> 
다만 반환 값은 처음 두 개의 인수만을 사용해 계산된다. <br>

이렇게 여분의 매개변수는 그 값들을 담을 배열 이름을 마침표 세 개 ...뒤에 붙여주면 함수 선언부에 포함시킬 수 있다. <br>
이때 마침표 세개 ...는 "남아있는 매개변수들을 한데 모아 배열에 집어넣어라." 는 것을 의미한다. <br>

나머지 매개변수는 항상 마지막에 있어야한다.

### arguments 객체
유사 배열 객체인 arguments를 사용하면 인덱스를 사용해 인수에 접근할 수 있다. <br>
또한 arguments 는 이터러블 객체이기 때문에 for(let arg of arguments) alert(arg)를 사용해 인수를 펼칠 수 있다. <br>
arguments는 유사 배열 객체이면서 이터러블(반복 가능한)객체이다. <br>
하지만 배열은 아니다 따라서 배열 메서드를 사용할 수 없다는 단점이 있다 <br>
또한 인수 전체를 담기 때문에 나머지 매개변수처럼 인수의 일부만 사용할 수 없다는 단점도 있다. <br>
따라서 배열 메서드를 사용하거나 인수 일부만 사용할 때는 나머지 매개변수를 사용하는 것이 좋다. <br>
또한 화살표 함수는 arguments 객체를 지원하지 않는다. <br>
접근하면, 외부에 있는 일반 함수의 arguments객체를 가져온다. 

### 스프레드 문법
개발을 하다보면 배열을 통째로 매개변수에 넘겨주는 기능이 필요할때가 있다. <br>
예를들어 내장함수 Matn.max는 인수로 받은 숫자 중 가장 큰 숫자를 반환한다. 
```jsx
alert(Matn.max(3,5,1)); // 5
```
배열 [3,5,1]이 있고 이 배열을 대상으로 Matn.max를 호출하고 싶다고 가정해보자 <br>
아무런 조작 없이 배열을 있는 그대로 넘기면 원하는 대로 동작하지 않는다. (결과는 NaN)<br> 
Math.max는 배열이 아닌 숫자 목록을 인수로 받기 때문이다. <br>
Math.max(arr[0],arr[1],arr[2]) 처럼 배열 요소를 수동으로 나열하는 방법도 있긴 한데, 배열 길이를 알 수 없을 때는 이마저도 불가능하다. <br>
스크립트가 돌아갈 때 넘어오는 배열의 길이는 아주 길 수도 있고, 아예 빈 배열일 수도 있기 때문이다. <br>

전개 구문(spread syntax, 스프레드 구문)은 이럴 떄 사용하기 위해 만들어졌다.<br>
...를 사용하기 때문에 나머지 매개변수와 비슷해보이지만 전개 구문은 나머지 매개변수와 반대 역할을 한다. <br>

함수를 호출할 때 ...arr을 사용하면, 이터러블 객체 arr이 인수 목록으로 '확장'된다.
```jsx
let arr = [3,5,1];
alert( Math.max(...arr) ) // 5 (전개 구문이 배열을 인수 목록으로 바꿔주었음.) 
```

