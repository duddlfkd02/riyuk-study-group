# 📝 01. 재귀와 스택

## 1-1. 재귀의 개념과 기본 단계, 재귀 단계

### 1-1-1. 재귀란?

재귀는 함수가 **자기 자신을 호출**하는 프로그래밍 기술

문제를 더 작은 문제로 쪼개어 해결하는 방식으로 동작하며, `기본 단계(Base Case)`와 `재귀 단계(Recursive Step)`로 나뉜다.

- 목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화 시킬 수 있을 때
- 특정 자료구조를 다뤄야 할 때

### 1-1-2. 재귀의 기본 구조

1. 기본 단계(Base Case)
   1. 함수가 더 이상 자기 자신을 호출하지 않아야 할 조건
   2. 무한히 호출되는 것을 방지하는 것이 목표
2. 재귀 단계(Recursive Step)
   1. 더 작은 문제를 해결하기 위해 자기 자신을 호출하는 부분

**✏️  숫자합계 예시**

```jsx
function sum(n) {
  if (n === 1) return 1; // 기본 단계
  return n + sum(n - 1); // 재귀 단계
}

console.log(sum(5)); // 15
```

- `sum(5)`는 `5 + sum(4)`를 호출 →`sum(4)`는 `4 + sum(3)`를 호출 → … → `sum(1)`은 1을 반환 (기본 단계)

결과적으로 5 + 4 + 3 + 2 + 1 = 15를 반환

<br>

## 1-2. 실행 컨텍스트와 스택

### 1-2-1. 실행 컨텍스트란?

함수 실행에 필요한 정보를 담은 내부 데이터 구조이다.

- 함수 호출 시 생성
- 함수 내부 상태 (변수, 실행 위치 등)를 기록한다.

실행 컨텍스트 스택 :

- 함수 호출이 중첩될 때, 실행 컨텍스트를 저장하는 스택
- 스택에 저장(`Push`), 호출이 끝나면 제거(`Pop`) 한다.

### 1-2-2. 재귀와 실행 컨텍스트 동작 살펴보기

```jsx
function sum(n) {
  if (n === 1) return 1; // 기본 단계(Base Case)
  return n + sum(n - 1); // 재귀 단계(Recursive Step)
}

console.log(sum(3)); // 6
```

**✅ 작동 과정**

```jsx
sum(3) -> 3 + sum(2) -> 3 + (2 + sum(1)) -> 3 + (2 + 1)
       -> 6
```

1. `sum(3)` 호출 → 실행 컨텍스트 생성 → `(3 + sum(2))` 계산 시작
2. `sum(2)` 호출 → 실행 컨텍스트 생성 → `(2 + sum(1))` 계산 시작
3. `sum(1)` 호출 → 실행 컨텍스트 생성 → `1` 반환 (기본 단계)
4. 스택에서 차례로 컨텍스트 제거(Pop)하며 결과를 계산:
   - `sum(1)` → 1 반환 → 스택에서 제거
   - `sum(2)` → `2 + 1 = 3` 반환 → 스택에서 제거
   - `sum(3)` → `3 + 3 = 6` 반환 → 스택에서 제거

**✅ 도식화 - 호출**

```jsx
스택:
[ Context: { n: 3, 실행 위치: 2번째 줄 } ]
[ Context: { n: 2, 실행 위치: 2번째 줄 } ]
[ Context: { n: 1, 실행 위치: 2번째 줄 } ]
```

**✅ 도식화 - 반환 시작**

```jsx
스택:
[ Context: { n: 3, 실행 위치: 2번째 줄 } ]
[ Context: { n: 2, 실행 위치: 2번째 줄 } ]
```

### 1-2-3. 재귀의 장/단점

- 장점
  - 코드가 간결하고 직관적이다.
  - 수학적 문제나 트리/그래프 탐색 등에서 유용
- 단점

  - 재귀 깊이가 깊어질수록 메모리 사용량 증가
  - \*스택 오버플로(Stack Overflow) 위험이 있음

    ```jsx
    // 스택 오버플로
    function infiniteRecursion() {
      infiniteRecursion(); // 무한 호출
    }

    infiniteRecursion(); // Uncaught RangeError: Maximum call stack size exceeded
    ```

### 1-2-4. 반복문으로 대체하는 방법

앞서 보았듯이 재귀는 메모리 사용량이 많기 때문에 반복문으로 대체할 수 있다.

```jsx
function sumLoop(n) {
  let result = 0;
  for (let i = 1; i <= n; i++) {
    result += i;
  }
  return result;
}

console.log(sumLoop(3)); // 6
```

### 1-2-5. **재귀 vs 반복문 간단 비교**

| **재귀**                       | **반복문**                |
| ------------------------------ | ------------------------- |
| 코드가 간결하고 직관적임       | 코드가 명확하고 빠름      |
| 메모리 사용량이 많음           | 메모리 효율적             |
| 스택 오버플로우 위험이 있음    | 스택 오버플로우 위험 없음 |
| 특정 문제(트리 탐색 등)에 유용 | 일반적인 작업에 적합      |

**✏️ 피보나치 수열을 통한 재귀와 반복문 차이 알기**

```jsx
// 재귀로 구현
function fibonacciRec(n) {
  if (n <= 1) return n;
  return fibonacciRec(n - 1) + fibonacciRec(n - 2);
}

console.log(fibonacciRec(6)); // 8

// 반복문으로 구현
function fibonacciIter(n) {
  let a = 0,
    b = 1;
  for (let i = 0; i < n; i++) {
    [a, b] = [b, a + b];
  }
  return a;
}

console.log(fibonacciIter(6)); // 8
```

<br>

## 1-3. 재귀적 순회

재귀적 순회 (Recursive Traversal)

- 자료 구조(ex. 트리, 연결리스트 등)를 재귀적으로 순회하면서 각 요소를 처리하는 방식
- 기본적으로 “작업” 과 “작업을 더 작은 부분으로 나누는 과정” 을 반복한다.

### 1-3-1. 재귀적 순회 코드로 알아보기

**트리 순회**

```jsx
let company = {
  name: "CEO",
  employees: [
    {
      name: "Manager1",
      employees: [{ name: "Employee1" }, { name: "Employee2" }],
    },
    {
      name: "Manager2",
      employees: [{ name: "Employee3" }, { name: "Employee4" }],
    },
  ],
};

function printEmployees(department) {
  console.log(department.name);

  if (department.employees) {
    for (let employee of department.employees) {
      printEmployees(employee); // 재귀 호출
    }
  }
}

printEmployees(company);
/*
출력:
CEO
Manager1
Employee1
Employee2
Manager2
Employee3
Employee4
*/
```

**✅ 재귀 동작 과정**

1. `printEmployees(company)` 호출:
   - `name: "CEO"` 출력 → `employees` 배열로 재귀 호출
2. `printEmployees(Manager1)` 호출:
   - `name: "Manager1"` 출력 → `employees` 배열로 재귀 호출
3. `printEmployees(Employee1)` 호출:
   - `name: "Employee1"` 출력 → 반환
4. `printEmployees(Employee2)` 호출:
   - `name: "Employee2"` 출력 → 반환
5. `printEmployees(Manager2)` 호출: 같은 방식으로 진행

## 1-4. 연결 리스트와 트리 구조

<img width="419" alt="스크린샷 2025-01-06 오후 3 19 22" src="https://github.com/user-attachments/assets/d659022c-7008-48bf-a100-002754b38a2b" />

### 1-4-1. 연결 리스트(Linked List)란?

- 각 요소가 다음 요소를 가리키는 방식으로 구성된 선형 자료 구조이다.
- 각 노드는 데이터와 다음 노드를 가리키는 포인터를 포함한다.

```jsx
list = {value, next -> list}

// value
// next: 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 땐 null
```

**✏️ 연결리스트 예시 코드**

```jsx
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null, // 마지막 노드
      },
    },
  },
};

// 연결 리스트 순회
function traverseList(node) {
  console.log(node.value); // 현재 노드의 값 출력
  if (node.next) {
    traverseList(node.next); // 다음 노드로 재귀 호출
  }
}

traverseList(list);
/*
출력:
1
2
3
4
*/
```

**✏️ 반복문으로 연결 리스트 순회하기**

```jsx
function traverseListIteratively(node) {
  while (node) {
    console.log(node.value);
    node = node.next; // 다음 노드로 이동
  }
}

traverseListIteratively(list);
```

### 1-4-2. 트리 구조란?

- 트리(Tree)는 계층적으로 데이터를 표현하는 자료구조이다.
- 각 노드는 "자식 노드"를 가질 수 있다.

**✏️ 트리 순회 코드**

```jsx
let tree = {
  value: "root",
  children: [
    { value: "child1", children: [] },
    {
      value: "child2",
      children: [
        { value: "grandchild1", children: [] },
        { value: "grandchild2", children: [] },
      ],
    },
  ],
};

function traverseTree(node) {
  console.log(node.value);

  for (let child of node.children) {
    traverseTree(child); // 자식 노드를 재귀적으로 순회
  }
}

traverseTree(tree);
/*
출력:
root
child1
child2
grandchild1
grandchild2
*/
```

💡 **트리 순회의 여러 방식 살펴보기 (전위, 중위, 후위 순회)**

```jsx
function preorderTraversal(node) {
  if (!node) return;
  console.log(node.value); // ⭐️ 현재 노드 출력 (전위)
  for (let child of node.children) {
    preorderTraversal(child);
  }
}

function postorderTraversal(node) {
  if (!node) return;
  for (let child of node.children) {
    postorderTraversal(child);
  }
  console.log(node.value); // ⭐️ 현재 노드 출력 (후위)
}

// 예시: preorderTraversal(tree), postorderTraversal(tree)
```

### 1-4-3. 연결 리스트와 트리구조 도식화

**✅ 트리 구조**

```jsx
        root
       /    \
   child1  child2
           /      \
    grandchild1  grandchild2
```

**✅ 연결 리스트**

```jsx
[1] -> [2] -> [3] -> [4] -> null
```

💡 **연결 리스트와 트리의 특징 차이점**

| **트리**                                | **연결 리스트**              |
| --------------------------------------- | ---------------------------- |
| 각 노드가 여러 자식 노드를 가질 수 있음 | 각 노드가 다음 노드를 가리킴 |
| 계층적 자료구조                         | 선형 자료구조                |
| 계층적으로 데이터 처리 가능             | 순차적으로 데이터 처리 가능  |

<br>

---

<br>

# 📝 02. 나머지 매개변수와 전개구문

## 2-1. 나머지 매개변수 `…`

햠수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수에는 제약이 없다.

```jsx
function sum(a, b) {
  // 함수 정의 시 2개의 인수만 받도록 함
  return a + b;
}

console.log(sum(1, 2, 3, 4, 5)); // 호출 시 더 많은 인수 전달 but 오류 발생하지 않음
```

함수를 정의할 때와 달리 더 많은 여분의 인수를 전달했지만 위 코드에서 오류가 발생하지 않았다. 다만, 반환값은 처음 두 개의 인수만 사용하여 계산된다.

이렇듯 여분의 매개변수는 그 값들을 담을 배열 이름을 마침표 `…` 뒤에 붙여주면 함수 선언부에 포함시길 수 있다.

```jsx
function sumAll(...args) {
  // 여분의 매개변수를 배열에 집어 넣어줘!
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

console.log(sumAll(1)); // 1
console.log(sumAll(1, 2)); // 3
console.log(sumAll(1, 2, 3)); // 6
```

✏️ **처음 인수 2개는 변수, 나머지 인수들은 `titles` 배열에 할당하기**

```jsx
function showName(firstName, lastName, ...titles) {
  console.log(firstName + " " + lastName); // Bora Lee

  // titles = ["Software Engineer", "Researcher"]
  console.log(titles[0]); // Software Engineer
  console.log(titles[1]); // Researcher
  console.log(titles.length); // 2
}

showName("Bora", "Lee", "Software Engineer", "Researcher");
```

이렇게 작성하면 나머지 인수들은 배열 `titles` 의 요소가 된다.

### ⚠️ 나머지 매개변수는 항상 마지막에 있어야 한다.

나머지 매개변수는 남아있는 인수를 모으는 역할을 하기 때문에 마지막에 작성하지 않으면 오류가 발생한다.

```jsx
function func(arg1, ...rest, arg2){ // ...rest 후에 arg2가 있으면 안 됨
	// 🚨 error!!
}
```

<br>

## 2-2 arguments 객체

유사 배열 객체(array-like object)인 `arguments` 를 사용하면 `index` 를 사용하여 인수에 접근할 수 있다.

**✅ 코드 예시**

```jsx
function showName() {
  console.log(arguments.length);
  console.log(arguments[0]);
  console.log(arguments[1]);

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg); 를 사용해 인수를 펼칠 수 있다.
}

// 2, Bora, Lee가 출력됨
showName("Bora", "Lee");

// 1, Bora, undefined가 출력됨(두 번째 인수는 없음)
showName("Bora");
```

나머지 매개변수가 나오기 이전에는 `arguments` 를 사용하는 방법을 사용했다. 이 `arguments` 방식에는 몇 가지 단점이 존재하는데 아래와 같다.

1. 배열 메서드 사용 불가능

   : `arguments`는 유사 배열 객체이면서 이터러블 객체이지만, 결과적으로 배열은 아니다! 때문에 배열 메서드를 사용할 수 없다는 단점이 있다.

2. 인수의 일부만 사용할 수 없다.

   : `arguments`는 인수 “전체” 를 담기 때문에 나머지 매개변수처럼 인수의 “일부만” 사용할 수 없다.

3. 화살표 함수는 `arguments` 객체를 지원하지 않는다.

   : 화살표 함수에서 `arguments` 객체에 접근하려 하면, 외부에 있는 ‘일반’ 함수의 `arguments` 객체를 가져온다.

   ```jsx
   function f() {
     let showArg = () => console.log(arguments[0]);
     showArg();
   }

   f(1); // 1
   ```

이와 같은 단점이 있으므로 배열 메서드를 사용하거나, 인수 일부만 가져와 사용할 경우에는 나머지 매개변수를 사용하는 것이 좋다.👍

<br>

## 2-3. 스프레드 문법

### 2-3-1. 스프레드 문법 역할

스프레드 문법은 배열이나 이터러블 객체를 **개별 요소로 확장**할 수 있게 해주는 문법이다. 배열의 요소를 나열하거나 합칠 때 주로 사용된다.

**✅ 배열을 함수의 인수로 전달하는 코드 예시**

```jsx
let arr = [3, 5, 1];

// 전개 구문을 사용하여 배열 요소를 개별 인수로 전달
console.log(Math.max(...arr)); // 5
```

`Math.max`는 배열이 아닌 숫자 목록을 인수로 받기 때문에 위 코드처럼 아무 조작없이 있는 그대로 배열을 `Math.max`에 넘기면 원하는 값을 얻을 수 없다. 배열을 바로 전달하면 동작하지 않지만, 스프레드 문법을 사용하면 가능하다.

**✅ 여러 배열을 합치기**

```jsx
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

let merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4, 5, 6]
```

**✅ 평범한 값과 혼합 가능**

스프레드 문법은 개별 값과 섞어서 사용할 수 있다.

```jsx
let arr1 = [1, 2];
let arr2 = [3, 4];

let combined = [0, ...arr1, 99, ...arr2];
console.log(combined); // [0, 1, 2, 99, 3, 4]
```

### 2-3-2. 스프레드 문법과 이터러블 객체

스프레드 문법은 **이터러블 객체**에서 동작한다. 따라서 문자열을 문자 배열로 변환할 수 있고, `Set`과 `Map`을 함께 사용할 수 있다.

```jsx
// 문자열 -> 문자 배열
let str = "Hello";
console.log([...str]); // ['H', 'e', 'l', 'l', 'o']

// Set, Map과 함께 사용
let set = new Set([1, 2, 3]);
console.log([...set]); // [1, 2, 3]

let map = new Map([
  ["key1", "value1"],
  ["key2", "value2"],
]);
console.log([...map]); // [['key1', 'value1'], ['key2', 'value2']]
```

### 2-3-3. Array.from과의 비교

| **기능**  | **스프레드문법 [...obj]**                |  **Array.from(obj)**                            |
| --------- | ---------------------------------------- | ----------------------------------------------- |
| 적용 대상 | 이터러블 객체만                          | 이터러블 객체 + 유사 배열 객체                  |
| 사용 목적 | 간단히 배열로 변환                       | 더 복잡한 변환 작업                             |
| 예시      | `[...str]` → `['H', 'e', 'l', 'l', 'o']` | `Array.from(str)` → `['H', 'e', 'l', 'l', 'o']` |

**✏️ 유사 배열 객체 변환**

스프레드 문법과 달리 `Array.from`은 유사 배열 객체도 변환할 수 있다.

```jsx
let arrayLike = { 0: "a", 1: "b", length: 2 };

// 스프레드 문법은 동작하지 않음 ❌
// console.log([...arrayLike]); // TypeError

// Array.from을 사용해 변환 ✅
console.log(Array.from(arrayLike)); // ['a', 'b']
```

### 2-3-4. 스프레드 문법의 장점 및 주의사항

**👍 장점**

1. **가독성** : 복잡한 배열 조직을 단순화 시킨다.
2. **유연성** : 함수 호출, 배열 병합, 복사 등 다양한 상황에서 활용할 수 있다.
3. **이터러블 지원** : 이터러블 객체 (`Set`, `Map`, `문자열` 등)을 다룰 수 있다.

**⚠️ 주의할 점**

1. 이터러블 객체만 사용 가능하다.
2. 스프레드 문법은 메모리 소비를 할 수 있어 큰 배열에서 성능을 고려해야한다.

### 2-3-5. 다양한 활용 예시

**✅ 최댓값 계산하기**

```jsx
let numbers = [1, 2, 3, 4, 5];
console.log(Math.max(...numbers)); // 5
```

**✅ 배열 복사하기**

```jsx
let arr = [1, 2, 3];
let copy = [...arr];
console.log(copy); // [1, 2, 3]
```

**✅ 배열 병합하기**

```jsx
let a = [1, 2];
let b = [3, 4];
let merged = [...a, ...b];
console.log(merged); // [1, 2, 3, 4]
```

<br>

## 2-4. 배열과 객체의 복사본 만들기

`Object.assign()`을 사용해 객체를 복사를 배웠는데 스프레드 문법을 사용하여 배열과 객체를 복사할 수 있다.

**✅ 배열 복사**

```jsx
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 배열을 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음에
// 매개변수 목록을 새로운 배열에 할당함

console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

console.log(arr === arrCopy); // 참조가 다르기 때문에 false

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않는다.
arr.push(4);
console.log(arr); // 1, 2, 3, 4
console.log(arrCopy); // 1, 2, 3
```

**✅ 객체 복사**

```jsx
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음에
// 매개변수 목록을 새로운 객체에 할당함

console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

console.log(obj === objCopy); // 참조가 다르기 때문에 false

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않는다.
obj.d = 4;
console.log(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
console.log(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```

<br>

---

<br>

# 📝 03. 변수의 유효범위와 클로저

자바스크립트는 함수 지향 언어이기 때문에 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수 있다.

## 3-1. 코드 블록

코드블록 `{…}` 안에 선언한 변수는 블록 안에서만 사용할 수 있다. 때문에 특정 작업을 수행하는 코드를 한 곳에 묶어두는 용도로 활용할 수 있다.

`let`, `if`, `for`, `while` 등에서도 마찬가지로`{…}`안에 선언한 변수는 오직 해당 블록 안에서만 접근 가능하다.

```jsx
for (let i = 0; i < 3; i++) {
  // 변수 i는 for 안에서만 사용할 수 있다.
  alert(i); // 0, 1, 2가 출력
}

alert(i); // ReferenceError: i is not defined
```

`if` 블록 밖에 있는 `alert`는 `phrase`에 접근할 수 없기 때문에 위 예시를 실행하면 에러가 발생한다.

<br>

## 3-2. 중첩 함수

중첩 함수(Nested Function)는 함수 내부에서 선언된 함수이다. 중첩 함수는 외부 함수의 변수에 접근할 수 있다.

중첩함수를 사용하여 코드를 정리하면 복잡한 계산이나 로직을 중첩함수로 분리해 가독성을 높일 수 있다.

```jsx
function sayHiBye(firstName, lastName) {
  function getFullName() {
    return firstName + " " + lastName;
  }

  console.log("Hello, " + getFullName());
  console.log("Bye, " + getFullName());
}

sayHiBye("John", "Doe");
// 출력:
// Hello, John Doe
// Bye, John Doe
```

- 외부 함수의 변수 접근 가능 : `getFullName()` 함수는 외부 함수 `firstName`과 `lastName`에 접근할 수 있다.

<br>

## 3-3. 클로저(Closure)

클로저란 함수가 생성될 때, 함수가 정의된 위치의 외부 변수(렉시컬 환경)를 기억하고 사용할 수 있는 함수를 말한다. 자바스크립트에서는 모든 함수가 클로저이다.

### 3-3-1. 클로저의 개념 및 특징

1. **개념**
   - **외부 변수를 기억**: 함수가 생성될 당시의 외부 변수를 기억
   - **외부 변수에 접근**: 기억된 변수에 접근하거나 수정할 수 있다.
2. 특징
   1. 함수가 생성된 위치의 외부 변수를 기억
   2. 외부 변수를 참조하거나 수정할 수 있음

### 3-3-2. 클로저 동작 원리

✏️ **렉시컬 환경(Lexical Environment)**

자바스크립트에서 함수는 실행될 때마다 렉시컬 환경이라는 내부 객체를 생성하는데, 이는 지역 변수와 외부 변수를 참조하는 정보로 구성된다.

✏️  **작동 방식**

1. 함수가 호출되면 새로운 렉시컬 환경이 생성된다.
2. 내부 렉시컬 환경은 외부 렉시컬 환경을 참조한다.
3. 내부 함수는 자신이 생성된 렉시컬 환경 정보를 기억한다.

✅ **렉시컬 환경 예제**

```jsx
function outer() {
  let outerVar = "I am from outer!";

  return function inner() {
    console.log(outerVar); // 외부 변수를 참조
  };
}

let innerFunc = outer();
innerFunc(); // "I am from outer!"
```

- `outer` 함수가 실행되면 렉시컬 환경이 생성되고 `outerVar`가 저장
- `inner` 함수가 반환되면서 `outer`의 렉시컬 환경을 기억함
- `innerFunc`를 호출하면 `outerVar`를 참조할 수 있음

<img width="485" alt="클로저 도식화" src="https://github.com/user-attachments/assets/913b306f-4399-4b70-a310-8f11d9720082" />

### 3-3-3. 예시 코드로 클로저 살펴보기

✅ **기본 예제 : 외부 변수 기억**

```jsx
function makeCounter() {
  let count = 0; // 외부 변수

  return function () {
    return count++; // 외부 변수 count 참조
  };
}

let counter = makeCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

- 코드 설명 : `makeCounter` 함수는 내부에 `count`를 가지고 있으며, 반환된 함수는 이 `count`를 계속 참조한다.
- 결과 : 클로저를 통해 외부 변수 `count` 값을 유지한다.

**✅ 응용 ver : private 변수**

```jsx
function createSecret() {
  let secret = "This is a secret!";

  return {
    getSecret() {
      return secret;
    },
    setSecret(newSecret) {
      secret = newSecret;
    },
  };
}

let secretHandler = createSecret();

console.log(secretHandler.getSecret()); // "This is a secret!"
secretHandler.setSecret("New secret!");
console.log(secretHandler.getSecret()); // "New secret!"
```

- 코드 설명 : `secret` 변수는 외부에서 접근할 수 없고 오직 클로저로만 접근할 수 있다.
- 활용 : 클로저를 이용해 변수를 보호하고 캡슐화 한다.

✅ **반복문에서 클로저 사용하기**

```jsx
function createCounters() {
  let counters = [];

  for (let i = 0; i < 3; i++) {
    counters.push(function () {
      console.log(i);
    });
  }

  return counters;
}

let funcs = createCounters();
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2
```

✅ **이벤트 핸들러에서 사용**

```jsx
function setupClickHandlers() {
  for (let i = 0; i < 3; i++) {
    document
      .getElementById(`button${i}`)
      .addEventListener("click", function () {
        console.log(`Button ${i} clicked`);
      });
  }
}
```

### 3-3-4. 클로저와 메모리 관리

⚠️ 클로저는 외부 변수를 계속 참조하기 때문에 불필요한 메모리 점유를 발생시킬 수 있다.

→ 더 이상 필요하지 않은 참조는 `null` 로 설정한다.

⚠️ 클로저를 과도하게 사용하면 성능에 영향을 줄 수 있다.

<br>

---

<br>

# 📝 04. 오래된 Var

## 4-1. var를 권장하지 않는 이유

자바스크립트에서 `var`는 오래전부터 사용된 변수 선언 방식이지만 아래와 같은 이유로 권장되지 않는다.

### 4-1-1. 블록 스코프를 지원하지 않음

- `var` 는 블록스코프를 지원하지 않으며 함수 스코프만 가진다.
- `let` 과 `const` 변수를 사용하여 변수의 범위를 더 안전하게 관리할 수 있다.

```jsx
if (true) {
  var test = "hello"; // 블록 밖에서도 접근 가능
}
console.log(test); // "hello"

// ✅ let 으로 개선
if (true) {
  let test = "I exist only in this block!";
}
console.log(test); // ReferenceError: test is not defined
```

### 4-1-2. 중복 선언 가능

- `var` 로 동일한 이름의 변수를 여러 번 선언해도 에러가 발생하지 않는다.

```jsx
var name = "John";
var name = "Alice"; // 중복 선언 가능
console.log(name); // "Alice"

// ✅ let 으로 개선
let name = "John";
let name = "Alice"; // SyntaxError: Identifier 'name' has already been declared
```

### 4-1-3. 호이스팅 문제

- `var` 는 선언이 코드 상단으로 끌어올려지는 호이스팅 동작을 가진다.
- 변수 선언부는 위로 끌어올려지지만, 초기화는 끌어올려지지 않아 예기치 않은 동작을 유발할 수 있다.

```jsx
console.log(name); // undefined
var name = "John";

// ✅ let 으로 개선
console.log(value); // ReferenceError: Cannot access 'value' before initialization
let value = 10;
```

<br>

## 4-2. var 를 사용했을 때 발생할 수 있는 문제점 추가 정리

**❌ 반복문 내 `var` 동작**

```jsx
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// 3, 3, 3 (모든 `setTimeout`에서 마지막 값 출력)

// ✅ let 으로 개선
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// 0, 1, 2 (각각의 블록에 독립적인 i 값 유지)
```

**→ `var`는 블록 스코프를 지원하지 않으므로, 반복문에서 선언된 변수가 반복문 외부에서도 변경될 수 있다.**

<br>

**❌ 전역변수 생성 가능성**

```jsx
function example() {
  testVar = "I am global!"; // `var`를 생략
}
example();
console.log(testVar); // "I am global!" (전역 변수 생성)

// ✅ let 또는 const로 개선
function example() {
  let testVar = "I am local!"; // 명시적 선언
}
example();
console.log(testVar); // ReferenceError: testVar is not defined
```

→ `var`를 생략하면 전역 변수가 암묵적으로 생성된다.

<br>

**❌ TDZ(Temporal Dead Zone)를 지원하지 않음**

```jsx
console.log(x); // undefined
var x = 5;

// ✅ let 으로 개선
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 5;
```

→ `var`는 TDZ(일시적 사각지대)를 지원하지 않아 변수 선언 전에 변수에 접근이 가능하다.

→ 반면 `let`과 `const`는 선언 전에 접근 시 에러를 발생시켜 안전성을 보장한다.
