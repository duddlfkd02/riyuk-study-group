# 📝 01. 객체 기본

- 자바스크립트에는 8가지의 자료형이 있는데, 이 중 7개는 하나의 데이터(문자열, 숫자 등)만 담을 수 있는 `“원시형(primitive type)”`이라고 부른다.

- `객체형` 은 다양한 데이터를 담을 수 있다는 점이 원시형과의 차이점인데, 키로 구분된 데이터 집합이나 복잡한 개체(`entity`)를 저장할 수 있다.

- `key` : 문자형 허용/ `value` : 모든 자료형 허용

- **객체 만드는 법** : `{…}` 중괄호를 이용해 만들고 이 안에는 `key`, `value` 가 `쌍(pair)` 형태로 구성되어있다.
  이 쌍에는 `프로퍼티(property)` 를 여러 개 넣을 수 있다.

```jsx
let user = new Object(); // 생성자 방식
let user = {...} // 리터럴 방식  👍 주로 리터럴 방식 사용
```

<br />

## 1-1. 리터럴과 프로퍼티

`{…}` 안에는 **‘키 : 값’** 이 쌍으로 구성된 프로퍼티가 들어간다.

```jsx
let user = {
  // 객체
  name: "John", // 키: "name",  값: "John"
  age: 30, // 키: "age", 값: 30
};

/*
<user의 프로퍼티>

1. "name"과 "John"
2. "age"와 30
*/
```

- `콜론(:)` 을 기준으로 왼쪽이 `key`, 오른쪽이 `value`가 된다.
  (프로퍼티 키 === 프로퍼티 이름 === 식별자 같은 이름임!)

  <br />

## 1-2. 점 표기법(dot notaition) 사용하여 추가, 삭제하기

**✅ 프로퍼티 값 얻기**

```jsx
alert(user.name); // John
alert(user.age); // 30
```

✅ **불린형 프로퍼티 추가하기**

```jsx
user.isAdmin = true;
```

✅ **`delete` 연산자를 사용하여 프로퍼티 삭제하기**

```jsx
delete user.age;
```

**✅ 여러 단어 조합하여 프로퍼티 이름을 만든 경우**

```jsx
let user = {
  name: "John",
  age: 30,
  "likes birds": true, // ⭐️ 복수 단어는 따옴표로 묶기

  // 💡 trailing, hanging 쉼표 : 마지막 프로퍼티 끝을 쉼표로 끝냄
};
```

- `trailing`, `hanging` 쉼표 장점 : 모든 프로퍼티가 유사한 형태를 보여 추가, 삭제, 이동하기 쉬워진다.

<br />

### 🙋‍♀️ 상수 객체는 수정될 수 있나요? - 례.

`const` 는 “값”을 고정하지만 “내용”은 고정하지 않는다.

<br />

```jsx
const user = { name: "John" };
user = { name: "Pete" }; // ❌ Error: Assignment to constant variable
```

→ `user` 를 다른 객체로 재할당하려고 했기 때문에 에러 발생!

<br />

```jsx
const user = {
  name: "John",
};

user.name = "Pete";
```

→ `user` 변수는 **객체의 참조값**을 가지고 있다. **참조값을 변경할 수 없지만, 객체 내부의 `name` 속성 값을 `“Pete”`로 변경하는 것은 가능!!**

<br />

따라서 `user.name = "Pete"` 이 실행된 후 `alert(user.name)` 을 실행하면 `Pete`가 출력된다.

<br />

### 🙋‍♀️ 상수 내부 속성 수정도 못하게 할 수 있나요? - 례.

`Object.freeze` 메서드를 사용하면 `const` 로 선언한 **객체 내부의 속성 수정도 막을 수 있다.**

```jsx
const user = {
  name: "John",
};

Object.freeze(user); // ⛄️ 객체를 동결

user.name = "Pete"; // ❌ 수정되지 않음
console.log(user.name); // John
```

<br />

### 요약

- `const`는 **변수 자체의 재할당**을 금지한다.
- 하지만!!! `const`로 선언된 **객체의 내부 프로퍼티는 수정 가능**
- 객체 내부 속성 수정도 금지하고 싶다면 `Object.freeze`를 사용

<br />

## 1-3. 대괄호 표기법

### 유효한 변수 식별자

```jsx
let user = {
  name: "John",
  age: 30,
  "likes birds": true,
};

// ⭐️ 대괄호 표기법
let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
```

아까 본 코드에서 마지막 프로퍼티 "likes birds" 를 점 표기법으로 읽으려고 하면 에러가 발생한다.

점 표기법은 ‘유효한 변수 식별자’ 인 경우에만 사용할 수 있는데 이 유효한 변수 식별자에는 공백이 없어야 한다. 따라서 "likes birds" 에는 공백이 있기 때문에 문법 에러가 발생하는 것!

**⚠️ 유효한 변수 식별자를 쓸 수 없는 경우**

1. 숫자로 시작하면 안 됨
2. 공백 불가
3. 특수문자 제외 (`$` , `_` 제외)

<br />

### 대괄호 표기법 예시 코드

```jsx
// 1. 대괄호 표기법 ⭕️
let user = {
  name: "John",
  age: 30,
};

let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

alert(user[key]); // John (프롬프트 창에 "name"을 입력한 경우)

// 2. 점 표기법 ❌
let key = "name";
alert(user.key); // undefined
```

**대괄호 표기법**을 사용하면 변수를 키로 사용한 것 같이 모든 표현식의 결과를 프로퍼티 키로 사용할 수 있다.

- 동적으로 속성 이름을 결정해야 할 때 유용함
- 속성 이름에 공백, 특수문자, 숫자가 포함되어도 사용할 수 있음

<br />

**✅ 동적 속성 접근**

```jsx
const user = { name: "John", age: 30 };

const key = "name";
console.log(user[key]); // "John" (key 변수의 값인 "name" 속성에 접근)

const dynamicKey = "age";
console.log(user[dynamicKey]); // 30
```

✅ **`delete` 연산자로 속성 삭제하기**

```jsx
const obj = { name: "John", age: 30 };
delete obj["name"];
console.log(obj); // { age: 30 }
```

<br />

### 계산된 프로퍼티 (computed property)

객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우 <br />
객체 리터럴을 생성할 때 **속성 이름을 동적으로 설정**할 수 있는 기능

✅ **기본 사용법**

```jsx
let key = "name";

let obj = {
  [key]: "John", // key 변수의 값이 속성 이름으로 설정됨
};

console.log(obj.name); // "John"
```

✅ **변수로 속성이름 설정**

```jsx
const key1 = "name";
const key2 = "age";

const person = {
  [key1]: "Alice", // key1의 값이 "name"이므로 속성 이름이 name이 됨
  [key2]: 25, // key2의 값이 "age"이므로 속성 이름이 age가 됨
};

console.log(person); // { name: "Alice", age: 25 }
```

✅ **함수로 동적 키 생성**

```jsx
function createKey(value) {
  return `key_${value}`;
}

let obj = {
  [createKey("abc")]: "value1",
  [createKey("def")]: "value2",
};

console.log(obj); // { key_abc: "value1", key_def: "value2" }
```

<br />

## 1-4. 단축 프로퍼티

객체 리터럴에서 속성 이름과 변수 이름이 같을 경우 **키와 값을 간략하게 작성**할 수 있는 문법

- 객체의 속성 이름이 변수 이름과 같으면 자동으로 매핑되는 특징이 있다.
- 불필요한 중복을 줄여 코드를 간결하게 만들어 줌

<br />

✅ **기본 사용법**

```jsx
let title = "Developer";
let company = "리육이";

let job = {
  title, // title: title
  company, // company: 리육이
};

console.log(job); // { title: "Developer", company: "리육이" }
```

✅ **함수와 함께 사용**

```jsx
function createUser(name, age) {
  return { name, age }; // 단축 프로퍼티 사용
}

let user = createUser("Alice", 30);
console.log(user); // { name: "Alice", age: 30 }
```

✅ **계산된 프로퍼티 + 단축 프로퍼티 사용**

```jsx
let key = "nickname";
let value = "Johnny";
let age = 30;

let user = {
  [key]: value, // 계산된 프로퍼티
  age, // 단축 프로퍼티
};

console.log(user); // { nickname: "Johnny", age: 30 }
```

<br />

## `in` 연산자로 프로퍼티 존재 여부 확인하기

객체는 존재하지 않는 프로퍼티에 접근하려고 해도 `undefined` 를 반환하는 특징이있다.

연산자 `in` 을 사용하면 프로퍼티 존재 여부를 알 수 있다.

⚠️ **주의사항**

- `in` 왼쪽엔 반드시 프로퍼티 이름이 와야한다.
- 프로퍼티 이름은 보통 따옴표로 감싼 문자열이다.

```jsx
let user = { name: "John", age: 30 };

alert("age" in user); // user.age가 존재하므로 true가 출력
alert("blabla" in user); // user.blabla는 존재하지 않기 때문에 false가 출력
```

<br />

### 🙋‍♀️ 그냥 `undefined` 랑 비교하면 안되나요? `in` 연산자 써야하나요? - 례.

대부분의 경우는 일치 연산자를 사용해서 프로퍼티 존재 여부를 알 수 있지만, 값에 `undefined`를 할당한 경우에는 `in` 연산자를 사용해야한다.

```jsx
let obj = {
  test: undefined, // ⭐️ undefined 값 할당
};

alert(obj.test);

alert("test" in obj);
```

`obj.test`는 실제 존재하는 프로퍼티이다. 따라서 `in` 연산자는 `true`를 반환한다.

<br />

## 1-5. `for…in` 반복문

✅ **객체 속성 반복 (일반적인 사용 법)**

```jsx
const user = {
  name: "John",
  age: 30,
  job: "Developer",
};

for (let key in user) {
  console.log(`${key}: ${user[key]}`);
}
// 출력:
// name: John
// age: 30
// job: Developer
```

`for..in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있는데, `for` 반복문과는 완전히 다른 문법이므로 혼동하지 않도록 주의할 것!

<br />

✅ **배열에서 사용**

```jsx
const arr = ["apple", "banana", "cherry"];

for (let index in arr) {
  console.log(`Index: ${index}, Value: ${arr[index]}`);
}
// 출력:
// Index: 0, Value: apple
// Index: 1, Value: banana
// Index: 2, Value: cherry
```

`for ... in` 반복문을 배열에서 사용할 수 있으나 **배열의 인덱스(key)를 순회한다는 점**을 주의하자!

위 같은 이유로 배열을 순회할 때는 `forEach` 혹은 `for..of`를 사용하는 것이 적합하다.

<br />

🚨`for ... in` 에서의 구조분해 사용하면 안 됨!

```jsx
const nameList = [
  { a: 1, b: 2 },
  { a: 3, b: 4 },
];

for (const { a, b } in nameList) {
  console.log(a, b); // ❌ SyntaxError: Invalid destructuring assignment target
}
```

`{a, b}`는 구조 분해 할당으로 객체의 속성을 추출하려는 시도이지만, **`for...in`은 객체의 키만 순회**하기 때문에 오류가 발생한다.

<br />

---

<br />

# 📝 02. **참조에 의한 객체 복사**

객체는 자바스크립트에서 `참조 타입(reference type)`으로 동작한다. 변수에 객체를 할당하면 객체 자체가 아닌, **`객체가 저장된 메모리 주소`를 참조**합니다. 그래서 객체를 복사할 때 값이 아닌 참조값이 복사됩니다.

## 2-1. 원시타입과 객체타입

- **원시타입** : 값 자체 복사 (ex. `number`, `string`, `boolean`)
- **객체타입** : 참조값 복사 (ex. `object`, `array`)

<br />

## 2-2. 객체 복사

```jsx
let obj1 = { name: "John" };
let obj2 = obj1; // obj1의 참조값이 obj2에 복사됨

obj2.name = "Pete"; // obj2를 변경하면 obj1도 영향을 받음
console.log(obj1.name); // "Pete"
console.log(obj2.name); // "Pete"
```

`obj1` 와 `obj2`는 같은 객체를 참조하기 때문에 둘 중 하나를 변경하면 다른 하나도 영향을 받게 된다.

<br>

**그림으로 이해하기**

![원시 객체 복사](https://github.com/user-attachments/assets/6713301c-5a8f-4b87-8b47-e50da26f47fd)

- **원시 타입 복사**
  - `a`와 `b`는 서로 독립적으로 값을 가짐 (복사 시 값 자체가 복사)
- **객체 타입 복사**

  - `obj1`과 `obj2`는 동일한 메모리 주소를 참조
  - `obj2`를 변경하면 `obj1`도 영향을 받음

  <br>

### 2-2-1. 깊은 복사와 얕은 복사

✅ **얕은 복사**

```jsx
let obj1 = { name: "John", age: 30 };
let obj2 = { ...obj1 }; // 얕은 복사

obj2.name = "Pete";
console.log(obj1.name); // "John" (영향을 받지 않음)
console.log(obj2.name); // "Pete"
```

스프레드 연산자를 사용하면 1단계 속성만 복사한다.

✅ **깊은 복사**

```jsx
let obj1 = { name: "John", address: { city: "Seoul" } };
let obj2 = JSON.parse(JSON.stringify(obj1)); // 깊은 복사

obj2.address.city = "Busan";
console.log(obj1.address.city); // "Seoul" (영향을 받지 않음)
console.log(obj2.address.city); // "Busan"
```

깊은 복사는 객체 내부의 중첩된 객체까지 복사한다.

ex. `JSON.parse(JSON.stringify(obj)` 또는 `lodash.cloneDeep` 사용하여 깊은 복사

<br>

### 2-2-2. **병합과 Object.assign**

✅ `Object.assign`을 사용하여 얕은 복사를 할 수 있다. 하지만 중첩된 객체의 경우 내부 객체는 여전히 참조된다.

```jsx
const obj1 = { name: "John", address: { city: "Seoul" } };
const obj2 = Object.assign({}, obj1); // ⭐️ Object.assign 사용

console.log(obj2); // { name: "John", age: 30 }

obj2.address.city = "Busan";
console.log(obj1.address.city); // "Busan" (원본 객체가 영향을 받음)
```

**✅ 객체 병합**

```jsx
const obj1 = { name: "John", age: 30 };
const obj2 = { age: 35, city: "Seoul" };

const merged = Object.assign({}, obj1, obj2);
console.log(merged); // { name: "John", age: 35, city: "Seoul" }
```

동일한 속성은 마지막 소스 객체의 값으로 덮어씌워진다는 특징이 있다.

✅ **빈 객체로 병합**

```jsx
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const obj3 = { c: 3 };

const result = Object.assign({}, obj1, obj2, obj3); // ⭐️ 빈 객체 설정!
console.log(result); // { a: 1, b: 2, c: 3 }
```

대상 객체를 빈 객체로 설정하여 원본 객체를 유지하면서 병합

<br>

---

<br>

# 📝 03. 가비지 컬렉션

## 3-1. 가비지 컬렉션 기준

자바스크립트는 **도달 가능성(reachability)** 라는 개념을 사용해 메모리 관리를 수행한다.

#### 💡 **도달 가능성?**

도달 가능성은 어떻게든 접근하거나 사용할 수 있는 값을 의미한다. 도달 가능한 값은 메모리에서 삭제되지 않는다.

1. 현재 함수의 지역 변수와 매개변수
2. 중첩 함수의 체인에 있는 함수에서 사용 되는 변수와 매개변수
3. 전역 변수 등

위 세 가지 예시들을 우리는 “`루트(root)`” 라고 부르는데, 이 루트가 참조하는 값이나 체이닝으로 참조할 수 있다면 도달 가능한 값이 된다.

자바스크립트 엔진 내에서는 `가비지 컬렉터(garbage collector)`가 끊임없이 동작한다. 이 가비지 컬렉터는 모든 객체를 모니터링하고 도달할 수 없는 객체는 삭제한다.

`가비지 컬렉션(GC)`은 **더 이상 필요하지 않은 메모리를 자동으로 해제**하여 프로그램의 메모리 효율성을 유지하는 과정이다. 자바스크립트는 **자동 메모리 관리**를 수행하므로 개발자가 명시적으로 메모리를 해제할 필요는 없다.

<br>

**✅ 예시 - 간단 ver, 참조 두 개**

![가비지컬렉션](https://github.com/user-attachments/assets/7247dc04-1844-424c-bb6a-a693489bd1fb)

1. 첫번째 코드를 보면 `user`는 `John` 이라는 객체를 참조하고 있다.
2. 두번째 코드에서 `null` 이라는 값으로 덮어 씌워버리는 순간 참조하지 않는다. 이 때 이 메모리는 가비지컬렉터가 `John` 메모리를 삭제한다.
3. 참조를 `user` 에서 `admin` 으로 복사하고 똑같이 `user = null`값을 바꾸어도 `admin`이 참조하고 있기 때문에 `John` 메모리는 남아있게 된다.

<br>

**✅ 예시 - 연결된 객체**

![여러개 참조](https://github.com/user-attachments/assets/b0beff26-f10e-49c1-9976-3c99774ff05f)

`marry` 함수는 매개변수로 받은 두 객체를 서로 참조하게 하면서 함수를 실행시키고, 이 두 객체를 포함하는 새로운 객체를 반환한다. (사진 속 메모리 구조 참고)

<br>

![여러개 참조2](https://github.com/user-attachments/assets/cdd7ba36-e784-419f-ac06-741b31c3fbec)

참조 두 개를 지우면 `John`으로 들어오는 참조(화살표)는 모두 사라져 `John`은 도달 가능한 상태에서 벗어난다. (하나만 지웠다면 도달 가능한 상태였을 것!)

따라서 **`John`은 도달 가능한 상태가 아니기 때문에 메모리에서 제거**되고, `John`에 저장된 데이터(프로퍼티)도 메모리에서 사라진다.

<br>

## 3-2. 내부 알고리즘

### 3-2-1. 마크 앤 스위프 (Mark - and - Sweep) - 현재 자바스크립트 엔진의 주된 알고리즘

1. **마크 단계 (**mark**)**

   : 가비지 컬렉터가 도달 가능한 객체를 찾아 마킹한다.

2. **스위프 단계 (**sweep**)**

   : 마크되지 않은 객체는 도달 불가능하다고 판단하여 메모리를 해제한다.

```jsx
function example() {
  let obj1 = { name: "John" }; // obj1은 도달 가능
  let obj2 = { age: 30 }; // obj2는 도달 가능

  obj1.ref = obj2; // obj1이 obj2를 참조
  obj2 = null; // obj2는 더 이상 참조되지 않음
}

example();
```

<br>

### 3-2-2. 최적화 기법

- **세대별 가비지 컬렉션 (Generational GC)**:

  - 객체를 `새로운 객체(Young Generation)`와 `오래된 객체(Old Generation)`로 나눠서 관리
  - 생성 이후 역할 수행 후 쓸모 없어진 새로운 객체를 공격적으로 메모리에서 제거
  - 일정시간 동안 살아남은 객체를 오래된 객체라고 하며 가비지 컬렉터가 덜! 감시함

- **점진적 가비지 컬렉션 (Incremental GC)**:

  - 객체가 많을 경우 mark 하는데 시간 소모를 줄이기 위해 사용
  - 한 번에 모든 메모리를 검사하지 않고 나눠서 수행하여 성능 개선

- **유휴 시간 수집 (idle-time collection)**:
  - 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행

<br>

---

<br>

# 📝 04. 메서드와 this

메서드는 객체에 저장된 프로퍼티의 값을 활용하기 위해 존재한다. <br>
메서드 내부에서 this 를 사용하면 메서드를 호출한 객체에 접근할 수 있다.

⭐️ **`this` 는 런타임에 결정된다.**

<br>

## 4-1. 기본 원리 / 메서드와 this

- `this` 는 보통 **`점(.)` 앞의 객체** 를 나타낸다
- 메서드를 호출한 객체를 참조하기 때문에 동일한 메서드라도 호출한 객체에 따라 `this` 가 달라진다

```jsx
let user = {
  name: "John",
  sayHi() {
    console.log(this.name);
  },
};

user.sayHi(); // John
```

→ `user.sayHi()` 호출 시 `user` 가 `점(.)` 앞의 객체이기 때문에 `this` 는 `user` 객체를 가리킨다.

<br>

### 4-1-1. this 대신 외부 변수를 사용할 경우 문제점

`this`를 사용하지 않고 외부 변수를 사용하여 객체 참조를 하면 “**동적 특성**”을 사용할 수 없어 에러가 발생할 수 있다.

```jsx
let user = {
  name: "John",
  sayHi() {
    console.log(user.name); // 외부 변수 user 사용
  },
};

let admin = user;
user = null; // 🚨 user를 null로 덮어씀

admin.sayHi(); // Error: Cannot read property 'name' of null
```

`user`를 직접 참조했기 때문에 `user`가 `null`로 바뀌면 에러가 발생

<br>

## 4-2. 자유로운 this

처음 말했듯 **`this`는 런타임에 결정**된다. 동일한 함수라도 다른 객체에서 호출되었다면 참조하는 값이 달라진다.

함수가 어디에서 정의되었는가? ❌ → **함수가 어떻게 호출되었는가? ⭕️**

<br>

### 4-2-1. 동일한 함수를 다른 객체에서 호출하기

```jsx
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  console.log(this.name);
}

user.f = sayHi; // user에 함수 할당
admin.f = sayHi; // admin에 함수 할당

user.f(); // John (this == user)
admin.f(); // Admin (this == admin)
```

규칙 : `obj.f()` 호출 시 `this`는 `f`를 호출한 객체 `obj`를 참조

- `user.f()` → `this == user`
- `admin.f()` → `this == admin`

<br>

### 4-2-2. 객체 없이 호출하기: `this == undefined`

```jsx
"use strict";
function sayHi() {
  console.log(this);
}

sayHi(); // undefined
```

- 일반 함수에서 `this`를 사용하면 **엄격 모드**(`"use strict"`)에서는 `undefined`가 된다.
- 엄격 모드가 아닐 때는 `전역 객체(window)`를 참조한다.
- 함수 호출 시 `this`를 사용하려면 객체 컨텍스트에서 호출해야한다.

<br>

## 4-3. 화살표 함수와 `this`

### 💡 화살표 함수는 this 를 가지지 않는다!

화살표 함수는 `this` 를 가지지 않고 `외부함수(렉시컬 환경)의 this` 를 사용한다.

```jsx
let user = {
  firstName: "리육이",
  sayHi() {
    let arrow = () => console.log(this.firstName);
    arrow();
  },
};

user.sayHi(); // 리육이
```

- 화살표 함수의 `this`는 바깥 메서드 `sayHi()`의 `this`를 가져온다.
- `sayHi()`는 `user` 객체를 호출한 것이므로 `this`는 `user`를 참조한다.

<br>

## 4-4. this 정리

| 구분                 | **설명**                                                      |
| -------------------- | ------------------------------------------------------------- |
| `this`의 동적 특성   | `this`는 런타임에 결정되며, 메서드를 호출한 객체를 참조함     |
| 점(.) 앞의 객체      | `obj.f()` 호출 시 `this`는 `obj`를 참조함                     |
| 일반 함수의 `this`   | 엄격 모드에서는 `undefined`, 비엄격 모드에서는 전역 객체 참조 |
| 화살표 함수의 `this` | 화살표 함수는 자체 `this`가 없고, 외부 함수의 `this`를 참조   |

<br>

---

<br>

# 📝 05. new 연산자와 생성자 함수

유사한 객체를 여러 개 만들어야할 때 `객체 리터럴 {…}` 보다 **`new 연산자`와 `생성자 함수`를 사용하는 것을 권장**한다.

<br>

## 5-1. 생성자 함수

객체를 생성하는 함수로, 재사용 가능한 객체 생성코드를 구현할 때 사용된다.

⚠️ **생성자 함수를 만들 때 지켜야 할 사항 2가지**

1. 함수 이름의 첫 글자는 대문자로 시작한다.
2. 반드시 `new` 연산자를 붙여 호출해야하며, 새로운 객체가 생성되고 반환된다.

<br>

✅ **new 연산자에 의한 알고리즘 순서**

빈 객체 `this` 를 만들어 할당 → 함수 실행 → `this`에 새로운 프로퍼티 추가 → `this` 반환

```jsx
function User(name, age) {
  this.name = name;
  this.age = age;
  this.isAdmin = false;
}

let user1 = new User("John", 30);
console.log(user1.name); // "John"
console.log(user1.age); // 30
console.log(user1.isAdmin); // false
```

위 코드에서 `this = { };` 부분과 `return this` 부분은 `new` 연산자를 사용했을 때 알고리즘에 의해 처리해준다.

- `new User("John", 30)`를 호출하면 `User` 함수는 새로운 객체를 생성하고 반환
- `this`는 새로 생성된 객체를 참조

<br>

## 5-2. 익명 생성자 함수 (new function)

재사용할 필요가 없는 복잡한 객체를 만들 때 사용<br>
자주 쓰이지 않고 특별한 경우에만 사용된다.

```jsx
let user = new (function () {
  this.name = "John";
  this.isAdmin = false;

  // 복잡한 로직과 코드
  console.log("사용자 객체 생성 완료");
})();

console.log(user.name); // "John"
console.log(user.isAdmin); // false
```

이 생성자 함수는 익명이므로 함수 이름이 없다. 한번만 호출되기 위해 설계되었기 때문에 재사용 또한 불가능하다. → **\*코드 캡슐화**할 수 있다는 장점이 있다.

<br>

### 5-2-1. 코드 캡슐화 (Encapsulation)

**객체 지향 프로그래밍(OOP) 의 핵심 개념** 중 하나로, 데이터(속성)와 이를 처리하는 메서드(함수)를 하나의 단위로 묶고 외부로부터 특정 부분을 숨겨 **데이터의 무결성**과 **보안성을 유지하는 방법**이다.

**✅ 클로저(Closure) 를 활용한 캡슐화**

클로저를 활용하여 함수 내부에 변수를 정의한 후, 반환된 함수에서 접근하도록 하면 외부에서 직접 접근할 수 없는 프라이빗 변수를 만들 수 있다.

```jsx
function Developer(language) {
  let lang = language; // 프라이빗 변수

  return {
    getLang: function () {
      return lang;
    },
    setLang: function (newLang) {
      lang = newLang;
    },
  };
}

const dev = Developer("JavaScript");
console.log(dev.getLang()); // JavaScript
dev.setLang("TypeScript");
console.log(dev.getLang()); // TypeScript
console.log(dev.lang); // undefined (직접 접근 불가)
```

위 코드에서 `lang` 변수는 함수 스코프 내에 있으므로 회부에서 직접 접근할 수 없다.<br>
`getLang`, `setLang` 메서드를 통해서만 접근 가능하다.

<br>

✅ **ES6 클래스의 프라이빗 필드(Private Field) 사용**

ES6 이후 도입된 클래스 문법과 최근에는 프라이빗 필드를 정의할 수 있는 문법이 추가되었다.

```jsx
class Developer {
  #language; // ⭐️ 프라이빗 필드

  constructor(language) {
    this.#language = language;
  }

  getLanguage() {
    return this.#language;
  }

  setLanguage(newLanguage) {
    this.#language = newLanguage;
  }
}

const dev = new Developer("JavaScript");
console.log(dev.getLanguage()); // JavaScript
dev.setLanguage("TypeScript");
console.log(dev.getLanguage()); // TypeScript
console.log(dev.#language); // 🚨 SyntaxError: Private field '#language' must be declared in an enclosing class
```

`#`으로 시작하는 필드는 프라이빗 필드로 선언되어 클래스 외부에서 직접 접근이 불가능하다.

<br>

✅ **모듈 패턴(Module Pattern)을 통한 캡슐화**

즉시 실행 함수 표현식(IIFE)을 활용하여 프라이빗 변수와 메서드를 정의하고, 공개할 부분만 반환하는 방식

```jsx
const Developer = (function () {
  let lang = "JavaScript"; // ⭐️ 프라이빗 변수

  function getLang() {
    return lang;
  }

  function setLang(newLang) {
    lang = newLang;
  }

  return {
    getLang,
    setLang,
  };
})();

console.log(Developer.getLang()); // JavaScript
Developer.setLang("TypeScript");
console.log(Developer.getLang()); // TypeScript
console.log(Developer.lang); // 🚨 undefined (직접 접근 불가)
```

<br>

### 5-2-2. **캡슐화의 장점**

- **데이터 보호**: 외부에서 직접 접근을 제한하여 데이터의 무결성을 유지
- **코드 모듈화**: 관련된 데이터와 메서드를 하나의 단위로 묶어 코드의 가독성과 유지 보수성을 향상
- **인터페이스 제공**: 필요한 부분만 외부에 공개하여 객체의 사용 방법을 명확히 정의함

📚 참고자료
[[JavaScript] 8-3. 객체지향 프로그래밍(캡슐화) - DEVLOG](https://bkdevlog.netlify.app/posts/oop-encapsulation-of-js?utm_source=chatgpt.com)

<br>

## 5-3. new.target 과 생성자 함수

자바스크립트에서 `new` 키워드와 함께 호출되어 새로운 객체를 생성하는 생성자 함수와 달리, `new.target`은 함수 내부에서 해당 함수가 `new`와 함께 호출되었는지를 확인하는데 사용 되는 특수 프로퍼티이다.

<br>

### 5-3-1. `new` 없이 호출된 함수에서 `new.target` 확인하기

```jsx
function User(name) {
  console.log(new.target); // new.target 값을 출력
  this.name = name;
}

// `new` 없이 호출
User("Alice");
// 출력: undefined (new 키워드 없이 호출된 경우)

// `new`를 붙여 호출
new User("Bob");
// 출력: [Function: User] (new.target은 함수 자체를 가리킴)
```

### 5-3-2. `new` 없이 호출될 때 자동으로 `new`를 붙이기

```jsx
function User(name) {
  if (!new.target) {
    return new User(name); // new 없이 호출되면 new를 붙여 재호출
  }
  this.name = name;
}

const user1 = User("Alice"); // new 없이 호출
console.log(user1.name); // Alice

const user2 = new User("Bob"); // new와 함께 호출
console.log(user2.name); // Bob
```

**동작방식**

- 함수가 `new`와 함께 호출되면, `new.target` 은 해당 함수를 가리킨다.
- `new` 없이 호출되면, `new.target`은 `undefined` 이다.

<br>

✅ **생성자함수와 new.target 차이점 요약**

| **생성자함수**                                           | **new.target**                                                                   |
| -------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `new` 키워드와 함께 호출되어 새로운 객체를 생성하는 함수 | 함수 내부에서 해당 함수가 `new`와 함께 호출되었는지 확인하는데 사용되는 프로퍼티 |

<br>

## 5-4. 생성자 내 메서드

생성자 함수 내부에서 **객체의 메서드를 만드는 방법**은 **객체 프로퍼티에 함수를 할당하는 것**이다. 이렇게 생성된 메서드는 **각 인스턴스에 독립적으로 존재**한다.

```jsx
function User(name, age) {
  this.name = name;
  this.age = age;

  // 메서드 정의
  this.sayHi = function () {
    console.log(`안녕하세요! 제 이름은 ${this.name}입니다.`);
  };
}

const user1 = new User("Alice", 25);
const user2 = new User("Bob", 30);

user1.sayHi(); // 출력: 안녕하세요! 제 이름은 Alice입니다.
user2.sayHi(); // 출력: 안녕하세요! 제 이름은 Bob입니다.
```

**코드 설명**

1. `this.sayHi = function() {...}`: 생성자 함수 내에서 `this`를 통해 객체에 메서드 추가하기

2. 각 객체(`user1`, `user2`)는 자신의 `sayHi` 메서드를 가지고 있다. (메서드가 **각 인스턴스에 독립적으로 존재)**

⚠️ **위 코드의 문제점** : 생성자 함수 내에서 메서드를 만들 경우, 각 인스턴스마다 메서드가 복제되므로 메모리 낭비가 발생한다. 따라서 프로토타입에 메서드를 추가하는 방법이 효율적이다.

<br>

✅ **프로토타입에 메서드 정의**

```jsx
function User(name, age) {
  this.name = name;
  this.age = age;
}

// 프로토타입에 메서드 추가
User.prototype.sayHi = function () {
  // ⭐️ prototype 사용
  console.log(`안녕하세요! 제 이름은 ${this.name}입니다.`);
};
```

(\* 클래스, 프로토타입과 상속에서 다시 다룰 예정)

<br>

---

<br>

# 📝 06. 옵셔널 체이닝 ‘?’

( 🚨 추가된 지 얼마 안 된 문법으로 예전 브라우저에서는 폴리필이 필요)

## 6-1. 옵셔널 체이닝(optional chaining)

`?.`을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있다.

### 6-1-1. 옵셔널 체이닝이 필요한 이유

1. 옵셔널 체이닝이 없던 때에는 `&&` 연산자를 사용해서 구현했다.

   ```jsx
   let user = {}; // 주소 정보가 없는 사용자

   // ❌ 오류 코드
   alert(user.address.street); // TypeError: Cannot read property 'street' of undefined

   // 👍 && 연산자 사용
   alert(user && user.address && user.address.street); // undefined

   // 👏 옵셔널 체이닝 적용
   alert(user?.address?.street);
   ```

2. `&&` 로 연결해 해당 객체나 프로퍼티의 존재 유무를 확인하는 방법은 코드가 매우 길어진다는 단점이 있다.

<br>

### 6-1-2. 옵셔널 체이닝 사용하기

`?.`은 `?.`'앞’의 평가 대상이 `undefined`나 `null`이면 평가를 멈추고 `undefined`를 반환한다.

```jsx
let user = null;

alert(user?.address); // undefined
alert(user?.address.street); // undefined
```

- `? .`**‘앞’** 평가 대상에만 동작되고 확장은 되지 않는다.
- `user? .` 는 `user`가 `null` 이나 `undefined`인 경우만 처리할 수 있다.

<br>

### 6-1-3. 옵셔널 체이닝 주의사항

1. **옵셔널 체이닝 남용 금지!! 🚫**

   1. 위 예시에서 보면 `user`는 반드시 있어야하지만 `address`는 필수값이 아니다. 따라서 `user.address?.street` 를 사용해도 괜찮다.

   2. 만약 `user`에 값을 할당하지 않았다면 바로 알아낼 수 있도록 해야한다. 그렇지 않으면 에러를 조기에 발견하지 못해 디버깅이 어려워진다.

2. **`? .` 앞의 변수는 꼭 선언**되어 있어야한다.

   1. 변수 `user`가 선언되어 있지 않을 때 `user?.anything` 사용 시 에러가 발생한다.

<br>

## 6-2. 단락 평가 (short-circuit)

옵셔널 체이닝은 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈추는데 이를 단락 평가라고 부른다.

```jsx
let user = null;
let x = 0;

user?.sayHi(x++); // 아무 일도 일어나지 않음

alert(x); // 0, x는 증가하지 않음
```

<br>

## 6-3. () 와 ?.[]

`?.` 는 연산자가 아니다! 함수나 대괄호와 함께 동작하는 특별한 문법 구조체(syntax construct)이다.

<br>

**✅ 존재 여부가 확실치 않은 함수를 호출할 때**

```jsx
et user1 = {
  admin() {
    alert("관리자 계정입니다.");
  }
}

let user2 = {};

user1.admin?.(); // 관리자 계정입니다.
user2.admin?.();
```

`?.()`를 사용해 `admin`의 존재 여부를 확인할 때,  `user1`엔 `admin`이 정의되어 있기 때문에 메서드가 제대로 호출되었다.

반면 `user2`엔 `admin`이 정의되어 있지 않았음에도 불구하고 메서드를 호출하면 에러 없이 그냥 평가가 멈추는 것을 확인할 수 있다.

<br>

✅ **대괄호 `[ ]` 를 사용해 객체 프로퍼티에 접근하는 경우**

```jsx
let user1 = {
  firstName: "Violet",
};

let user2 = null; // user2는 권한이 없는 사용자라고 가정해봅시다.

let key = "firstName";

alert(user1?.[key]); // Violet ⭐️ 대괄호 사용
alert(user2?.[key]); // undefined ⭐️ 대괄호 사용

alert(user1?.[key]?.something?.not?.existing); // undefined
```

위 예시처럼 `?.[]`를 사용하면 객체 존재 여부가 확실치 않은 경우에도 안전하게 프로퍼티를 읽을 수 있다.

<br>

### ⚠️ ? . 옵셔널체이닝은 삭제하기에는 사용 가능! but 쓰기에는 사용할 수 없음!

```jsx
// delete
delete user?.name;

// user가 존재하면 user.name에 값을 쓰려는 의도로 작성
user?.name = "Violet"; // SyntaxError: Invalid left-hand side in assignment
```

<br>

## 6-4. 옵셔널 체이닝 요약

1. `obj?.prop` – `obj`가 존재하면 `obj.prop`을 반환하고, 그렇지 않으면 `undefined`를 반환함
2. `obj?.[prop]` – `obj`가 존재하면 `obj[prop]`을 반환하고, 그렇지 않으면 `undefined`를 반환함
3. `obj?.method()` – `obj`가 존재하면 `obj.method()`를 호출하고, 그렇지 않으면 `undefined`를 반환함

<br>

---

<br>

# 📝 07. 심볼형

자바스크립트는 객체 프로퍼티 키로 문자형과 심볼형만 허용한다. **→ 숫자, 불린형 모두 불가!**

## 7-1. 심볼

심볼(Symbol)은 `Symbol()` 을 사용하여 만들고 유일한 식별자(unique identifier)를 만들 때 사용한다.

```jsx
let id = Symbol("id");
```

위 코드에서 볼 수 있듯이 심볼을 만들 때 ‘심볼 이름’이라 불리는 설명을 붙일 수 있는데 이는 디버깅 시 매우 유용하다.

심볼은 유일성이 보장되는 자료형이기 때문에 설명이 동일한 심볼을 여러 개 만들더라도 각 심볼값은 다르다.

심볼에 붙이는 심볼이름(설명)은 어떤 것에도 영향을 미치지 않는다.

```jsx
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
```

**⚠️ 심볼은 문자형으로 자동 형 변환되지 않는다!**

```jsx
let id = Symbol("id");

alert(id); // TypeError: Cannot convert a Symbol value to a string
alert(id.toString()); // Symbol(id)가 얼럿 창에 출력됨
alert(id.description); // id
```

- 문자열과 심볼은 근본이 다르기 때문에 심볼을 출력해야한다면 `.toString()` 메서드를 명시적으로 호출해줘야한다.
- 심볼 이름(설명)만 보여주고 싶다면 `symbol.description` 프로퍼티를 이용하면 된다.

<br>

## 7-2. 숨김 프로퍼티

심볼을 이용하면 다른 코드와 충돌하지 않고 객체에 숨김(hidden) 프로퍼티를 만들 수 있다. 숨김 프로퍼티는 외부 코드에서 접근이 불가능하고 값 덮어쓰기도 불가능하다.

```jsx
let user = {
  name: "Alice",
};

const id = Symbol("id");
user[id] = 12345;

console.log(user); // { name: "Alice", [Symbol(id)]: 12345 }
console.log(user[id]); // 12345
```

**🤔 심볼 키를 사용하면 프로퍼티를 숨길 수 있는 이유? 심볼이 열거되지 않기 때문!**

<br>

### 7-2-1. `for…in` 반복문과 `Object.keys`에서 제외되는 심볼

심볼 프로퍼티는 일반 프로퍼티와 달리 열거되지 않는다.

✅ `for … in` , `Object.keys` 코드 예시

```jsx
let user = {
  name: "Alice",
  age: 25,
};

const id = Symbol("id");
user[id] = 12345;

// `for...in` 반복문
for (let key in user) {
  console.log(key); // name, age (심볼 프로퍼티는 출력되지 않음)
}

// Object.keys
console.log(Object.keys(user)); // ["name", "age"]
```

<br>

✅ `Object.assign` 은 키가 심볼인 프로퍼티를 배제하지 않는다!

```jsx
let id = Symbol("id");
let user = {
  [id]: 123,
};

let clone = Object.assign({}, user);

alert(clone[id]); // 123
```

이는 **의도적으로 설계된 것**으로, 객체를 복사 또는 병합할 때 `id` 같은 심볼을 포함한 **프로퍼티 전부를 사용하고 싶어할 것이라는 생각**에 이렇게 설계되었다.

<br>

### 7-2-2. 숨겨진 심볼 프로퍼티 접근 방법

1. **`Object.getOwnPropertySymbols()`** : 객체의 모든 심볼 프로퍼티를 가져옴

   ```jsx
   let symbols = Object.getOwnPropertySymbols(user);
   console.log(symbols); // [Symbol(id)]
   console.log(user[symbols[0]]); // 12345
   ```

2. **`Reflect.ownKeys()`** : 객체의 모든 키(문자열과 심볼)를 반환

   ```jsx
   console.log(Reflect.ownKeys(user)); // ["name", "age", Symbol(id)]
   ```

   <br>

## 7-3. 전역 심볼 (Global Symbol)

지금까지 심볼은 고유한 값을 가지기 때문에 이름이 같아도 서로 다른 심볼이 된다고 했는데, 전역 심볼 레지스트리(Global Symbol Registry) 를 사용할 경우 이름이 같으면 동일한 심볼을 반환 받을 수 있다.

<br>

### 7-3-1. `Symbol.for()`를 사용한 전역 심볼

**전역 심볼 레지스트리**에서 **심볼을 찾거나, 없으면 새로 등록**하는 역할

```jsx
// "id"라는 이름으로 전역 심볼 생성 (처음 호출이므로 새로 생성됨)
let id1 = Symbol.for("id");

// 같은 이름의 심볼을 다시 요청
let id2 = Symbol.for("id");

console.log(id1 === id2); // true (같은 심볼임)
```

- `Symbol.for("id")`를 호출하면 전역 심볼 레지스트리에서 `"id"`라는 이름의 심볼을 찾음
- 만약 존재하면 그 심볼을 반환하고, 없으면 새로 생성하여 등록한다
- 결과적으로 이름이 같으면 항상 같은 전역 심볼을 반환

<br>

### 7-3-2. `Symbol.keyFor()`로 전역 심볼의 이름 얻기

```jsx
let globalSymbol = Symbol.for("name"); //전역 심볼
let localSymbol = Symbol("name"); // 일반 심볼

console.log(Symbol.keyFor(globalSymbol)); // "name" (전역 심볼의 키를 반환)
console.log(Symbol.keyFor(localSymbol)); // undefined (전역 심볼이 아님)

console.log(localSymbol.description); // "name" (일반 심볼의 설명)
```

- `symbol.keyFor()`는 전역 심볼의 이름을 가져올 때 사용한다.
- **일반 심볼**에 사용하면 `undefined`를 반환
- 일반 심볼의 이름을 확인하려면 **`description`** 프로퍼티를 사용

<br>

### 7-3-3. 전역 심볼 vs 일반 심볼

| 전역 심볼                      | **일반 심볼**                |
| ------------------------------ | ---------------------------- |
| `Symbol.for()`를 사용해 생성   | `Symbol()`을 사용해 생성     |
| 이름이 같으면 동일한 심볼 반환 | 이름이 같아도 서로 다른 심볼 |

<br>

## 7-4. 시스템 심볼 (Well-known Symbols)

자바스크립트 내부 동작을 커스터마이징하거나 특정 기능을 활성화할 때 사용되는 내장 심볼

이 심볼은 ECMAScript 사양에 정의되어 있으며, **미리 정해진 용도**를 가지고 있다.

| **시스템심볼**             | **설명**                                                  |
| -------------------------- | --------------------------------------------------------- |
| **Symbol.iterator ⭐️**    | 객체에 반복자를 정의하면 `for…of` 루프를 사용할 수 있음   |
| **Symbol.hasInstance ⭐️** | `instanceof` 연산자가 객체를 검사할 때 동작 커스터마이징  |
| **Symbol.toPrimitive ⭐️** | 객체를 `원시 값(문자열, 숫자 등)으로 변환`할 때 동작 설정 |
| **Symbol.match**           | 객체를 정규 표현식의 `match` 메서드에서 사용할 수 있게 함 |
| **Symbol.search**          | 객체를 `search` 메서드에 사용할 수 있게 함                |
| **Symbol.asyncIterator**   | 객체에 `비동기` 반복자를 정의할 때 사용                   |

**(⭐️** = 대표적인 내장 심볼)

참고자료
[ECMAScript® 2025 Language Specification](https://tc39.es/ecma262/#sec-well-known-symbols)

<br>

---

<br>

# 📝 08. 객체를 원시형으로 변환하기

- 객체는 논리 평가 시 `true` 를 반환한다. 따라서 객체는 숫자형, 문자형으로만 형 변환이 일어난다고 생각하면 된다.
- `숫자형`으로의 형 변환 : 객체끼리 빼는 연산을 할 때나 수학 관련 함수를 적용할 때 나타난다.
- `문자형`으로의 형 변환 : 대체 `alert(obj)` 같이 객체를 출력하려고 할 때 일어난다.

객체는 기본적으로 원시형 값으로 변환되지 않으며, 연산이나 **특정 상황에서 원시형으로 변환이 필요할 때 자동으로 변환**되고 이 과정에서 아래 **세 가지 메서드가 호출**된다.

1. **`toString()`**
2. **`valueOf()`**
3. **`Symbol.toPrimitive`**

이 메서드들이 원시 값을 반환하지 않으면 `TypeError`가 발생한다.

<br>

## 8-1. ToPrimitive

특수 객체 메서드를 사용하면 숫자형이나 문자형으로의 형 변환을 원하는 대로 조절할 수 있다.

`ToPrimitive`는 ECMAScript 명세서에 정의된 알고리즘으로, 객체를 원시형으로 변환하기 위해 동작한다. 이 과정에서 `hint`가 중요한 역할을 한다.

### 8-1-1. ToPrimitive 변환 과정

1. `Symbol.toPrimitive`가 존재하면 호출
   - 해당 심볼 메서드가 반환하는 값을 사용.
2. 힌트에 따라 `toString` 또는 `valueOf` 호출
   - `"string"` 힌트:
     - `toString()` → `valueOf()` 순서로 호출.
   - `"number"` 힌트:
     - `valueOf()` → `toString()` 순서로 호출

<br>

### 8-1-2. hint 의 종류

힌트는 원시 값을 변환할 때 기대하는 타입이다.

- `string` : 객체를 **문자열**로 변환하려고 할 때
  - `alert(obj)` 또는 문자열 연결 (`+`) 연산 시 사용
- `number` : 객체를 **숫자**로 변환하려고 할 때
  - 산술 연산( `-` , `*` , `/`) 시 사용
- `default` : 보통 숫자와 문자열 **둘 다 가능하게 할 때** 사용

<br>

## 8-2. 변환 메서드의 구현하기

### 8-2-1. Symbol.toPrimitive

객체에 정의하면 원시형 변환 시 최우선으로 호출!

```jsx
let user = {
  name: "Alice",
  age: 25,
  [Symbol.toPrimitive](hint) { ✅
    console.log(`hint: ${hint}`);
    return hint === "string" ? `Name: ${this.name}` : this.age;
  }
};

console.log(String(user)); // hint: string, 출력: "Name: Alice"
console.log(+user);        // hint: number, 출력: 25
console.log(user + "");    // hint: default, 출력: "25"
```

### 8-2-2. toString() 과 valueOf()

- `toString()`: 객체를 문자열로 변환
- `valueOf()`: 객체를 숫자로 변환하려고 시도

```jsx
let user = {
  name: "Alice",
  age: 25,
  toString() {
    return `Name: ${this.name}`;
  },
  valueOf() {
    return this.age;
  },
};

console.log(String(user)); // "Name: Alice" (toString 호출)
console.log(+user); // 25 (valueOf 호출)
console.log(user + ""); // "25" (valueOf 호출 후 문자열로 변환)
```

<br>

### 🙋‍♀️ `console.log(user + "");` 이 부분 자세히 설명해주세요!

1. `+` 연산자의 동작 원리
   - 숫자 연산 (덧셈) : 양쪽 피연산자가 숫자라면 덧셈 연산을 수행
   - 문자열 연산 (문자열 연결) : 한쪽이라도 문자열이라면 문자열 연결 연산을 수행
2. `user + “”`의 평가 과정

   `user`는 **객체**, `“”` 는 **문자열**이므로 , `+` 연산자는 **문자열 연결을 시도**한다.

   1. 객체 → 원시형 변환
      - `user` 는 객체이기 때문에 원시형으로 변환
      - `ToPrimitive` 알고리즘에 의해 객체를 원시형으로 변환
   2. `+` 연산자와 문자열 `“”` 를 조합하면 여기서 힌트는 “`default`” 또는 “`string`”으로 설정
   3. 변환 메서드 호출
      - 힌트가 `string` 또는 `default` 이기 때문에, `toString() → valueOf()` 순서로 호출된다.
      - `toString`이 원시 값을 반환하면 변환 종료

3. 코드 다시 보기

```jsx
let user = {
  name: "Alice",
  age: 25,
  toString() {
    return `Name: ${this.name}`;
  },
  valueOf() {
    return this.age;
  },
};

console.log(user + ""); // "Name: Alice"
```

**진행 순서**

`user + ""` 평가 시작 → 문자열과 결합하므로 `힌트`는 `default` 또는 `string` → `"string"` 힌트에서는 `toString()` → `valueOf()` 순서로 호출 → `toString()`에서 문자열을 반환하므로 변환 끝 → 결과 “Name: Alice” 반환

4. 만약 `toString()`이 없다면?

```jsx
let user = {
  name: "Alice",
  age: 25,
  valueOf() {
    return this.age;
  },
};

console.log(user + ""); // "25"
```

`toString()`이 없으므로 `valueOf()` 호출 → 숫자 `25`는 문자열 `"25"`로 변환되고, 문자열 연결이 수행 → `"25"` 출력

<br>

## 8-3 추가 형 변환 ( \* )

곱셈을 해주는 연산자 `*` 는 피연산자를 숫자형으로 변환시킨다.

객체가 피연산자일 때는 아래 과정을 거쳐 형 변환이 일어난다.

- 객체는 원시형으로 변화된다.
- 변환 후 원시값이 원하는 형이 아닌 경우 형 변환이 다시 일어난다.

✅ **예시 코드**

```jsx
let obj = {
  // 다른 메서드가 없으면 toString에서 모든 형 변환을 처리
  toString() {
    return "2";
  },
};

alert(obj * 2); // 4, 객체가 문자열 "2"로 바뀌고, 곱셈 연산 과정에서 문자열 "2"는 숫자 2로 변경됩니다.
```

`obj` 객체가 형 변환을 시도하여 `toString` 때문에 문자열 “2” 가 된다.

하지만 곱셈 연산자 `*` 를 만나 “2” 는 **더이상 문자열이 아니라 숫자 2로 변환**되어 결과를 4로 출력한다.
<br>

---

<br>

# 📝 09. Map

지금까지의 자료구조는 **객체**(`key`가 있는 컬렉션 저장)와 **배열**(`순서`가 있는 컬렉션 저장)로 정리했다.

`Map` 과 `Set`도 객체, 배열과 유사하지만 약간의 차이점이 존재한다.

## 9-1. Map

`Map`은 키가 있는 데이터를 저장한다는alert 객체와 유사하지만, `key`에 다양한 자료형을 허용한다는 부분이 차이점이다.

대량 데이터를 처리할 때 객체보다 `Map`을 사용하는 것이 검색 및 삽입 성능이 뛰어나다.

### Map 메서드 및 프로퍼티

- `new Map()` : `맵` 생성
- `map.set(key, value)` : `key`를 이용해 `value` 저장
- `map.get(key)`: `key` 해당하는 값 반환 (없다면 `undefined` 반환)
- `map.has(key)` : `key`가 존재하면 `true`, 없으면 `false` 반환
- `map.delete(key)` : `key` 값 삭제
- `map.clear()`: `맵` 안의 모든 요소 제거
- `map.size` : 요소의 개수 반환

```jsx
let map = new Map();

map.set("1", "str1"); // 문자형 키
map.set(1, "num1"); // 숫자형 키
map.set(true, "bool1"); // 불린형 키

// 아래의 코드는 출력되는 값이 다르다. (맵은 키를 문자형으로 변환 ❌)
console.log(map.get(1)); // 'num1'
console.log(map.get("1")); // 'str1'

console.log(map.size); // 3
```

⭐️ `Map`은 객체와 달리 `key`를 문자형으로 변환하지 않는다. `key`에는 자료형 제약이 없다.

객체에서 대괄호를 사용했었는데 `Map`에서도 `map[key] = 2` 처럼 사용할 수 있긴 하지만, 이 방법은 **`map` 을 일반 객체처럼 취급**하게 된다. 여러 제약이 생기게 되므로 **`map`의 전용 메서드 `set`, `get` 등을 사용하도록 하자**

<br>

**✅** `Map`**의 `key`로 객체 사용하기**

```jsx
let john = { name: "John" };

// 고객의 가게 방문 횟수를 세본다고 가정
let visitsCountMap = new Map();

// john을 맵의 키로 사용
visitsCountMap.set(john, 123);

console.log(visitsCountMap.get(john)); // 123
```

⭐️ 객체를 `key`로 사용할 수 있다는 점이 `Map`의 가장 중요한 기능!!!

**🚨 객체형 `key`를 객체에 사용하기**

```jsx
let john = { name: "John" };

let visitsCountObj = {}; // 객체 생성

visitsCountObj[john] = 123; // 객체(john)를 키로 해서 객체에 값(123)을 저장

// 원하는 값(123)을 얻으려면 아래와 같이 키가 들어갈 자리에 `object Object`를 써줘야한다.
console.log(visitsCountObj["[object Object]"]); // 123
```

객체 `visitsCountObj`는 모든 `key`를 **문자형으로 변환**하는데, 이 때 `john`이 문자형으로 바뀌어 `"[object Object]"`가 된다.

<br>

### map 체이닝

`map.set`을 호출할 때마다 `Map`자신이 반환된다. 이를 활용하여 `map.set`을 체이닝 하는 것도 가능하다.

단, 체이닝은 코드의 가독성을 높이지만, **사용 시 `undefined` 같은 값이 저장될 위험성이 있으므로 주의**해야한다.

```jsx
let map = new Map();
map
  .set("a", 1)
  .set("b", undefined) // 체이닝 중 undefined 저장 가능
  .set("c", null);

console.log(map.get("b")); // undefined
console.log(map.size); // 3
```

<br>

## 9-2. Map 요소에 반복 작업하기

### 반복작업 메서드

- `map.keys()` : 각 요소의 `키`를 모은 이터러블 객체 반환
- `map.values()` : 각 요소의 `값`을 모은 이터러블 객체 반환
- `map.entries()` : 요소의 `[키, 값]`을 한 쌍으로 하는 이터러블 객체 반환
  → 이 이터러블 객체는 `for..of` 반복문의 기초로 사용된다.

✅ `Map`**은 삽입 순서를 기억하여 삽입된 순서대로 순회를 실시한다.**

```jsx
let recipeMap = new Map([
  ["cucumber", 500],
  ["tomatoes", 350],
  ["onion", 50],
]);

// 키(vegetable)를 대상으로 순회
for (let vegetable of recipeMap.keys()) {
  console.log(vegetable); // cucumber, tomatoes, onion
}

// 값(amount)을 대상으로 순회
for (let amount of recipeMap.values()) {
  console.log(amount); // 500, 350, 50
}

// [키, 값] 쌍을 대상으로 순회
for (let entry of recipeMap) {
  // recipeMap.entries()와 동일
  console.log(entry); // cucumber,500 ...
}
```

### 9-2-1. Map의 이터러블 특성

`Map` 은 기본적으로 이터러블 객체를 가지고 있어 `forEach`,`for…of` 문이나 스프레드 연산자를 활용할 수 있다.

```jsx
let map = new Map([
  ["apple", 10],
  ["banana", 20],
]);

for (let [key, value] of map) {
  console.log(`${key}: ${value}`);
}
// apple: 10
// banana: 20

console.log([...map]); // [["apple", 10], ["banana", 20]]
```

<br>

## 9-3. Object.entries: 객체 → Map

각 요소가 키-값 쌍인 배열이나 이터러블 객체를 초기화 용도로 `Map`에 전달해 새로운 `Map`을 만들 수 있다.

평범한 객체를 가지고 `Map`을 만들고 싶을 경우 `Object.entries(obj)`를 사용해야한다. \* (`[key, value]`로 가지는 배열을 반환함

```jsx
let obj = {
  name: "John",
  age: 30,
};

let map = new Map(Object.entries(obj));

console.log(map.get("name")); // John

// 1. Object.entries를 사용해 객체 obj를 배열 [ ["name","John"], ["age", 30] ]로 바꿈
// 2. 이 배열을 이용해 새로운 맵 생성
```

<br>

## 9-4. Object.fromEntries: Map → 객체

이 메서드는 각 요소가 `[키, 값]` 쌍인 배열을 객체로 바꿔준다.

`Object.fromEntries` 는 인수로 이터러블 객체를 받기 때문에 짧게 줄인 코드도 이전 코드와 동일하게 동작한다. 꼭 배열을 전달할 필요가 없다는 뜻!!

```jsx
let map = new Map();
map.set("banana", 1);
map.set("orange", 2);
map.set("meat", 4);

let obj = Object.fromEntries(map.entries()); // 맵을 일반 객체로 변환

// 맵이 객체가 되었습니다!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

`map.entries()` 를 호출하면 `Map`의 `[키, 값]`을 요소로 가지는 이터러블 반환한다.

**✅ `.entries()` 생략하여 짧게 줄이기 가능**

```jsx
let obj = Object.fromEntries(map.entries());
let obj = Object.fromEntries(map);

// 둘 다 같은 역할!
```

### 9-4-1. Object.entries()와 Object.fromEntries()의 활용

JSON 데이터를 처리하거나 변환하는 사례를 통해 조금 더 살펴보면 아래와 같다.

```jsx
// 서버에서 받은 JSON 데이터
let jsonData = {
  banana: 1,
  orange: 2,
  meat: 4,
};

// 객체 → 맵 변환
let map = new Map(Object.entries(jsonData));

// 맵 작업 수행
map.set("apple", 5);

// 맵 → 객체 변환 후 JSON으로 전송
let updatedJson = JSON.stringify(Object.fromEntries(map));
console.log(updatedJson); // {"banana":1,"orange":2,"meat":4,"apple":5}
```

## 9-5. 객체 vs Map 요약

| **특징**       | **객체(Object)**           | **맵(Map)**           |
| -------------- | -------------------------- | --------------------- |
| 키 타입        | 문자열, 심볼만 가능        | 모든 자료형           |
| 순서 유지      | 보장되지 않을 수 있음      | 삽입 순서 보장        |
| 크기 확인      | 직접 요소 개수 계산 필요   | `size` 프로퍼티 사용  |
| 반복 가능 여부 | 기본적으로 `Iterable` 아님 | 기본적으로 `Iterable` |

<br>

---

<br>

# 📝 10. Set

## 10-1. Set

`Set` 은 중복을 허용하지 않는 값을 모아놓은 컬렉션이다. `Set`에 `key`가 없는 값이 저장된다.

```jsx
let set = new Set();
set.add(1);
set.add(1); // 중복된 값은 무시됨
console.log(set.size); // 1 (값이 하나만 저장됨)
```

중복이 없기 때문에 `Set` 내에 동일한 값(`value`)이 있다면 `set.add(value)`을 아무리 많이 호출하더라도 아무런 반응이 없다.

<br>

### Set 메서드

- `new Set(iterable)` : `Set` 생성. 이터러블 객체를 전달받으면 그 안의 값을 복사하여 `Set`에 넣어준다.
- `set.add(value)`  : 값을 추가하고 `Set` 자신을 반환
- `set.delete(value)` : 값 제거. 호출 시점에 `Set` 내에 값이 있어 제거에 성공하면 `true`, 아니면 `false`를 반환
- `set.has(value)`  : `Set` 내에 값이 존재하면 `true`, 아니면 `false`를 반환
- `set.clear()` : `Set` 비우기
- `set.size` : `Set`에 몇 개의 값이 있는지 세준다.

✅ **사용예시**

```jsx
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// john, mary는 여러 번 방문할 수 있음
set.add(john); ✨
set.add(pete);
set.add(mary); ✨
set.add(john); ✨
set.add(mary); ✨

// 셋에는 중복되지 않은! 값만 저장된다 (중복해서 저장 ❌)
console.log( set.size ); // 3

for (let user of set) {
  console.log(user.name); // // John, Pete, Mary 순으로 출력됩니다.
}
```

<br>

## 10-2. Set 값에 반복 작업하기

### 반복작업 메서드

- `set.keys()` : `Set` 내의 모든 값을 포함하는 이터러블 객체를 반환
- `set.values()` : `set.keys`와 동일한 작업을 하며, `Map` 과 호환성을 위해 만들어진 메서드이다.
- `set.entries()` :  `Set` 내의 각 값을 이용해 만든 `[value, value]` 배열을 포함하는 이터러블 객체를 반환한다. 이 또한 `Map`과의 호환성을 위해 만들어졌다.

🤔 `set.keys()` 와 `set.values()`의 차이

두 메서드는 **실제로 같은 작업을 수행하지만 차이점은 “`Map`과의 호환성을 위해 설계되었는가?” 의 여부**에 따라 다른 점이 있다.

```jsx
let set = new Set(["apple", "banana", "cherry"]);
console.log([...set.keys()]); // ["apple", "banana", "cherry"]
console.log([...set.values()]); // ["apple", "banana", "cherry"]

// -> 하는 역할은 동일~!!
```

✅ `for..of`나 `forEach`를 사용하여 반복 작업 수행

```jsx
let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// forEach를 사용해도 동일하게 동작
set.forEach((value, valueAgain, set) => {
  console.log(value);
});
```

<br>

### set 체이닝

`set.add()`을 활용하여 `map.set` 처럼 체이닝이 가능하다.

```jsx
let set = new Set();
set.add("apple").add("banana").add("cherry");
console.log([...set]); // ["apple", "banana", "cherry"]
```

<br>

## 10-3. Set과 Array의 변환

`Set`과 `Array`는 상호 변환이 가능하다.

✅ 코드 예시

```jsx
// 배열 → Set 변환
let arr = [1, 2, 3, 3, 4];
let set = new Set(arr); // 중복 제거
console.log(set); // Set(4) { 1, 2, 3, 4 }

// Set → 배열 변환
let uniqueArray = [...set];
console.log(uniqueArray); // [1, 2, 3, 4]
```

<br>

---

<br>

# 📝 11. 위크**맵과 위크셋**

## 11-1. WeakMap과 WeakSet 개념

### WeakMap

- `WeakMap`은 `Map` 과 유사하지만 `key`가 반드시 **객체**여야한다.
- 해당 객체에 대한 참조가 약하게 유지되어 메모리 누수를 방지한다.
- 가비지 컬렉션 : `WeakMap`의 `key`는 약한 참조로, `key`에 해당하는 객체가 다른 곳에서 참조되지 않으면 메모리에서 자동으로 해제된다.
- 비공개 데이터 저장에 적합

### WeakSet

- `WeakSet`은 `Set`과 유사하지만, 값이 반드시 **객체**여야한다.
- 약한 참조로 유지되어 메모리 누수를 방지한다.
- 값으로 설정된 객체가 다른 곳에서 참조되지 않으면 가비지 컬렉션에 의해 제거된다.
- 객체 추적 및 중복 방지에 유용

<br>

## 11-2. WeakMap WeakSet 특징

| **특징**      | **WeakMap**                          | **WeakSet**                         |
| ------------- | ------------------------------------ | ----------------------------------- |
| `key` / 값    | 객체만 가능                          | 객체만 가능                         |
| 약한 참조     | `key`에 대한 약한 참조               | `값`에 대해 약한 참조               |
| 가비지 컬렉션 | `key`가 더이상 참조 되지 않으면 해제 | `값`이 더 이상 참조되지 않으면 해제 |
| 크기 확인     | `size` 프로퍼티 X                    | `size` 프로퍼티 X                   |
| 반복          | 반복 불가능                          | 반복 불가능                         |

### WeakMap과 WeakSet의 제한사항

1. **크기 확인 불가능** : `size` 프로퍼티가 없기 때문에 몇 개의 요소가 저장되어 있는지 알 수 없다.
2. **반복 불가능** : `forEach`, `for..of` 같은 반복 작업을 수행할 수 없다. 때문에 단순히 데이터 보관 용도로 사용된다.
3. **강한 참조와의 비교** : `Map`과 `Set`은 데이터를 강하게 참조하여 데이터가 명시적으로 삭제되지 않으면 메모리에서 해제되지 않는다.

<br>

## 11-3. 주요 메서드

### WeakMap 메서드

- **`weakMap.set(key, value)`**: 키-값 쌍을 추가
- **`weakMap.get(key)`**: 키에 해당하는 값을 반환, 키가 없으면 `undefined` 반환
- **`weakMap.delete(key)`**: 특정 키를 삭제
- **`weakMap.has(key)`**: 키가 존재하면 `true`를 반환

### **WeakSet 메서드**

- `weakSet.add(value)`: 객체를 추가
- `weakSet.has(value)`: 객체가 존재하면 `true` 반환
- `weakSet.delete(value)`: 특정 값을 삭제

<br>

## 11-4. 활용 예제

**✅ WeakMap 활용예제 - 객체와 추가 데이터 연결**

```jsx
let weakMap = new WeakMap();

let user = { name: "John" };
weakMap.set(user, "민감한 정보");

// weakMap.get()으로 데이터 접근
console.log(weakMap.get(user)); // 출력: "민감한 정보"

// user가 더 이상 참조되지 않으면 가비지 컬렉션에 의해 weakMap에서 제거됨
user = null;
```

<br>

**✅ DOM 요소와 데이터 연결**

DOM 요소에 데이터를 연결할 때 요소가 제거되면 자동으로 메모리가 해제된다.

```jsx
let weakMap = new WeakMap();

let button = document.querySelector("button");
weakMap.set(button, "Clicked");

// 버튼 제거 후 메모리에서 자동 해제
button.remove();
```

<br>

**✅ WeakSet 활용예제 - 객체 추적**

```jsx
let visitedSet = new WeakSet();

let john = { name: "John" };
let mary = { name: "Mary" };

visitedSet.add(john);
visitedSet.add(mary);

console.log(visitedSet.has(john)); // true
console.log(visitedSet.has(mary)); // true

// john이 참조되지 않으면 가비지 컬렉션으로 제거
john = null;
```

<br>

**✅ 중복 방지**

`WeakSet`은 중복된 객체를 자동으로 무시된다.

```jsx
let weakSet = new WeakSet();

let obj1 = {};
let obj2 = obj1;

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true
console.log(weakSet.has(obj2)); // true (같은 객체)
```

### **WeakMap과 WeakSet의 주요 활용 사례**

1. 메모리 누수 방지 : 약한 참조를 하기 때문에 참조되지 않는 데이터는 자동으로 메모리에서 해제
2. 비공개 데이터 저장 : 객체의 외부에서 접근할 수 없는 비공개 데이터를 저장하는데 적합
3. DOM 요소와 데이터 연결 : DOM 요소와 추가 데이터를 연결하여 DOM 요소가 제거되면 자동으로 데이터도 해제된다.

<br>

---

<br>

# 📝 12. Object.keys, values, entries

`key()`, `values()`, `entries()` 를 사용할 수 있는 자료구조는 `Map`, `Set`, `Array` 이다.

일반 객체에도 순회 관련 메서드가 있지만 문법에 차이가 있다.

- **Object.keys(obj)** : 객체의 `키`만 담은 배열을 반환
- **Object.values(obj)** : 객체의 `값`만 담은 배열을 반환
- **Object.entries(obj)** : `[키, 값]` 쌍을 담은 배열을 반환

`Object.keys`, `Object.values`, `Object.entries` 는 객체의 프로퍼티와 값을 다룰 수 있는 메서드로 이 메서드들은 객체를 반복(`iterate`)하거나 변환할 때 자주 사용된다.

<br>

## 12-1. 각 메서드 예제 코드

### Object.keys(obj)

객체의 “키(프로퍼티 이름)”만 배열로 반환한다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

console.log(Object.keys(user));
// ["name", "age", "isAdmin"]
```

### Object.values(obj)

객체의 “값(value)”만 배열로 반환한다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

console.log(Object.values(user));
// ["John", 30, true]
```

### Object.entries(obj)

객체의 "키-값” 쌍을 배열로 반환한다. 각 배열의 요소는 `[key, value]` 형태이다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

console.log(Object.entries(user));
// [["name", "John"], ["age", 30], ["isAdmin", true]]
```

<br>

## 12-2. 반복문에 활용해보기

### Object.keys(obj) + for…of

객체의 “**키**”만 순회

```jsx
let user = {
  name: "John",
  age: 30,
};

for (let key of Object.keys(user)) {
  console.log(key); // "name", "age"
}
```

### Object.values(obj) + for…of

객체의 “**값(value)**”만 순회

```jsx
let user = {
  name: "John",
  age: 30,
};

for (let value of Object.values(user)) {
  console.log(value); // "John", 30
}
```

### Object.entries(obj) + for…of

객체의 **키-값** 쌍을 순회

```jsx
let user = {
  name: "John",
  age: 30,
};

for (let [key, value] of Object.entries(user)) {
  console.log(`${key}: ${value}`);
}
// name: John
// age: 30
```

### 객체 변환에 활용하기

**✅ Object.values 를 사용하여 값의 총합 계산하기**

```jsx
let salaries = {
  John: 1000,
  Pete: 1200,
  Mary: 3000,
};

let total = Object.values(salaries).reduce((sum, salary) => sum + salary, 0);
console.log(total); // 5200
```

**✅ Object.entries 를 사용하여 객체를 배열로 변환하기**

```jsx
let user = {
  name: "John",
  age: 30,
};

// [key, value] 배열로 변환
let entries = Object.entries(user);

// 배열 정렬
let sorted = entries.sort(([key1], [key2]) => key1.localeCompare(key2)); // *localeCompare

console.log(sorted);
// [["age", 30], ["name", "John"]]
```

객체를 배열로 변환하였기 때문에 당연히 배열 메서드도 사용할 수 있다.

**\*`localeCompare()`** : 참조 문자열이 정렬 순으로 지정된 문자열 앞 혹은 뒤에 오는지 또는 동일한 문자열인지 나타내는 수치를 반환 ([MDN - localeCompare 참조 링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare))

✅ **Object.fromEntries 를 사용하여 배열을 객체로 변환하기**

```jsx
let entries = [
  ["name", "John"],
  ["age", 30],
];

// 배열 → 객체 변환
let user = Object.fromEntries(entries);

console.log(user);
// { name: "John", age: 30 }
```

### **객체 변환 메서드 간의 관계**

1. **객체 → 배열**
   - `Object.keys`, `Object.values`, `Object.entries`를 사용하여 객체를 배열로 변환
2. **배열 → 객체**
   - `Object.fromEntries`를 사용하여 `[key, value]` 배열을 객체로 변환

#### 💡Tip!

- 정렬된 결과가 필요하다면? → `Object.entries`를 사용해 배열로 변환 후, 정렬하여 사용
- 객체의 특정 프로퍼티 필터링 한다면? → `Object.entries`와 `filter`를 조합하여 특정 키-값만 필터링

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

// isAdmin을 제외한 객체 생성
let filteredEntries = Object.entries(user).filter(([key]) => key !== "isAdmin");

let filteredUser = Object.fromEntries(filteredEntries);

console.log(filteredUser);
// { name: "John", age: 30 }
```

<br>

---

<br>

# 📝 13. 구조 분해 할당

객체나 배열을 변수로 분해할 수 있는 특별한 문법으로 함수의 매개변수가 많거나 매개변수 기본값이 필요한 경우에 구조 분해 할당을 유용하게 사용할 수 있다.

## 13-1. 배열 분해하기

```jsx
let arr = ["Bora", "Lee"];

// firstName엔 arr[0]을 , surname엔 arr[1]을 할당
let [firstName, surname] = arr;

console.log(firstName); // Bora
console.log(surname); // Lee
```

인덱스를 이용해서 배열에 접근하지 않고 변수로 이름과 성을 사용할 수 있다.

```jsx
let [firstName, surname] = "Bora Lee".split(" ");
```

이 코드처럼 `split` 같은 배열을 반환하는 메서드를 함께 사용할 수 있다.

**✏️ 쉼표를 사용하여 요소 무시하기**

```jsx
// 두 번째 요소는 필요하지 않음
let [firstName, , title] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];

console.log(title); // Consul
```

만약에 두 번째 요소 (”Caesar”)를 사용하지 않고 값을 출력하려 한다면 쉼표를 사용하여 필요하지 않은 배열 요소를 버릴 수 있다.

- 쉼표로 두 번째 요소 Caesar 생략 → title 변수에 Consul 할당
- 네 번째 요소는 할당될 변수가 없기 때문에 생략

**✏️ 할당 연산자 우측엔 모든 이터러블이 올 수 있다**

```jsx
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

배열 뿐만 아니라 모든 이터러블에 구조 분해 할당을 적용할 수 있다.

**✏️ 할당 연산자 좌측엔 뭐든지 올 수 있다**

```jsx
let user = {};
[user.name, user.surname] = "Bora Lee".split(" ");

console.log(user.name); // Bora
```

할당 연산자 좌측에는 할당할 수 있는 것이라면 객체 프로퍼티 마저도 가능하다.

**✏️ .entries()로 반복하기**

```jsx
let user = {
  name: "John",
  age: 30,
};

// 객체의 키와 값 순회하기
for (let [key, value] of Object.entries(user)) {
  console.log(`${key}:${value}`); // name:John, age:30이 차례대로 출력
}

// Map에서도 사용 가능!
let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user) {
  console.log(`${key}:${value}`); // name:John, then age:30
}
```

지난 챕터에서 정리한 `Object.entries(obj)` 메서드와 구조 분해를 조합하면 객체의 키와 값을 순회해 변수로 분해 할당할 수 있다.

**✏️ 두 변수에 저장된 값 교환하기**

```jsx
let guest = "Jane";
let admin = "Pete";

// 변수 guest엔 Pete, 변수 admin엔 Jane이 저장되도록 값을 교환함
[guest, admin] = [admin, guest];

console.log(`${guest} ${admin}`); // Pete Jane
```

두 개의 변수에 저장된 값을 교환할 때도 구조 분해 할당을 사용하면 편리하게 바꿀 수 있다.

<br>

### 13-1-1. ‘`…`’ 로 나머지 요소 가져오기

배열 앞쪽에 위치한 값 일부만 사용하고 나머지 값들은 따로 모아 저장하고 싶을 때, 점 세 개 ‘`…`’ 를 붙인 매개변수 하나를 추가하면 나머지(`rest`) 요소를 가져올 수 있다.

```jsx
let [name1, name2, ...rest] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];

console.log(name1); // Julius
console.log(name2); // Caesar

// `rest`는 배열
console.log(rest[0]); // Consul
console.log(rest[1]); // of the Roman Republic
console.log(rest.length); // 2
```

- `rest`는 나머지 배열 요소가 저장된 **새로운 배열**이 된다.
- **⚠️ 변수 앞의 점 세 개(`…`)와 변수가 가장 마지막에 위치**해야한다.

### 13-1-2. 기본값

할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 커서, 할당할 값이 없으면 `undefined`로 취급되어 에러가 발생하지 않는다.

```jsx
let [firstName, surname] = [];

console.log(firstName); // undefined
console.log(surname); // undefined
```

✅ `=` 이용하여 기본값(`default value`) 설정하기

```jsx
// 기본값
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

console.log(name); // Julius (배열에서 받아온 값)
console.log(surname); // Anonymous (기본값)
```

이렇게 기본식으로 표현식이나 함수를 설정하면 할당할 값이 없을 때 표현식이나 함수가 호출된다.

```jsx
// name의 prompt만 실행됨
let [
  surname = prompt("성을 입력하세요."),
  name = prompt("이름을 입력하세요."),
] = ["김"];

console.log(surname); // 김 (배열에서 받아온 값)
console.log(name); // prompt에서 받아온 값
```

위 예시는 기본값으로 두 개의 `prompt` 함수를 할당한 예시이다.

값이 제공되지 않았을 때만 함수가 호출되기 때문에, `prompt` 는 한 번만 호출된다.

<br>

## 13-2. 객체 분해하기

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};

let { title, width, height } = options;

console.log(title); // Menu
console.log(width); // 100
console.log(height); // 200

// ⭐️ 이렇게 작성해도 동일하게 작동함!
let { height, width, title } = { title: "Menu", height: 200, width: 100 };
```

할당 연산자 우측에는 분해하고자 하는 객체를 적고, 좌측에는 상응하는 객체 프로퍼티 패턴을 넣는다.

순서는 중요하지 않고 ⭐️ 표시처럼 작성해도 동일하게 동작한다.

**✅ 조금 더 복잡한 패턴의 코드 살펴보기**

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { 객체 프로퍼티: 목표 변수 }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

console.log((title);  // Menu
console.log((w);      // 100
console.log((h);      // 200
```

`options.width` 를 `w` 라는 변수에 저장하는 방식의 코드인데, 좌측 패턴에 콜론 `:` 을 사용하면 된다.

- 콜론은 `분해하고자 하는 객체의 프로퍼티 : 목표 변수` 같은 형태로 사용한다.
- 프로퍼티가 없는 경우에는 `=` 을 사용하여 설정할 수 있다. (ex. `*let {width = 100, height = 200, title} = options;`)\*

**✅ 콜론 + 할당연산자 동시에 사용하기**

```jsx
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

console.log((title);  // Menu
console.log((w);      // 100
console.log((h);      // 200
```

**✅ 프로퍼티가 많은 복잡한 객체에서 원하는 정보만 뽑아오기**

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};

// title만 변수로 뽑아내기
let { title } = options;

console.log(title); // Menu
```

### 13-2-1. 나머지 패턴 ‘`…`’

나머지 패턴(rest pattern)을 사용하면 나머지 프로퍼티를 다른 곳에 할당하는 것이 가능하다. 단, IE를 비롯한 일부 브라우저에서는 나머지 패턴을 지원하지 않으므로 주의해야한다.

```jsx
let options = {
  title: "Menu",
  height: 200,
  width: 100,
};

// title = 이름이 title인 프로퍼티
// rest = 나머지 프로퍼티들
let { title, ...rest } = options;

// title엔 "Menu", rest엔 {height: 200, width: 100}이 할당
console.log(rest.height); // 200
console.log(rest.width); // 100
```

**✏️ `let` 없이 사용하기**

자바스크립트는 표현식 안에 있지 않으면서 주요 코드 흐름상에 있는 `{…}` 를 코드 블록으로 인식한다. 코드 블록의 본래 용도는 아래와 같이 문(statement)을 묶는 것이다.

```jsx
// ✅ 정상 작동 코드
{
  // 코드 블록
  let message = "Hello";
  // ...
  console.log( message );
}

// ===========================================================================

// 🚨 에러 발생 코드 - SyntaxError: Unexpected token '='
let title, width, height;

{title, width, height} = {title: "Menu", width: 200, height: 100};

// ===========================================================================

// 🚧 표현식으로 해석하게 만들기
let title, width, height;

// 에러가 발생하지 않음!
({title, width, height} = {title: "Menu", width: 200, height: 100}); ⭐️

console.log( title );
```

이 에러를 해결하기 위해서는 할당문을 괄호 `(…)`로 감싸서 자바스크립트가 `{…}`를 표현식으로 해석하기 만들면 된다.

<br>

## 13-3. 중첩 구조 분해(nested destructuring)

### 13-3-1. 중첩 객체 분해

객체 안에 또 다른 객체가 있는 경우, 중첩된 객체의 프로퍼티를 분해하여 변수에 할당할 수 있다.

```jsx
let options = {
  size: {
    width: 100,
    height: 200,
  },
  items: ["Cake", "Donut"],
  extra: true,
};

let {
  size: { width, height }, // size 내부의 width와 height
  items: [item1, item2], // items 배열의 첫 번째와 두 번째 요소
  title = "Menu", // 기본값 설정
} = options;

console.log(title); // Menu (기본값)
console.log(width); // 100
console.log(height); // 200
console.log(item1); // Cake
console.log(item2); // Donut
```

⚠️ `size`와 `items`는 변수로 선언되지 않는다. 대신 내부 프로퍼티만 분해된다.

### 13-3-2. 배열과 객체 조합

배열과 객체를 조합한 복잡한 구조도 분해 가능하다.

```jsx
let data = {
  title: "Sample Data",
  values: [
    { id: 1, name: "A" },
    { id: 2, name: "B" },
  ],
};

let {
  title,
  values: [
    { id: firstId }, // 첫 번째 객체의 id
    { name: secondName }, // 두 번째 객체의 name
  ],
} = data;

console.log(title); // "Sample Data"
console.log(firstId); // 1
console.log(secondName); // "B"
```

### 13-3-3. 중첩 구조 분해의 장점

1. 객체나 배열의 복잡한 구조를 쉽게 분해하여 필요한 데이터만 추출할 수 있다.
2. 기본값 설정과 변수 이름을 변경할 수 있다.

<br>

## 13-4. 똑똑한 함수 매개변수 (Smart Function Parameters)

### 13-4-1. 객체를 매개변수로 받아 구조분해 하기

함수의 매개변수로 객체를 받아 필요한 값만 구조분해 할 수 있다.

```jsx
function showMenu({
  title = "Untitled",
  width = 200,
  height = 100,
  items = [],
}) {
  console.log(`${title} - ${width}x${height}`);
  console.log(`Items: ${items.join(", ")}`);
}

let options = {
  title: "Menu",
  items: ["Item1", "Item2"],
};

showMenu(options);
// "Menu - 200x100"
// "Items: Item1, Item2"
```

### 13-4-2. 매개변수 이름 변경과 기본값 설정하기

객체의 프로퍼티 이름과 다른 변수명으로 할당하거나 기본값을 설정할 수 있다.

```jsx
function showMenu({
  title = "Untitled",
  width: w = 100, // width를 w로 바꿔서 사용
  height: h = 200, // height를 h로 바꿔서 사용
  items: [item1, item2], // 배열 구조 분해
}) {
  console.log(`${title} - ${w}x${h}`);
  console.log(`Items: ${item1}, ${item2}`);
}

let options = {
  title: "My Menu",
  items: ["Cake", "Donut"],
};

showMenu(options);
// "My Menu - 100x200"
// "Items: Cake, Donut"
```

### 13-4-3. 매개변수 기본값으로 빈 객체 사용하기

매개변수로 아무 것도 전달되지 않아도 에러가 발생하지 않도록, 기본값으로 빈 객체 `{}`를 설정할 수 있다.

```jsx
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  console.log(`${title} - ${width}x${height}`);
}

showMenu(); // "Menu - 100x200"
```

### 13-4-4. 똑똑한 함수 매개변수의 장점

1. 많은 매개변수를 한 번에 객체로 받아 관리 가능히다.
2. 기본값 설정과 객체 구조 분해를 통해 코드 가독성 향상된다.

<br>

---

<br>

# 📝 14. Date 객체와 날짜

## 14-1. Date 객체 생성하기

`new Date()`를 호출하면 새로운 `Date` 객체를 만들 수 있다.

```jsx
let now = new Date();
console.log(now); // 현재 날짜 및 시간이 출력

let Jan01_1970 = new Date(0);
console.log(Jan01_1970); // 1970년 1월 1일 0시 0분 0초(UTC+0)를 나타내는 객체

let Jan02_1970 = new Date(24 * 3600 * 1000);
console.log(Jan02_1970); // 1970년 1월 1일의 24시간 후는 1970년 1월 2일(UTC+0)
```

1970년의 첫날을 기준으로 이 이후의 밀리초를 나타내는 정수는 **타임스탬프(timestamp)** 라고 부른다.

1970년 1월 1일 이전의 날짜의 타임스탬프는 음수를 가진다.

타임스탬프를 사용하면 날짜를 숫자형태로 간편하게 나타낼 수 있는데 `new Date(timestamp)` 또는 `date.getTime()` 메서드를 사용해서 `Date` 객체에서 타임스탬프를 추출하는 것도 가능하다.

### **✅ new Date(datestring)**

하나뿐인 인수가 문자열이라면, 해당 문자열은 자동으로 구문 분석(parsed) 된다.

**`new Date(year, month, date, hours, minutes, seconds, ms)`**

주어진 인수를 조합해 만들 수 있는 날짜가 저장된 객체가 반환된다. 여기서 첫 번째와 두 번째 인수만 필수값이다. (지역 시간대 기준)

- `year`는 반드시 네 자리 숫자여야 한다.
- `month`는 `0`(1월)부터 `11`(12월) 사이의 숫자여야한다.
  - 자바스크립트에서는 `0`이 첫번째 요소이므로 이를 주의해서 로직을 작성해야한다.
- `date`는 값이 없는 경우엔 1일로 처리된다.
- `hours/minutes/seconds/ms`에 값이 없는 경우엔 `0`으로 처리된다.

<br>

## 14-2. 날짜 구성요소 얻기

### Date 객체 메서드 정리

이 메서드는 모두 현지 시간 기준 날짜 구성요소를 반환한다.

⭐️ `'UTC’`를 붙여주면 표준시(UTC+0) 기준의 날짜 구성 요소를 반환해주는 메서드 `getUTCFullYear()`, `getUTCMonth()`, `getUTCDay()`를 만들 수 있다.

⭐️ 다만 `getTime()`과 `getTimezoneOffset()` 는 변환할 수 없다.

| **메서드**                                                        | **반환값**                                                                 |
| ----------------------------------------------------------------- | -------------------------------------------------------------------------- |
| `getFullYear()`                                                   | 연도 반환 (네자리)                                                         |
| `getMonth()`                                                      | 월을 반환 (0 이상 11 이하)                                                 |
| `getDate()`                                                       | 일을 반환 (1 이상 31 이하)                                                 |
| `getHours()`, `getMinutes()`, `getSeconds()`, `getMilliseconds()` | 시, 분, 초, 밀리초를 반환                                                  |
| `getDay()`                                                        | 요일 반환 (일요일 = 0. 토요일 = 6)                                         |
| `getTime()` ⭐️                                                   | 주어진 일시와 1970년 1월 11일 00시 00분 00초 사이의 간격인 타임스탬프 반환 |
| `getTimezoneOffset()` ⭐️                                         | 현지 시간과 표준 시간의 차이(분) 반환                                      |

<br>

## 14-3. 날짜 구성요소 설정하기

### 메서드 종류

날짜 구성요소를 설정해주는 메서드들이다.

- `setFullYear(year, [month], [date])`
- `setMonth(month, [date])`
- `setDate(date)`
- `setHours(hour, [min], [sec], [ms])` : 날짜 구성요소를 동시에 설정 가능, 메서드 인수에 없는 구성요소는 변경되지 않는다.

  ```jsx
  let today = new Date();

  today.setHours(0);
  console.log(today); // 날짜는 변경되지 않고 시만 0으로 변경

  today.setHours(0, 0, 0, 0);
  console.log(today); // 날짜는 변경되지 않고 시, 분, 초가 모두 변경된다(00시 00분 00초)
  ```

- `setMinutes(min, [sec], [ms])`
- `setSeconds(sec, [ms])`
- `setMilliseconds(ms)`
- `setTime(milliseconds)` (1970년 1월 1일 00:00:00 UTC부터 밀리초 이후를 나타내는 날짜를 설정) : 유일하게 이 메서드만 UTC를 추가하여 표준시에 따라 날짜 구성 요소를 설정하는 메서드 없음!

<br>

## 14-4. 자동 고침

`Date` 객체는 범위를 벗어난 날짜를 입력하면 자동으로 조정된다. (ex. 1월 32일 입력하면 → 2월 1일로 수정)

✅ 예시 코드

```jsx
let date = new Date(2013, 0, 32); // 2013년 1월 32일은 없는 날짜
console.log(date); // 2013년 2월 1일 출력
```

**✅ 활용 예시**

- 윤년 계산 없이 간단히 날짜를 더하고 뺄 때 사용함

```jsx
let date = new Date(2016, 1, 28); // 2016년 2월 28일
date.setDate(date.getDate() + 2); // 이틀 추가
console.log(date); // 2016-03-01
```

- 시간을 더하거나 뺄 때도 사용 가능

```jsx
let date = new Date();
date.setSeconds(date.getSeconds() + 70); // 70초 추가
console.log(date); // 70초 후의 시간
```

- 음수 값을 입력하면 이전 날짜로 자동 조정

```jsx
let date = new Date(2016, 0, 2); // 2016년 1월 2일
date.setDate(0); // 0은 이전 달의 마지막 날
console.log(date); // 2015-12-31
```

<br>

## 14-5. 날짜 차이 계산하기

`Date` 객체는 숫자형으로 변환될 수 있고, 숫자로 변환하면 타임스탬프가 반환된다. 이를 사용하여 두 날짜 간의 차이를 계산할 수 있다.

```jsx
let start = new Date(); // 시작 시간

// 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // 종료 시간

console.log(`작업 완료에 걸린 시간: ${end - start}ms`); // 밀리초 단위 시간 차이
```

<br>

## 14-6. Date.now()

이 메서드는 현재 타임스탬프를 반환한다. `new Date()` ,`.getTime()`과 동일한 역할을 하지만, 더 빠르고 효율적이다.

```jsx
let start = Date.now(); // 시작 시간 (타임스탬프)

// 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // 종료 시간

console.log(`작업 완료에 걸린 시간: ${end - start}ms`);
```

<br>

## 14-7. 벤치마크 테스트

벤치마크 테스트는 함수의 성능을 비교하는 데 사용된다. 두 함수가 동일한 작업을 수행하더라도, 성능 차이를 확인할 수 있다.

**✅ 코드 예시**

```jsx
function diffSubtract(date1, date2) {
  return date2 - date1; // 객체를 숫자형으로 변환 후 연산
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime(); // getTime()으로 숫자값 반환 후 연산
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

console.log(`diffSubtract 실행 시간: ${bench(diffSubtract)}ms`);
console.log(`diffGetTime 실행 시간: ${bench(diffGetTime)}ms`);
```

⚠️ **주의할 점** : CPU 상황에 따라 결과가 달라질 수 있기 때문에 **여러 번 실행하여 평균값을 구해 신뢰성**을 높인다.

```jsx
let time1 = 0,
  time2 = 0;

for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

console.log(`diffSubtract 평균 시간: ${time1 / 10}ms`);
console.log(`diffGetTime 평균 시간: ${time2 / 10}ms`);
```

<br>

## 14-8. Date.parse()로 문자열 파싱

`Date.parse(str)` 를 사용하면 문자열을 날짜 객체로 변환할 수 있다.

이 문자열 형식은 `YYYY-MM-DDTHH:mm:ss.sssZ`처럼 생겨야한다.

### YYYY-MM-DDTHH:mm:ss.sssZ 형식 설명 및 코드 예시

- `YYYY-MM-DD`: 날짜 (필수)
- `T`: 날짜와 시간을 구분하는 문자
- `HH:mm:ss.sss`: 시간 (선택)
- `Z`: UTC 시간대 표시 (옵션)

✅ **코드 예시**

```jsx
let timestamp = Date.parse("2012-01-26T13:51:50.417-07:00");
console.log(timestamp); // 1327611110417 (타임스탬프)

let date = new Date(timestamp);
console.log(date); // 2012-01-26T20:51:50.417Z
```

**✅ 유용하게 활용하는 방법**

- `Date.parse()`로 타임스탬프를 받아 새로운 날짜 생성

```jsx
let date = new Date(Date.parse("2023-12-31T23:59:59Z"));
console.log(date); // 2023-12-31T23:59:59.000Z
```

<br>

---

<br>

# 📝 15. JSON과 메서드

## 15-1. JSON

JavaScript Object Notation의 약자로 값이나 객체를 나타내주는 범용 포맷이다. JSON은 자바스크립트에서 사용할 목적으로 만들어진 포맷이지만 라이브러리를 사용하면 자바스크립트가 아닌 언어에서도 JSON을 충분히 다룰 수 있다. 때문에 JSON을 데이터 교환 목적으로 사용하는 경우가 많으며 서버 측 언어가 무엇이든 상관없다.

### JSON 관련 메서드

`JSON.stringify` : 객체를 JSON으로 바꿔주는 메서드

`JSON.parse` : JSON을 객체로 바꿔주는 메서드

<br>

## 15-2. JSON.stringify

### `JSON.stringify`의 전체 문법

```jsx
let json = JSON.stringify(value, [replacer, space]);
```

- `value` : JSON으로 변환할 객체
- `repalcer` : JSON으로 변환할 프로퍼티를 제어할 **배열** 또는 **함수**
- `space` : 가독성을 위해 JSON 문자열에 추가할 공백 문자 수

**✅ 코드 예시**

```jsx
let student = {
  name: "John",
  age: 30,
  isAdmin: false,
  courses: ["html", "css", "js"],
  wife: null,
};

let json = JSON.stringify(student);

console.log(typeof json); // 문자열

console.log(json);

/* JSON으로 인코딩된 객체:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
```

`student`는 문자열로 바뀌었는데 이렇게 문자열로 변환된 후에야 네트워크를 통해 전송하거나 저장소에 저장할 수 있다.

변경된 문자열은 `*JSON으로 인코딩된(JSON-encoded)`, `직렬화 처리된(serialized)`, `문자열로 변환된(stringified)`, `결집된(marshalled)`\*객체라고 부른다.

### 15-2-1. JSON으로 인코딩 된 객체의 특징

- 문자열은 큰따옴표로 감싸야한다.
  → 작은 따옴표, 백틱을 사용할 수 없다.
- 객체 프로퍼티 이름은 큰따옴표로 감싸야한다.
  → `age : 30` 이 `“age” : 30` 으로 변한 것 확인

### 15-2-2. 원시값에 적용하기

적용할 수 있는 자료형

- 객체
- 배열
- 원시형
  - 문자형
  - 숫자형
  - 불린형
  - `null`

JSON은 데이터 교환을 목적으로 만들어진 언어에 종속되지 않는 포맷이다.
<br>따라서 자바스크립트 특유의 객체 프로퍼티는 `JSON.stringify` 로 처리할 수 없다.

### 15-2-3. JSON.stringify 호출 시 무시되는 프로퍼티

- 함수 프로퍼티 (메서드)
- 심볼형 프로퍼티 (키가 심볼인 프로퍼티)
- 값이 `undefined`인 프로퍼티

```jsx
let user = {
  sayHi() {
    // 무시
    console.log("Hello");
  },
  [Symbol("id")]: 123, // 무시
  something: undefined, // 무시
};

console.log(JSON.stringify(user)); // 빈 객체 출력
```

### 15-2-4. JSON.stringify 장점과 주의사항

**👏 중첩 객체도 알아서 문자열로 바꿔주는 장점이 있다.**

```jsx
let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"],
  },
};

console.log(JSON.stringify(meetup));

/* 
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
```

⚠️ **순환 참조시 주의하기**

**순환 참조**: 객체의 프로퍼티가 자기 자신을 참조하거나 다른 객체를 참조하다가 **결국 다시 자기 자신으로 돌아오는 경우**를 말한다. 이 경우 `JSON.stringify`는 **에러**를 발생시킨다.

```jsx
let room = {
  number: 23,
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"],
};

meetup.place = room; // meetup은 room을 참조
room.occupiedBy = meetup; // room은 meetup을 참조

JSON.stringify(meetup); // Error: Converting circular structure to JSON
```

**✅ 간단한 코드로 복습하기**

```jsx
let obj = {};
obj.self = obj; // obj가 자기 자신을 참조

JSON.stringify(obj);
// TypeError: Converting circular structure to JSON
```

**🚧 해결방법**

1. **객체를 직렬화 하기 전에 순환 참조 제거하기**

```jsx
let obj = {};
obj.name = "Example";
obj.self = obj; // 순환 참조

// 순환 참조 제거
obj.self = null;

console.log(JSON.stringify(obj));
// {"name":"Example","self":null}
```

2. **`replacer` 함수 사용하기 → 13-3 챕터에서 정리 예정**

```jsx
let obj = {};
obj.name = "Example";
obj.self = obj;

let json = JSON.stringify(obj, (key, value) => {
  if (value === obj) return undefined; // 순환 참조 제거
  return value;
});

console.log(json);
// {"name":"Example"}
```

3. **외부 라이브러리 사용하기 (ex. circular-json, flatted)**

```jsx
// npm install flatted
const { stringify } = require("flatted");

let obj = {};
obj.name = "Example";
obj.self = obj;

console.log(stringify(obj));
// {"name":"Example","self":"~"}
```

- [circular 라이브러리](https://www.npmjs.com/package/circular-json)
- [flatted 라이브러리](https://www.npmjs.com/package/flatted)

<br>

## 15-3. replacer로 원하는 프로퍼티만 직렬화하기

앞에서 살짝 다뤘지만 순환 참조를 다뤄야하는 경우처럼, 전환 프로세스를 정교하게 조정하려면 `replacer` 라는 두 번째 인수를 사용해야한다.

### 15-3-1. replacer에 배열 전달

- JSON으로 변환할 **프로퍼티 이름을 배열로 전달**하여 선택적으로 직렬화할 수 있다.

```jsx
let meetup = {
  title: "Conference",
  participants: [{ name: "John" }, { name: "Alice" }],
  location: "Online",
};

console.log(JSON.stringify(meetup, ["title", "participants"]));
// {"title":"Conference","participants":[{},{}]}
```

**문제점:** 중첩 객체나 배열의 프로퍼티는 명시적으로 포함하지 않으면 비어 있는 객체(`{}`)로 출력된다.

### 15-3-2. replacer에 함수 전달

- 함수를 전달하면 객체의 모든 프로퍼티를 재귀적으로 처리할 수 있다.
- 반환 값이 `undefined`인 프로퍼티는 직렬화되지 않는다.

```jsx
let room = { number: 23 };
let meetup = {
  title: "Conference",
  participants: [{ name: "John" }, { name: "Alice" }],
  place: room,
};
room.occupiedBy = meetup; // 순환 참조

let json = JSON.stringify(meetup, function replacer(key, value) {
  // 순환 참조 제거
  return key === "occupiedBy" ? undefined : value;
});

console.log(json);
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
```

코드 설명:

1. `replacer` 함수는 객체의 모든 프로퍼티를 `키-값` 쌍으로 처리한다.
2. 반환된 값만 JSON에 포함된다.
3. 첫 번째 호출에서는 키가 `“”` 이고 값이 객체 전체이다.

<br>

## 15-4. space로 가독성 높이기

space 매개변수를 사용하면 JSON 문자열에 공백, 들여쓰기를 추가할 수 있다.

숫자를 전달하면 해당 공백 문자 수로 들여쓰기 된다.

**✅ 코드 예시 - 숫자 전달**

```jsx
let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
};

console.log(JSON.stringify(user, null, 2));
/*
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/
```

**✅ 다양한 공백 추가하기 - 문자열 전달**

```jsx
// 📚 "--"로 들여쓰기
console.log(JSON.stringify(user, null, "--"));

/*
{
--"name": "John",
--"age": 25,
--"roles": {
----"isAdmin": false,
----"isEditor": true
--}
}
*/
```

## 15-5. replacer + space 조합하여 사용해보기

✅ 특정 프로퍼티 선택 후 가독성 높이기

```jsx
let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
  password: "secret",
};

let json = JSON.stringify(
  user,
  (key, value) => (key === "password" ? undefined : value), // password 제거
  4 // 들여쓰기
);

console.log(json);

/*
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
```

### 요약 및 Tip

| **매개변수** | **역할**                              | **사용예시**                                      |
| ------------ | ------------------------------------- | ------------------------------------------------- |
| replacer     | 선택적으로 프로퍼티를 직렬화 or 제거  | 배열로 포함할 프로퍼티 지정, 함수로 조건 처리하기 |
| space        | JSON 문자열의 가독성을 위한 공백 추가 | 들여쓰기 숫자 or 문자열 전달                      |

- **순환참조 처리** : `replacer` 활용하여 순환 참조 제거
- **데이터 필터링** : `replacer`를 사용해 민감한 데이터를 직렬화에서 제외시키기
- **가독성** : 디버깅 시 `space` 매개변수를 사용해 직렬화 된 JSON을 읽기 쉽게 출력하기

## 15-4. JSON.parse

JSON 형식의 문자열을 JavaScript 객체로 변환하는 메서드이다. `JSON.parse()`를 사용하면 JSON으로 인코딩 된 객체를 다시 디코딩 할 수 있다.

### `JSON.parse`의 전체 문법

```jsx
let value = JSON.parse(str, [reviver]);
```

- `str` : JSON 형식의 문자열
  - 유효한 JSON 형식이어야 함
  - 큰따옴표(`"`)로 감싸야 하며, 작은따옴표(`'`)는 허용되지 않음
- `reviver` : 변환된 객체의 각 키-값 쌍을 처리하는 함수

**✅ 기본 변환 코드 예시**

```jsx
let jsonString = '{"name": "John", "age": 30, "isAdmin": false}';
let user = JSON.parse(jsonString);

console.log(user.name); // "John"
console.log(user.age); // 30
console.log(user.isAdmin); // false
```

**✅ 중첩 객체 변환**

```jsx
let jsonString = `{
  "name": "John",
  "age": 30,
  "address": {
    "city": "New York",
    "zip": "10001"
  }
}`;
let user = JSON.parse(jsonString);

console.log(user.address.city); // "New York"
console.log(user.address.zip); // "10001"
```

**✅ 배열 변환**

```jsx
let jsonString = "[1, 2, 3, 4, 5]";
let numbers = JSON.parse(jsonString);

console.log(numbers[0]); // 1
console.log(numbers[4]); // 5
```

## 15-5. reviver 사용하기

- `reviver` 함수를 사용하면 변환된 객체의 각 `키-값` 쌍을 조작할 수 있다.
- `key` 와 `value` 를 매개변수로 받아 새로운 값을 반환한다.

### 15-5-1. 특정 값 필터링

```jsx
let jsonString = '{"name": "John", "age": 30, "isAdmin": false}';

let user = JSON.parse(jsonString, (key, value) => {
  // "age" 필드는 값을 2배로 변경
  if (key === "age") return value * 2;
  return value; // 다른 값은 그대로 반환
});

console.log(user.age); // 60
```

### 15-5-2. 날짜 변환

```jsx
let jsonString = '{"name": "John", "birthDate": "1990-01-01T00:00:00.000Z"}';

let user = JSON.parse(jsonString, (key, value) => {
  if (key === "birthDate") return new Date(value);
  return value;
});

console.log(user.birthDate); // Date 객체
console.log(user.birthDate.getFullYear()); // 1990
```

JSON은 날짜를 문자열로 저장하기 때문에 객체로 변환하려면 `reviver`를 사용해야한다.

<br>

## 15-6. JSON.parse 에러 처리하기

`JSON.parse`는 유효하지 않은 JSON 문자열을 만나면 에러를 발생시킨다. 이를 방지하기 위해 `try…catch` 문을 사용해준다.

**✅ 코드 예시**

```jsx
let invalidJson = "{name: 'John'}"; // JSON 형식 오류 (큰따옴표가 없음)

try {
  let user = JSON.parse(invalidJson);
} catch (error) {
  console.error("JSON parsing error:", error.message);
  // SyntaxError: Unexpected token n
}
```
