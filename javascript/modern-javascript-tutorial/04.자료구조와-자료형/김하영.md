# 📝 01. 원시값의 메서드

자바스크립트는 원시값(문자열, 숫자 등)을 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다. 본격적으로 들어가기 전에 원시값 ≠ 객체 라는 것을 꼭 잊지 말자!

| **구분** | **원시값**                                                                                     | **객체**                                                                  |
| -------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **특징** | 원시형 값                                                                                      | 프로퍼티에 다양한 종류의 값을 저장할 수 있음                              |
| **종류** | 문자(`string`), 숫자(`number`), `bigint`, 불린(`boolean`), 심볼(`symbol`), `null`, `undefiend` | 중괄호 `{ }` 를 사용하여 만들며, 함수를 포함하여 여러 종류의 객체가 있다. |

- 객체의 장점 : 함수를 프로퍼티로 저장할 수 있다.
- 객체의 단점 : 다양한 내장 객체를 제공하고 이 객체들은 고유한 프로퍼티와 메서드를 가진다. 그러나 이런 기능을 사용하면 시스템 자원이 많이 소모된다.

```jsx
let john = {
  name: "John",
  sayHi: function () {
    alert("친구야 반갑다!");
  },
};

john.sayHi(); // 친구야 반갑다!
```

## 1-1. 원시값을 객체처럼 사용하기

### Wrapper Object란?

```jsx
let str = "문자열"; // 문자열 생성
let len = str.length; // 문자열 프로퍼티인 length 사용
```

자바스크립트에서 원시값에 대해 메서드나 프로퍼티를 호출하면 해당 원시값은 임시 객체로 변환된다. 이 임시 객체는 객체의 메서드와 프로퍼티를 사용할 수 있도록 해준다.

위 예제 코드에서 보면 문자열 리터럴 `str`은 객체가 아님에도 `length` 프로퍼티를 사용할 수 있다. 이는 프로그램이 문자열 리터럴 `str`의 프로퍼티를 참조하려고 할 때, 자바스크립트는 `new String(str)`을 호출한 것처럼 문자열 리터럴을 객체로 자동변환해주기 때문이다.

**이렇게 숫자, 문자열, 불리언 등 원시 타입의 프로퍼티에 접근하려고 할 때 생성되는 임시 객체를 래퍼 객체(Wrapper Object) 라고 한다.**

📚 참고자료
[코딩교육 티씨피스쿨](https://www.tcpschool.com/javascript/js_standard_object)

<br />

**✅ 동작 과정**

```jsx
let str = "hello";

// 원시값에 대해 메서드를 호출
console.log(str.toUpperCase()); // "HELLO"

// 실제로는 다음과 같이 동작
// 1. "hello" → 임시 String 객체로 변환
// 2. String 객체의 toUpperCase() 호출
// 3. 결과 반환 후 임시 객체 제거
```

1. 원시값 → 객체로 변환

   (ex. `“hello”.toUpperCase()` 실행하면, 문자열 “hello” 가 `String` 객체로 변환)

2. 메서드/프로퍼티 실행 : 변환된 객체에서 메서드 실행
3. 임시 객체 제거 : 메서드 실행이 끝나면 임시 객체가 제거되면서 원래의 원시값으로 돌아감

<br />

### 원시값과 래퍼 객체의 차이점 = 원시값은 불변(Immutable)하다.

- 원시값은 변경할 수 없으며, 항상 새로운 값을 생성
- 래퍼 객체는 메서드 실행을 위한 임시 객체로만 존재한다.

```jsx
let str = "hello";
str.test = 123; // 임시 String 객체에 test 프로퍼티 추가 (즉시 삭제됨)
console.log(str.test); // undefined (test는 존재하지 않음)
```

<br />

### 원시값을 객체처럼 사용하는 대표적인 메서드

1. **문자열 (String)**

   1. `.toUpperCase()`, `.toLowerCase()`

   2. `.slice()`, `.substring()`

   3. `.length`

2. **숫자 (Number)**

   1. `.toFixed()`

   2. `.toString()`

3. **불리언 (Boolean)**
   1. `.toString()`

<br />

## **1-2. `String/Number/Boolean`를 생성자로 쓰지 말자!**

원시값을 명시적으로 객체로 감싸려면 `new` 키워드를 사용해서 래퍼 객체를 생성할 수 있다. <br />
다만, 이 방법은 혼란을 줄 수 있어 권장되지 않고 잘 사용되지 않는다.

**예제**

```jsx
let str = new String("hello"); // String 객체 생성
console.log(typeof str); // "object"
console.log(str.toUpperCase()); // "HELLO"

let num = new Number(123); // Number 객체 생성
console.log(typeof num); // "object"
console.log(num.toFixed(2)); // "123.00"
```

**⚠️ 주의해야하는 이유**

```jsx
let str1 = "hello";
let str2 = new String("hello");

console.log(str1 === "hello"); // true (원시값 비교)
console.log(str2 === "hello"); // false (객체와 원시값 비교)

console.log(typeof str1); // "string"
console.log(typeof str2); // "object"
```

명시적으로 래퍼 객체를 생성하면 일반적인 원시값과 다르게 동작할 수 있으므로 사용에 주의해야 한다.

## **1-3. null , undefined 는 메서드가 없다.**

특수 자료형인 `null`, `undefined`의 원시값은 이 자료형과 연관되는 “래퍼 객체”가 없고, 메소드도 제공하지 않는다.

<br />

---

# 📝 02. 숫자형

자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원한다. 일반적인 숫자는 64비트 부동소수점 형식의 IEEE-754에 저장된다. ( → 대부분 이 형식을 이용)

임의의 길이를 가진 정수는 `BigInt` 숫자로 나타낼 수 있다. 일반적인 숫자는 길이의 제약이 있기 때문에 만들어진 새로운 자료형이다. <br />주로 큰 숫자 계산이 필요한 암호화, 금융 등에서 유용하게 사용된다.

```jsx
const largeNumber = 123456789012345678901234567890n;
const anotherLargeNumber = 987654321098765432109876543210n;

console.log(largeNumber + anotherLargeNumber);
// 출력: 1111111110111111111011111111100n
```

- 숫자 뒤에 `n` 을 붙이면 `BigInt` 리터럴로 정의된다.
- `.BigInt()` 함수를 이용하여 생성할 수 있다.
- 크기에 제한 없이 정수를 정확히 표현한다.
- 소수는 지원히지 않는다.
- `Number`와 호환되지 않으며 `BigInt` 끼리만 비교가 가능하다.

  ```jsx
  // ❌ Number와 호환되지 않음
  const big = 10n;
  const num = 20;
  console.log(big + BigInt(num)); // 30n
  // console.log(big + num); // TypeError

  // 🚨 BigInt끼리만 비교 가능
  console.log(1n == 1); // true (== 사용하면 타입 강제로 변환하여 비교)
  console.log(1n === 1); // false
  ```

<br />

## 2-1. 숫자를 입력하는 다양한 방법

### 2-1-1. e 시용하여 숫자 나타내기

`e` 표기법은 **숫자가 너무 크거나 너무 작을 때 이를 간단히 표현**하기 위해 사용된다. <br />`e`는 10의 거듭제곱을 나타내며, `e` 를 기준으로 왼쪽 숫자와 오른쪽 숫자의 조합으로 크거나 작은 숫자를 계산한다.

보통 과학적 계산, 금융 애플리케이션(금액 단위 축약 표현), 물리학 등에서 사용된다.

<br />

✅ **큰 숫자 나타내기 (e 뒤에 양수)**

`e` 뒤에 **양수**를 붙이면, 해당 숫자는 **10의 거듭제곱을 곱한 값**을 나타낸다.

```jsx
let billion = 1e9; // 10억, 1과 9개의 0
console.log(billion); // 1000000000

let seventyThreeBillion = 7.3e9; // 7.3 뒤에 9개의 0
console.log(seventyThreeBillion); // 7300000000

// e 를 기준으로 왼쪽 수에 오른쪽 수 만큼 10의 거듭제곱
1e3 === 1 * 1000;
1.23e6 === 1.23 * 1000000;
```

✅ **작은 숫자 나타내기 (e 뒤에 음수)**

`e` 뒤에 음**수**를 붙이면, 해당 숫자는 **10의 거듭제곱을 나눈 값**을 나타낸다.

```jsx
let microsecond = 1e-6; // 1을 왼쪽으로 소수점 6번 이동
console.log(microsecond); // 0.000001
```

<br />

### 2-1-2. 16진수, 2진수, 8진수

1. 16진수

   - 색 나타내기, 문자를 인코딩할 때 등 다양한 곳에서 쓰인다.
   - 16진수는 `0x` 를 사용하여 짧게 표현할 수 있다.

   ```jsx
   alert(0xff); // 255
   alert(0xff); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타냅니다.)
   ```

2. 2진수와 8진수

   - `0b` 와 `0o`를 사용해 간단하게 표현한다.

   ```jsx
   let a = 0b11111111; // 255의 2진수
   let b = 0o377; // 255의 8진수

   alert(a == b); // true, 진법은 다르지만, a와 b는 같은 수
   ```

3. 이 3가지 진법 이외의 진법을 사용하려면 `parseInt` 메서드를 사용해야한다.

<br />

### 2-1-3. toString(base)

```jsx
number.toString(base);
```

`toString` 메서드는 `base`(진법)로 결과값을 **문자형으로 변환**해 반환한다.

- `base` : 숫자를 표현하는 방법, 숫자를 몇 개의 기호로 나타낼지 결정한다.
- `base` 는 2~36 사이의 정수를 지정하고 이를 통해 숫자를 2진법, 16진법 등 다양하게 변환할 수 있다.
  - 10진법(Base 10) : 0~9로 숫자를 표현 (일상에서 사용)
  - 2진법(Base 2) : 0과 1로 숫자를 표현 (컴퓨터에서 사용)

**✅ 간단 예제**

```jsx
let num = 255;

// 10진법
console.log(num.toString(10)); // "255"

// 2진법
console.log(num.toString(2)); // "11111111"

// 16진법
console.log(num.toString(16)); // "ff"

// 8진법
console.log(num.toString(8)); // "377"
```

1. **10진법 (Decimal)** : `Base 10`으로 숫자를 표현, 숫자 255는 그대로 “255”로 표현

2. **2진법 (Binary)** : `Base 2`로 숫자를 표현, **0과 1로만 구성**
3. **8진법 (Octal)** : `Base 8`로 숫자를 표현, 숫자는 **0~7로 구성**
4. **16진법 (Hexadecimal)** : `Base 16`으로 숫자를 표현, **숫자 0~9 + 문자 A~F를 사용**함 (10~15는 각각 A,B,C,D,E,F 로 표현)
5. **36진법 (Base 36)** : `Base 36`으로 숫자를 표현, **숫자 0~9 + 문자 A~Z를 사용**하여 가장 긴 표현을 제공

<br />

### 2-1-4. parseInt와 parseFloat

`parseInt`와 `parseFloat` 두 함수는 불가능할 때까지 문자열에서 숫자를 읽는다. <br />
만약 읽는 도중 오류가 발생하면 그 시점까지 읽어서 수집된 숫자를 반환한다.

**`parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환**한다.

```jsx
console.log(parseInt('100px')); // 100
console.log(parseFloat('12.5em') ; // 12.5

console.log(parseInt('12.3')); // 12, 정수 부분만 반환
console.log(parseFloat('12.3.4')); // 12.3, 두 번째 점에서 숫자 읽기 중단!

console.log(parseInt('a123')) // NaN -> 읽을 수 있는 숫자가 없을 때
```

<br />

**💡 parseInt(str, radix) 두 번째 인수**

```jsx
console.log(parseInt("0xff", 16)); // 255
console.log(parseInt("ff", 16)); // 255, 0x가 없어도 동작

console.log(parseInt("2n9c", 36)); // 123456
```

`radix` 에는 원하는 진수를 지정하여 사용할 수 있다. 따라서 `parseInt`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있다.

<br />

### 2-1-5. parseInt와 toString의 관계

- `toString(base)` : 숫자를 문자열로 변환 (다양한 진법으로 표현 가능함)
- `parseInt(string, base)`: 문자열을 특정 진법의 숫자로 변환 (특정 진법을 기준으로 해석함)

```jsx
let num = 255; // 10진수 숫자

// 1. 숫자를 2진수 문자열로 변환
let binaryStr = num.toString(2);
console.log(binaryStr); // "11111111" (2진수 문자열)

// 2. 변환된 2진수 문자열을 다시 10진수 숫자로 변환
let parsedNum = parseInt(binaryStr, 2);
console.log(parsedNum); // 255 (원래 숫자와 동일)

// parseInt 동작 과정 "11111111"을 2진법으로!
"11111111" = 1 × 2⁷ + 1 × 2⁶ + 1 × 2⁵ + 1 × 2⁴ + 1 × 2³ + 1 × 2² + 1 × 2¹ + 1 × 2⁰
           = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1
           = 255 (10진수)
```

<br />

### 2-1-6. 어림수 구하기

어림수 관련 내장 함수

- `Math.floor` : 소수점 첫째 자리에서 내림

- `Math.ceil` : 소수점 첫째 자리에서 올림
- `Math.round` : 소수점 첫째 자리에서 올림
- `Math.trunc` **\*Internet Explorer 지원 ❌** : 소수부 무시

|      | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
| ---- | ------------ | ----------- | ------------ | ------------ |
| 3.1  | 3            | 4           | 3            | 3            |
| 3.6  | 3            | 4           | 4            | 3            |
| -1.1 | -2           | -1          | -1           | -1           |
| -1.6 | -2           | -1          | -2           | -1           |

<br />

**✅ 특정 소수자리 기준으로 어림수 구하는 방법**

1. **곱하기와 나누기**

   ```jsx
   let num = 1.23456;

   console.log(Math.floor(num * 100) / 100);
   // 1.23456 -> 123.456 -> 123 -> 1.23
   ```

2. **`toFixed(n)` 메서드 사용하기**

   - `toFixed(n)` :  `Number` 객체를 주어진 `digits` 만큼의 소수점 이하 자리수를 정확하게 갖는 문자열 표현으로 반환한다.
   - 소수점 이하가 길면 숫자를 반올림하고, 짧아서 부족할 경우 뒤를 0으로 채울 수 있다.
   - 구문**:** `numObj.toFixed([digits]);`

     - `digits` : 소수점 뒤에 나타날 자릿수, 0 이상 20 이하의 값 지원하며 값을 지정하지 않으면 0을 사용한다.

     - 반환값 : 고정 소수점 표기법을 사용하여 나타낸 수를 “문자열”로 바꾼 값

     ```jsx
     function financial(x) {
       return Number.parseFloat(x).toFixed(2);
     }

     console.log(financial(123.456));
     // Expected output: "123.46"
     // -> Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림

     console.log(financial(0.004));
     // Expected output: "0.00"

     console.log(financial("1.23e+5"));
     // Expected output: "123000.00"
     // -> 소수부의 길이가 인수보다 작으면 끝에 0이 추가 (반환값이 문자열이기 떄문)
     ```

<br />

### 2-1-7. 부정확한 계산

자바스크립트에서 숫자는 64비트 부동소수점 형식에 따라 저장된다. 이 형식은 정수, 소수를 모두 표현할 수 있지만 소수점 계산에서 “정확하지 않은 결과를 초래”할 수 있다.

**✅ IEEE-754 부동 소수점 형식**

숫자는 `가수 × 2^지수`의 형태로 저장되고, 제한된 비트를 사용하기 때문에 일부 숫자는 정확하게 표현할 수 없고 근사치로 저장된다.

- 부호(Sign) : 숫자가 양수인지 음수인지 표시 (1비트)
- 지수(Exponent) : 소수점 위치를 결정 (11비트)
- 가수(Mantissa) : 숫자의 정확한 값 (52비트)

> 🤔 **왜 부정확한 계산이 될까?**
>
> : 일부 소수는 이진수로 정확히 표현되지 않아 **근사치**로 저장되고, 계산 과정에서 반올림 오차가 발생한다.
>
> 🤔 **그러면 이걸 어떻게 해결할 수 있을까?**
>
> : `toFixed`, `Math.round` 메서드로 반올림 처리 또는 정수로 변환한 후 계산한다.

**✅ 부정확한 계산 해결방법**

1. 소수점 계산 시 반올림

   ```jsx
   let result = 0.1 + 0.2;
   console.log(Number(result.toFixed(2))); // 0.3
   ```

2. 정수로 변환 후 계산

   ```jsx
   let result = (0.1 * 10 + 0.2 * 10) / 10;
   console.log(result); // 0.3
   ```

3. 계산 라이브러리 사용 (`decimal.js`, `big.js`, `math.js`)

   ```jsx
   const Decimal = require("decimal.js");
   let result = new Decimal(0.1).plus(0.2);
   console.log(result.toNumber()); // 0.3
   ```

📚 참고자료

- [자바스크립트에서의 부동소수점 연산과 정확한 계산 방법](https://f-lab.kr/insight/accurate-floating-point-calculation-in-javascript)
- [JavaScript에서 부동소수점 연산 오류 해결 방법 (decimal.js)](https://tak2k.tistory.com/83)

<br />

### 2-1-8. `isNaN`과 `isFinite`

`isNaN`과 `isFinite`는 자바스크립트에서 숫자 값의 유효성을 검사하기 위한 전역함수이다.

1. **isNaN (Not-a-Number 인지 확인)**

   역할 : 숫자가 아닌 값인지 확인하며, 숫자로 변환할 수 없는 값은 `true` 를 반환한다.

   ```jsx
   console.log(isNaN("hello")); // true (숫자로 변환 불가)
   console.log(isNaN(undefined)); // true (숫자로 변환 불가)
   console.log(isNaN(123)); // false (숫자)
   console.log(isNaN("123")); // false ("123"은 숫자로 변환 가능)
   ```

   ⚠️ `isNaN`은 숫자로 변환 가능한지 여부만 확인하기 때문에 논리적으로 예상하지 못한 결과를 반환할 수 있다. → 이를 해결하기 위해서는 `Number.isNaN`을 사용하는 것이 좋다.

   ```jsx
   console.log(isNaN(null)); // false (null은 숫자 0으로 변환 가능)
   console.log(isNaN(true)); // false (true는 숫자 1로 변환 가능)
   console.log(isNaN(NaN)); // true (NaN은 숫자로 변환 불가)

   // Number.isNaN 사용
   console.log(Number.isNaN("hello")); // false
   console.log(Number.isNaN(NaN)); // true
   ```

1. **isFinite (유한 숫자인지 확인)**

   역할 : 유한한 값의 숫자인지 확인하며, `Infinity`, `-Infinity`, `NaN`인 경우 `false`를 반환 / 다른 숫자는 `true`를 반환한다.

   ```jsx
   console.log(isFinite(123)); // true (유한한 숫자)
   console.log(isFinite("123")); // true ("123"은 숫자로 변환 가능)
   console.log(isFinite(Infinity)); // false (무한대)
   console.log(isFinite(NaN)); // false (NaN은 유한하지 않음)
   console.log(isFinite("hello")); // false ("hello"는 숫자로 변환 불가)
   ```

<br />

⚠️ `isFinite`는 숫자로 변환 가능한 값을 먼저 확인하기 때문에, 엄격하게 확인하려면 `Number.isFinite` 를 사용하는 것이 좋다.

```jsx
console.log(Number.isFinite(null)); // false
console.log(Number.isFinite(123)); // true
console.log(Number.isFinite(Infinity)); // false
```

**비교 요약**

| **특징**        | **isNaN**                         | **isFinite**                             |
| --------------- | --------------------------------- | ---------------------------------------- |
| 역할            | 숫자가 아닌 **값**인지 확인       | 값이 **유한한 숫자**인지 확인            |
| 숫자로 변환     | 값을 숫자로 변환 후 확인          | 값을 숫자로 변환 후 유한성 확인          |
| Number 버전     | `Number.isNaN`: 엄격한 `NaN` 확인 | `Number.isFinite`: 엄격한 유한 숫자 확인 |
| 예제에서의 동작 | `isNaN("hello")` → `true`         | `isFinite("123")` → `true`               |
| Infinity 처리   | Infinity는 `false`                | Infinity는 `false`                       |

<br />

---

# 📝 03. 문자열

## 3-1. 문자열의 길이 length

`length` 프로퍼티에는 문자열의 길이가 저장된다.

```jsx
console.log(`My\n`.length); // 3
```

→ `\n` 은 특수 문자 하나로 취급되기 때문에 길이가 총 3으로 출력된다.

**⭐️ `length`는 함수가 아니라 프로퍼티이다!**

`str.length` 가 아니라 `str.length()`로 문자열 길이를 알아내려고 하는데, `length`는 함수가 아니고 **숫자가 저장되는 프로퍼티**이기 때문에 **괄호 () 를 붙일 필요가 없다!**

<br />

## 3-2. 특정 글자에 접근하기

문자열 특정 위치에 접근하려면 `[pos]` 처럼 `대괄호`를 사용하거나 `str.charAt(pos)` 라는 메서드를 사용해야한다. (위치는 0부터 시작)

**⚠️ `charAt`는 하위 호환성을 위해 남아있는 메서드이기 때문에 최근에는 [pos] 와 같이 `대괄호` 방식을 사용한다.**

```jsx
let str = `Hello`;

// 첫 번째 글자
console.log(str[0]); // H
console.log(str.charAt(0)); // H

// 마지막 글자
console.log(str[str.length - 1]); // o
```

- 반환할 글자가 없는 경우
  - **대괄호** : `undefined` 반환
  - **charAt** : 빈 문자열 반환
- `for .. of`를 사용하여 반복 작업 실행하기

  ```jsx
  for (let char of "Hello") {
    console.log(char); // H,e,l,l,o (char는 순차적으로 H, e, l, l, o가 된다.)
  }
  ```

<br />

## 3-3. 문자열의 불변성

문자열은 수정할 수 없기 때문에 문자열 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

이를 해결하려면 완전히 새로운 문자열을 하나 만든 후 이 문자열을 변수에 할당하면 된다.

```jsx
let str = "Hi";

str = "h" + str[1]; // 문자열 전체를 교체함

console.log(str); // hi
```

<br />

## 3-4. 대소문자 변경하기

`toLowerCase()`, `toUpperCase()`를 사용하여 케이스 변경을 할 수 있다.

```jsx
console.log("Interface".toUpperCase()); // INTERFACE
console.log("Interface".toLowerCase()); // interface

// 글자 하나의 케이스만 변경하는 것도 가능 ✅
console.log("Interface"[0].toLowerCase()); // 'i'
```

<br />

## 3-5. 부분 문자열(substring) 찾기

### 3-5-1. str.indexOf(substr, pos) 메서드

- `str`의 `pos` 에서부터 시작해서 부분 문자열 `substr` 이 **어디에 위치하는지** 찾아준다.
- 원하는 부분의 문자열을 찾으면 **위치를 반환**, 그렇지 않으면 `-1` 을 반환한다.

```jsx
let str = "Widget with id";

console.log(str.indexOf("Widget")); // 0, str은 'Widget'으로 시작
console.log(str.indexOf("widget")); // -1, indexOf는 대·소문자를 따지므로 원하는 문자열을 찾지 못함

console.log(str.indexOf("id")); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
```

**✅  pos를 활용한 예시**

```jsx
let str = 'Widget with id'

console.log(str.indexOf('id', 2) // 12
```

부분 문자열 `“id”`는 위치 1에서 처음 등장하는데, 두 번째 인수(pos) 에 2를 넘겨 `“id”`가 두 번째로 등장하는 위치가 어디인지 알 수 있다.

**✅ 반복문 안에서의 `indexOf()`**

: 문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶을 때 사용하는 방법이다. <br />반복문이 하나씩 돌면서 검색 시작 위치가 갱신되어 `indexOf`가 새롭게 호출된다.

```jsx
const str = "As sly as a fox, as strong as an ox"; // 검색할 문자열
let target = "as"; // 찾으려는 부분 문자열
let pos = 0; // 검색을 시작할 위치

while (true) {
  // indexOf를 사용하여 target의 위치를 찾음
  let foundPos = str.indexOf(target, pos);

  // 더 이상 찾는 문자열이 없으면 반복문 종료
  if (foundPos == -1) break;

  console.log(`위치: ${foundPos}`);

  // 검색 위치를 갱신해 다음 검색을 이어감
  pos = foundPos + 1;
}
```

**✏️ 로직 설명**

1. `pos = 0` → `indexOf('as', 0)` 실행
   - 첫 번째 'as'의 위치: 8
2. `foundPos = 8` → `console.log('위치: 8')`
3. `pos = foundPos + 1 = 9`로 갱신

<br />

**🚨 조건문에 `indexOf` 사용 시 주의사항**

if 문에서 0을 `false` 로 간주하기 때문에 부분 문자열 여부를 검사하려면 `-1` 과 비교해야한다.

```jsx
let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
  console.log("찾았다!");
}
```

<br />

### 3-5-2. includes, startsWith, endsWith

1. **`includes`**

- `str`에 부분 문자열 `substr` 여부에 따라 `true` / `false` 를 반환한다.
- 부분 문자열의 위치 정보는 필요하지 않고 **포함 여부만 알고 싶을 때** 사용
- 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색한다. (`indexOf` 와 동일)

```jsx
console.log("Widget with id".includes("Widget")); // true
console.log("Hello".includes("Bye")); // false

// 두 번째 인수 값 넘기기
alert("Widget".includes("id")); // true
alert("Widget".includes("id", 3)); // false, 세 번째 위치 이후엔 "id"가 없음
```

2. **`startsWith`**

- 문자열 `str` 이 특정 문자로 시작하는지 (startsWith) / 특정 문자열로 끝나는지 (endsWith) 여부를 확인할 때 사용

  ```jsx
  console.log("Widget".startsWith("Wid")); // true, "Widget"은 "Wid"로 시작
  console.log("Widget".endsWith("get")); // true, "Widget"은 "get"으로 끝
  ```

<br />

## 3-6. 부분 문자열 추출하기

### 3-6-1. slice(start [, end])

- 문자열의 `start` 부터 `end` (미포함) 을 반환한다.

```jsx
let str = "stringify";
console.log(str.slice(0, 5)); // 'strin'
console.log(str.slice(0, 1)); // 's'
```

- **두 번째 인수가 생략되면 문자열 끝까지** 반환한다.

```jsx
let str = "stringify";
console.log(str.slice(2)); // ringify, 2번째부터 끝까지
```

- `start`와 `end`가 **음수**면, 문자열 **“끝”에서부터 카운팅**을 시작한다.

```jsx
let str = "stringify";

// 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
console.log(str.slice(-4, -1)); // gif
```

<br />

### 3-6-2. str.substring(start, [, end])

- `start`와 `end` 사이에 있는 문자열을 반환한다.
- `substring`은 음수 인수를 허용하지 않는다. 음수는 `0`으로 처리된다.

⭐️ **`slice`와 유사하지만 `start` 값이 `end` 보다 커도 괜찮다는 차이점이 있다.**

```jsx
let str = "stringify";

// 동일한 부분 문자열을 반환
console.log(str.substring(2, 6)); // "ring"
console.log(str.substring(6, 2)); // "ring"

// slice를 사용하면 결과가 다르다.
console.log(str.slice(2, 6)); // "ring" (같음)
console.log(str.slice(6, 2)); // 💥 "" (빈 문자열)
```

<br />

### 3-6-3. str.substr(start, [, **length**])

- `start`에서부터 시작해 `length` 개의 글자를 반환한다.
- `substr`은 끝 위치 대신에 “길이”를 기준으로 문자열을 추출한다는 점이 특징이다.

**⚠️ 거의 모든 곳에서 이 메서드가 동작하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있다.**

```jsx
let str = "stringify";
console.log(str.substr(2, 4)); // ring, 두 번째부터 글자 네 개
console.log(str.substr(-4, 2)); // gi, 끝에서 네 번째 위치부터 글자 두 개
```

<br />

## 3-7. 문자열 비교하기

자바스크립트에서 문자열 비교는 알파벳 순서 또는 유니코드(UTF-16) 코드 포인트를 기준으로 이루어진다.

✅ 예제

```jsx
console.log("a" > "Z"); // true (코드 값: 'a'는 97, 'Z'는 90)
console.log("Österreich" > "Zealand"); // true ('Ö'의 코드 값이 'Z'보다 큼)
```

각 문자는 고유한 코드 값(숫자)과 매칭되며, 이 코드 값으로 크기를 비교한다.

<br />

### 3-7-1. 문자열 비교의 특징

1. 소문자는 대문자보다 크다

   UTF-16 코드 값에서 대문자가 먼저 배치되기 때문

2. 발음 구별 기호(diacritical mark)는 알파벳 순서와 다를 수 있다.

   ex) `'Ö'`의 코드 값은 일반 알파벳보다 훨씬 뒤에 위치

3. 글자 비교는 코드 값을 기준으로 함
   1. `'a'.codePointAt(0)` → 97
   2. `'Z'.codePointAt(0)` → 90

<br />

### 3-7-2. str.codePointAt(pos) / **String.fromCodePoint(code)**

1. `str.codePointAt(pos)` : `pos`에 위치한 글자의 코드를 반환

   ```jsx
   console.log("z".codePointAt(0)); // 122
   console.log("Z".codePointAt(0)); // 90
   ```

2. `String.fromCodePoint(code)`: 숫자 형식의 `code`에 대응하는 글자를 만듦

   ```jsx
   console.log(String.fromCodePoint(90)); // Z
   ```

<br />

### 🤪 어떤 메소드를 언제 사용해야하나요!?

| **메서드**      | **입출력**                       | **범위**             |
| --------------- | -------------------------------- | -------------------- |
| `codePointAt`   | 문자열 → 유니코드 코드 포인트 값 | 모든 유니코드 문자   |
| `charCodeAt`    | 문자열 → UTF-16 코드 유닛 값     | BMP(U+0000 ~ U+FFFF) |
| `fromCharCode`  | UTF-16 코드 유닛 값 → 문자열     | BMP(U+0000 ~ U+FFFF) |
| `fromCodePoint` | 유니코드 코드 포인트 값 → 문자열 | 모든 유니코드 문자   |

⭐️ **특정 문자 코드 값을 정확히 확인해야 할 때**:

- 유니코드 전체 문자 → `codePointAt`
- UTF-16 코드 유닛 값 → `charCodeAt`

⭐️ **숫자 값을 문자로 변환해야 할 때**:

- BMP(기본 다국어 평면) 문자만 처리 → `fromCharCode`
- 유니코드 전체 문자 지원 → `fromCodePoint`

<br />

### 3-7-3. ASCII와 Unicode 비교

| **특징**     | **ASCII**                  | **Unicode**                      |
| ------------ | -------------------------- | -------------------------------- |
| 지원 문자 수 | 128개 (7비트)              | 1,114,112개 (최대 21비트)        |
| 범위         | 기본 영어 문자와 특수 기호 | 전 세계 모든 문자와 기호         |
| 용도         | 영어와 간단한 표현         | 다국어 지원, 전 세계 표준 인코딩 |
| 예시         | `'A'` → 65                 | `'A'` → U+0041                   |

<br />

## 3-8. 정확한 문자열 비교

기본 비교의 문제점은 **언어별로 글자의 정렬 규칙이 다르기 때문에** 단순 코드 값 비교로는 정확한 정렬이 어렵다.

`localeCompare` 를 사용하여 브라우저에서 사용 중인 언어와 정렬 규칙을 고려해 문자열을 비교한다.

```jsx
console.log("Österreich".localeCompare("Zealand"));
// -1 (정렬 기준에 따라 'Österreich'가 더 작음)
```

<br />

### 3-8-1. localeCompare 메서드의 반환값

- 비교 결과를 나타내는 **정수**를 반환한다.
- 음수 : 첫 번째 문자열 < 두 번째 문자열
- 0 : 두 문자열이 같음
- 양수 : 첫 번째 문자열 > 두 번째 문자열

<br />

### 3-8-2. 선택 인수로 비교 옵션 설정

- 특정 언어에 맞춘 비교 기준 지정 가능
- 대소문자를 구분할지 여부를 설정할 수 있다.
- 발음 구별 기호를 구분할 수 있다. ex) `‘a’`와 `'á'`를 동일하게 취급하거나 다르게 취급하도록 설정

```jsx
let str1 = "a";
let str2 = "á";

// 대소문자 무시, 발음 구별 기호 무시
console.log(str1.localeCompare(str2, "en", { sensitivity: "base" })); // 0

// 발음 구별 기호 고려
console.log(str1.localeCompare(str2, "en", { sensitivity: "variant" })); // -1
```

<br />

---

# 📝 04. 배열

객체만으로도 다양한 작업을 할 수 있으나, 순서가 있는 컬렉션이 필요할 때가 있는데, 객체를 사용하게 되면 순서와 관련된 메서드가 없어 편리하지 않는다. 객체 자체는 순서를 고려하지 않고 만들어졌기 때문에 새로운 프로퍼티를 기존 프로퍼티 사이에 끼워넣는 작업도 불가하다.

이렇듯 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조 “배열”이 필요하다.

## 4-1. 배열 선언

배열은 아래 두 문법을 사용하여 빈 배열을 만들 수 있다. 대부분 `대괄호 []` 를 사용하여 선언하며 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.

```jsx
let arr = new Array();
let arr = [];
```

<br />

배열 요소의 자료형에는 제약이 없다.

```jsx
// 요소에 여러 가지 자료형이 섞여 있음
let arr = [
  "사과",
  { name: "이보라" },
  true,
  function () {
    alert("안녕하세요.");
  },
];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력
console.log(arr[1].name); // 이보라

// 인덱스가 3인 요소(함수)를 실행
arr[3](); // 안녕하세요.
```

<br />

✅ 각 배열 요소에는 0부터 시작하는 `index` 가 매겨져 있고 이는 배열 내 순서를 나타낸다.

```jsx
let fruits = ["사과", "오렌지", "자두"];

console.log(fruits[0]); // 사과
console.log(fruits[1]); // 오렌지
console.log(fruits[2]); // 자두
```

<br />

✅ 배열 수정 및 추가하기

```jsx
// 요소 수정하기
fruits[2] = "배"; // 배열이 ["사과", "오렌지", "배"]로 바뀜

// 배열에 새로운 요소 추가하기
fruits[3] = "레몬"; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜
```

<br />

✅ 배열에 담긴 요소 개수 구하기

```jsx
let fruits = ["사과", "오렌지", "자두"];
console.log(fruits.length); // 3
```

<br />

## 4-2. 배열 메서드 pop / push / shift/ unshift

자바스크립트 배열은 큐(Queue)와 스택(Stack) 이라는 자료구조를 구현할 수 있는 기능을 제공한다.

`pop`, `push`, `shift`, `unshift` 메서드는 배열의 앞 뒤에서 요소를 추가하거나 제거한다.

### 4-2-1. pop

- 배열 끝 요소를 제거하고 그 요소를 반환
- 배열 크기 1 감소

```jsx
let fruits = ["사과", "오렌지", "배"];

let removed = fruits.pop(); // "배"를 제거하고 반환
console.log(removed); // "배"
console.log(fruits); // ["사과", "오렌지"]
```

### 4-2-2. push

- 배열의 끝 요소에 추가
- 새로운 배열 길이를 반환한다.

```jsx
let fruits = ["사과", "오렌지"];

let newLength = fruits.push("배"); // "배"를 끝에 추가
console.log(newLength); // 3
console.log(fruits); // ["사과", "오렌지", "배"]
```

### 4-2-3. shift

- 배열의 앞 요소를 제거하고 제거된 요소를 반환
- 배열의 나머지 요소들이 앞으로 이동하며, 배열의 크기가 1 감소힘

```jsx
let fruits = ["사과", "오렌지", "배"];

let removed = fruits.shift(); // "사과"를 제거하고 반환
console.log(removed); // "사과"
console.log(fruits); // ["오렌지", "배"]
```

### 4-2-4. unshift

- 배열의 앞 요소에 추가
- 추가된 후 새로운 배열 길이를 반환

```jsx
let fruits = ["오렌지", "배"];

let newLength = fruits.unshift("사과"); // "사과"를 앞에 추가
console.log(newLength); // 3
console.log(fruits); // ["사과", "오렌지", "배"]
```

<br />

`push`와 `unshift`로 여러 요소 추가하기

```jsx
let fruits = ["사과"];

fruits.push("오렌지", "배"); // 끝에 추가
console.log(fruits); // ["사과", "오렌지", "배"]

fruits.unshift("파인애플", "레몬"); // 앞에 추가
console.log(fruits); // ["파인애플", "레몬", "사과", "오렌지", "배"]
```

<br />

## 4-3. 큐(Queue) 와 스택(Stack) 에서의 활용 사례

위 4가지 메서드들을 조합하면 큐(Queue), 스택(Stack) 같은 자료구조를 쉽게 구현할 수 있다.

### 4-3-1. 큐(Queue)

- 큐(Queue)는 **선입선출(FIFO: First-In-First-Out)** 구조이다.
- `push`로 요소를 추가하고 `shift`로 요소를 제거한다.

```jsx
let queue = [];

// 요소 추가
queue.push(1);
queue.push(2);
queue.push(3);
console.log(queue); // [1, 2, 3]

// 요소 제거
console.log(queue.shift()); // 1
console.log(queue); // [2, 3]
```

### 4-3-2. 스택(Stack)

- 스택은 **후입선출(LIFO: Last-In-First-Out)** 구조이다.
- `push`로 요소를 추가하고 `pop`으로 요소를 제거한다.

```jsx
let stack = [];

// 요소 추가
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack); // [1, 2, 3]

// 요소 제거
console.log(stack.pop()); // 3
console.log(stack); // [1, 2]
```

<br />

## 4-4. 배열의 내부 동작 원리

배열은 자바스크립트에서 **특수한 객체**로, 숫자형 `키(인덱스)`를 사용해 요소를 관리한다. 객체와 마찬가지로 프로퍼티를 추가 및 수정할 수 있지만, 배열 고유의 순서가 있는 자료구조로 사용할 때 가장 효율적이다.

**✅ 배열과 객체의 차이**

| **특징**  | **배열**                          | **객체**                      |
| --------- | --------------------------------- | ----------------------------- |
| 키        | 숫자형 인덱스                     | 문자열 or 심볼                |
| 순서 보장 | 있음                              | 없음                          |
| 최적화    | 순차적 데이터 저장에 최적화       | 일반적인 데이터 저장에 최적화 |
| 메서드    | `push`, `pop`, `shift`, `unshift` | 직접 구현 필요                |

### 4-4-1. 배열 동작 예시

```jsx
let fruits = ["바나나"];
let arr = fruits; // 참조를 복사

arr.push("배"); // 원래 배열(fruits)에 영향을 줌

console.log(fruits); // ["바나나", "배"]
```

배열은 참조로 복사된다.

`arr`와 `fruits` 는 같은 배열을 참조하기 때문에 한쪽에서 변경하면 다른 쪽에도 영향을 미친다.

<br />

## 4-5. 성능

### **4-5-1. push와 pop가 빠른 이유**

- 배열 끝에서 작업이 이루어지기 때문에 다른 요소의 인덱스를 이동시키지 않는다.
- `push`: 배열 끝에 요소를 추가
- `pop`: 배열 끝 요소를 제거

```jsx
let fruits = ["바나나", "배"];
fruits.pop(); // "배" 제거
console.log(fruits); // ["바나나"]
```

### **4-5-2. shift와 unshift가 느린 이유**

- 요소 이동이 필요하므로 작업 시간이 **배열 길이에 비례(O(n))하다.**
- `shift`: 배열의 맨 앞 요소를 제거 → **모든 요소를 왼쪽으로 이동**
- `unshift`: 배열 맨 앞에 요소를 추가 → **모든 요소를 오른쪽으로 이동**

```jsx
let fruits = ["사과", "바나나", "배"];
fruits.shift(); // "사과" 제거
console.log(fruits); // ["바나나", "배"]
```

![배열 성능 설명_대지 1](https://github.com/user-attachments/assets/a13421bf-988d-4712-a6c2-ea476ea0dff4)

<br />

### 4-5-3. 잘못된 배열 사용

배열을 순서 있는 데이터로 사용하지 않으면 최적화가 비활성화되어 성능 저하가 발생한다.

```jsx
let fruits = [];
fruits[99999] = "배"; // 비어 있는 인덱스가 많음 → 일반 객체처럼 동작
fruits.age = 25; // 숫자형 키가 아닌 프로퍼티 추가
```

- 빠른 연산 이점 무력화
- 순서가 중요하지 않은 데이터라면 일반 객체 `{}` 를 사용하자

<br />

## 4-6. 반복문

### 4-6-1. for 반복문

`for` 문은 배열을 순회할 때 쓰는 방법으로 순회 시 `인덱스` 를 사용한다.

```jsx
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

### 4-6-2. for … of

`for … of` 를 사용하면 현재 요소의 값만! 얻을 수 있다.

```jsx
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행
for (let fruit of fruits) {
  console.log(fruit);
}
```

### 4-6-3. for … in

배열은 객체형에 속하기 때문에 `for … in` 을 사용하는 것도 가능하다.

```jsx
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  console.log(arr[key]); // 사과, 오렌지, 배
}
```

⚠️ **`for … in` 사용시 주의할 점**

- `for … in` 은 모든 프로퍼티를 대상으로 순회하기 때문에 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
- `for … in` 반복문은 객체와 함꼐 사용할 때 최적화 되어 있기 때문에 배열에 사용하면 객체에 사용했을 때보다 상당히 느리다.

<br />

## 4-7. length 프로퍼티

배열에 조작을 가하면 `length` 프로퍼티는 자동으로 갱신된다. `length` 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다.

**🚨 이따구로 쓰지 마세욧!**

```jsx
let fruits = [];
fruits[123] = "사과";

console.log(fruits.length); // 124
```

`length` 프로퍼티는 쓰기가 가능하다는 특징을 가지고 있는데, 수동으로 값을 증가하면 아무 일도 일어나지 않지만 **감소시킬 경우 배열이 잘리게 된다. 이렇게 잘린 배열은 다시 되돌릴 수 없다!**

```jsx
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 자르기
console.log(arr); // [1, 2]

arr.length = 5; // 본래 길이로 되돌리기
console.log(arr[3]); // undefined: 삭제된 기존 요소들이 복구되지 않는다.
```

<br />

## 4-8. new Array( )

대괄호를 사용하여 배열을 만들면 더 짧은 문법으로 배열을 만들 수 있어 비교적 잘 사용하지 않는 편이다.

⚠️ 하나의 숫자형 인수를 전달한 경우 → 전달된 숫자는 배열의 길이(`length`)로 설정된다!

```jsx
let arr = new Array(3);
console.log(arr); // [empty × 3] (요소가 없는 빈 배열)
console.log(arr.length); // 3
console.log(arr[0]); // undefined
```

✅ 이러한 혼란을 방지하려면 대괄호를 사용하거나 명시적으로 배열 생성 메서드(`Array.of`)를 사용해야한다.

```jsx
// 올바른 방법
let arr1 = [2];
let arr2 = Array.of(2);

console.log(arr1); // [2]
console.log(arr2); // [2]
```

<br />

## 4-9. toString( )

`toString` 메서드를 호출하면 쉼표로 구분한 문자열이 반환된다.

```jsx
let arr = [1, 2, 3];

console.log(arr); // 1,2,3
console.log(String(arr) === "1,2,3"); // true
```

배열에는 `Symbol`, `toPrimitive`, `valueOf` 메서드가 없다. 따라서 문자열로의 형 변환이 일어나 아래 코드처럼 값이 변환된다.

이항 덧셈 연산자 `"+"`는 피연산자 중 하나가 문자열인 경우 나머지 피연산자도 문자열로 변환하기 때문에 위와 동일하게 동작한다.

```jsx
// [] 를 사용하여 형 변환
console.log([] + 1); // "1"
console.log([1] + 1); // "11"
console.log([1, 2] + 1); // "1,21"

// 이항 덧셈 연산자
console.log("" + 1); // "1"
console.log("1" + 1); // "11"
console.log("1,2" + 1); // "1,21"
```

<br />

---

# 📝 05. 배열과 메서드

## 5-1. 요소 추가 / 삭제 메서드

### 5-1-1. splice(pos, deleteCount, ...items)

: 배열에서 pos 위치부터 deleteCount 개의 요소를 제거하거나, 제거된 자리에 items를 추가한다.

```jsx
let fruits = ["사과", "배", "포도"];
fruits.splice(1, 1, "귤"); // 1번 인덱스부터 1개 제거 후 "귤" 추가
console.log(fruits); // ["사과", "귤", "포도"]
```

<br />

## 5-2. 탐색 및 조회 메서드

### 5-2-1. indexOf(item, pos)

: 배열에서 `item`의 **첫 번째 등장 위치**를 반환. 없으면 `-1`

```jsx
let fruits = ["사과", "배", "포도", "배"];
console.log(fruits.indexOf("배")); // 1
```

### 5-2-2. lastIndexOf(item, from)

: 배열에서 `item`의 마지막으로 등장한 인덱스 반환. 없으면 `-1`

```jsx
let arr = ["a", "b", "a", "c", "a"];
console.log(arr.lastIndexOf("a")); // 4 (마지막 "a"의 인덱스)
console.log(arr.lastIndexOf("a", 2)); // 2 (2번 인덱스부터 왼쪽 검색)
console.log(arr.lastIndexOf("z")); // -1 ("z"는 없음)
```

### 5-2-3. includes(item)

: 배열에 `item`이 있으면 `true`, 없으면 `false`

```jsx
console.log(fruits.includes("포도")); // true
console.log(fruits.includes("바나나")); // false
```

### 5-2-4. find(func)

: 조건(`func`)을 만족하는 첫 번째 요소를 반환

```jsx
let numbers = [1, 2, 3, 4];
let found = numbers.find((num) => num > 2);
console.log(found); // 3
```

### 5-2-5. findIndex(func)

: `func` 조건을 만족하는 첫 번째 요소의 인덱스를 반환. 없으면 `-1`

```jsx
let numbers = [5, 12, 8, 130, 44];
let index = numbers.findIndex((num) => num > 10);
console.log(index); // 1 (12는 인덱스 1에 있음)
```

### 5-2-6. filter

: 배열의 모든 요소에 대해 `func` 조건을 만족하는 요소들만 모아 새로운 배열을 반환

⭐️ `filter`는 `find` 와 유사한 문법을 가졌지만, **`find` 메서드**는 함수의 반환 값을 `true` 로 만드는 **하나의 요소**를 찾는다. 조건을 충족하는 요소가 **여러 개라면 `filter` 메서드를 사용**한다.

```jsx
let numbers = [5, 12, 8, 130, 44];
let filtered = numbers.filter((num) => num > 10);
console.log(filtered); // [12, 130, 44]
```

### 5-2-7. some(func) / every(func)

- `some(func)` : 하나라도 조건을 만족하면 `true` 반환
- `every(func)` : 모든 요소가 조건을 만족하면 `true` 반환

```jsx
// 1. some
console.log(numbers.some((num) => num > 3)); // true

// 2. every
console.log(numbers.every((num) => num > 0)); // true
```

<br />

## 5-3. 배열 순회 메서드

### forEach(func)

: 모든 요소에 대해 `func` 를 호출하며 반환값은 없음

```jsx
numbers.forEach((num) => console.log(num)); // 1, 2, 3, 4
```

<br />

## 5-4. 배열 변형 메서드

### 5-4-1. map(func)

: 모든 요소에 `func` 를 적용해 “ 새 배열 “ 을 만듦

```jsx
let squared = numbers.map((num) => num ** 2);
console.log(squared); // [1, 4, 9, 16]
```

### 5-4-2. sort(func)

: 배열을 정렬

```jsx
let numbers = [10, 5, 20, 15];
numbers.sort((a, b) => a - b); // 오름차순 정렬
console.log(numbers); // [5, 10, 15, 20]

numbers.sort((a, b) => b - a); // 내림차순 정렬
console.log(numbers); // [20, 15, 10, 5]
```

**✏️ 작동 원리**

- `func(a, b)`의 반환값:
  - 음수: `a`가 `b`보다 앞에 위치
  - 0: 순서 변경 없음
  - 양수: `b`가 `a`보다 앞에 위치

### 5-4-3. reduce(func, initial)

: 배열을 순회하며 누적 값을 계산

```jsx
// 1. 합계 계산
let numbers = [1, 2, 3, 4];
let sum = numbers.reduce((acc, curr) => acc + curr, 0); // 초기값 0
console.log(sum); // 10

// 2. 중첩 배열 평탄화
let nested = [[1, 2], [3, 4], [5]];
let flat = nested.reduce((acc, curr) => acc.concat(curr), []);
console.log(flat); // [1, 2, 3, 4, 5]

// 3. 최댓값 찾기
let numbers = [10, 5, 20, 15];
let max = numbers.reduce((acc, curr) => (acc > curr ? acc : curr), 0);
console.log(max); // 20
```

`func(acc, curr, index, array)`:

- `acc`: 누적 값
- `curr`: 현재 요소
- `index`: 현재 인덱스
- `array`: 원본 배열

### 5-4-4. reduceRight(func, initial)

: 배열의 **오른쪽에서 왼쪽**으로 요소를 순회하며 `func`을 호출 (`reduce`와 유사하지만 순회 방향이 반대)

```jsx
let arr = [1, 2, 3, 4];
let result = arr.reduceRight((acc, curr) => acc + curr, 0);
console.log(result); // 10 (4 + 3 + 2 + 1)
```

### 5-4-5. split과 join

- **`split`**: 문자열을 특정 구분자(delimiter)로 나누어 배열로 반환
- **`join`**: 배열을 특정 구분자로 연결해 문자열로 반환

```jsx
// split
let str = "apple,banana,orange";
let arr = str.split(",");
console.log(arr); // ["apple", "banana", "orange"]

// join
let joined = arr.join(" | ");
console.log(joined); // "apple | banana | orange"
```

<br />

## 5-5. 배열 메서드와 thisArg

### 5-5-1. thisArg

: 메서드(`map`, `forEach`, `filter`, 등)에 `this`로 사용할 값을 설정

`thisArg`는 `func`의 `this`가 된다.

```jsx
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수
```

✅ **예시 코드**

```jsx
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  },
};

let users = [{ age: 16 }, { age: 20 }, { age: 23 }, { age: 30 }];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

console.log(soldiers.length); // 2
console.log(soldiers[0].age); // 20
console.log(soldiers[1].age); // 23
```

`users.filter(user => army.canJoin(user))`를 사용하면 `users.filter(army.canJoin, army)`를 대체할 수 있긴 한데 `thisArg`를 사용하는 방식이 좀 더 이해하기 쉬우므로 더 자주 사용된다.

<br />

## 5-6. 기타 메서드

### 5-6-1. slice(start, end)

: 배열의 일부분을 복사해 새로운 배열 생성

```jsx
let sliced = fruits.slice(1, 2);
console.log(sliced); // ["배"]
```

### 5-6-2. concat(…items)

: 배열의 모든 요소와 `items`를 병합해 새로운 배열 생성

```jsx
let newFruits = fruits.concat(["바나나", "귤"]);
console.log(newFruits); // ["사과", "배", "포도", "바나나", "귤"]
```

<br />

## 5-7. 심화 메서드

### 5-7-1. fill(value, start, end)

: 배열의 특정 구간을 `value`로 채움

```jsx
let filled = new Array(5).fill(0, 1, 4);
console.log(filled); // [empty × 1, 0, 0, 0, empty × 1]
```

### 5-7-2. copyWithin(**target, start, end)**

: 배열의 특정 구간을 복사해 **`target` 위치에 덮어쓰기**

```jsx
let arr = [1, 2, 3, 4];
arr.copyWithin(0, 2, 4); // 2번부터 4번 앞까지 복사해 0번에 덮어씀
console.log(arr); // [3, 4, 3, 4]
```

<br />

---

# 📝 06. iterable 객체

- `Iterable` 객체는 자바스크립트에서 **반복 가능한 객체**를 의미한다.
- `for … of` 반복문과 함께 사용될 수 있는 객체를 `Iterable` 이라고 한다.
- 배열, 문자열 , `Map`, `Set` 등 모두 기본적으로 `Iterable` 이다.

## 6-1. Symbol.iterator

`Iterable` 객체는 `Symbol.iterator` 메서드를 가지고 있다. 이 메서드는 객체를 반복할 때 호출되고 `Iterator` 객체를 반환한다.

### Iterator 객체란?

- `Iterator`는 `next()`메서드를 가지고 있는 객체이다.
- `next()` 메서드는 반복할 때마다 다음 값을 반환하고, `done` 속성으로 반복이 끝났는지를 표시한다.

**✅ 문자열과 `for…of`**

```jsx
let str = "Hello";

// 문자열을 for...of로 반복
for (let char of str) {
  console.log(char); // "H", "e", "l", "l", "o"
}
```

문자열은 기본적으로 `Iterable` 이다.

**✅ Symbol.iterator 명시적으로 사용하기**

```jsx
let str = "Hello";
let iterator = str[Symbol.iterator]();

console.log(iterator.next()); // { value: "H", done: false }
console.log(iterator.next()); // { value: "e", done: false }
console.log(iterator.next()); // { value: "l", done: false }
console.log(iterator.next()); // { value: "l", done: false }
console.log(iterator.next()); // { value: "o", done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

`Symbol.iterator`를 직접 호출해 `Iterator` 객체를 얻을 수 있다.

<br />

## 6-2. 이터러블과 유사 배열

- 이터러블(iterable) : `Symbol.iterator` 가 구현된 객체
- 유사 배열(array-like) : 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체

**⭐️ 이터러블 객체 ≠ 유사 배열 객체**

✅ 유사배열 객체이지만 이터러블 객체가 아닌 경우

```jsx
let arrayLike = {
  // ⭐️ 인덱스와 length프로퍼티가 있음 => 유사 배열
  0: "Hello",
  1: "World",
  length: 2,
};

// Symbol.iterator가 없으므로 에러 발생
for (let item of arrayLike) {
}
```

⚠️ **이터러블과 유사배열은 배열이 아니기 때문에 `push`, `pop` 등의 배열 메서드를 지원하지 않는다.**

→ `Array.from` 범용 메서드를 사용하면 배열 메서드를 적용할 수 있다!

<br />

## 6-3. Array.from

- `Array.from` 은 Iterable 객체를 배열로 변환한다.
- 문자열, Set, Map 등도 `Array.from` 을 사용하여 배열로 변환할 수 있다.
- ES6에서 도입된 기능으로, 배열로 변환이 필요한 다양한 상황에서 유용하게 사용할 수 있다.

### 6-3-1. 기본 문법

```jsx
Array.from(arrayLike, mapFunction?, thisArg?)
```

- `arrayLike`: 변환하고자 하는 유사 배열 객체 또는 `Iterable` 객체
- `mapFunction`: (선택적) 배열 요소 각각에 적용할 매핑 함수
- `thisArg`: (선택적) `mapFunction` 내부에서 사용할 `this` 값

### 6-3-2. 주요 사용 사례

✅ **유사 배열 객체를 배열로 변환**

```jsx
// 유사 배열 객체
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2,
};

let arr = Array.from(arrayLike);
console.log(arr); // ["Hello", "World"]
console.log(Array.isArray(arr)); // true
```

✅ **문자열을 배열로 변환**

```jsx
// 문자열을 배열로 변환
let str = "Hello";
let arr = Array.from(str);

console.log(arr); // ["H", "e", "l", "l", "o"]
```

**✏️ 코드 진행 과정**

1. `let arr = Array.from(str);` 이 부분에서 `Array.from`은 객체를 받아 이터러블인지, 유사배열인지 조사한다.
2. 넘겨 받은 인수가 이터러블이거나 유사배열인 경우 새로운 배열을 만든다.
3. 객체의 모든 요소를 새롭게 만든 배열로 복사한다.

✅ `Set`이나 `Map` 같은 `Iterable` 객체를 배열로 변환

```jsx
// Set
let set = new Set([1, 2, 3]);
let arrFromSet = Array.from(set);
console.log(arrFromSet); // [1, 2, 3]

// Map
let map = new Map([
  [1, "a"],
  [2, "b"],
]);
let arrFromMap = Array.from(map);
console.log(arrFromMap); // [[1, "a"], [2, "b"]]
```

✅ **매핑 함수와 함께 사용하기**

```jsx
let numbers = [1, 2, 3, 4];

// 각 요소를 제곱한 배열 생성
let squared = Array.from(numbers, (num) => num ** 2);
console.log(squared); // [1, 4, 9, 16]
```

✅ **`thisArg`와 함께 사용하기**

```jsx
let obj = { multiplier: 2 };

let numbers = [1, 2, 3];
let doubled = Array.from(
  numbers,
  function (num) {
    return num * this.multiplier;
  },
  obj
); // obj를 this로 설정

console.log(doubled); // [2, 4, 6]
```

📚 참고자료
[Array.from() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
<br>

---

<br>

# 📝 07. Map

지금까지의 자료구조는 **객체**(`key`가 있는 컬렉션 저장)와 **배열**(`순서`가 있는 컬렉션 저장)로 정리했다.

`Map` 과 `Set`도 객체, 배열과 유사하지만 약간의 차이점이 존재한다.

## 7-1. Map

`Map`은 키가 있는 데이터를 저장한다는alert 객체와 유사하지만, `key`에 다양한 자료형을 허용한다는 부분이 차이점이다.

대량 데이터를 처리할 때 객체보다 `Map`을 사용하는 것이 검색 및 삽입 성능이 뛰어나다.

### Map 메서드 및 프로퍼티

- `new Map()` : `맵` 생성
- `map.set(key, value)` : `key`를 이용해 `value` 저장
- `map.get(key)`: `key` 해당하는 값 반환 (없다면 `undefined` 반환)
- `map.has(key)` : `key`가 존재하면 `true`, 없으면 `false` 반환
- `map.delete(key)` : `key` 값 삭제
- `map.clear()`: `맵` 안의 모든 요소 제거
- `map.size` : 요소의 개수 반환

```jsx
let map = new Map();

map.set("1", "str1"); // 문자형 키
map.set(1, "num1"); // 숫자형 키
map.set(true, "bool1"); // 불린형 키

// 아래의 코드는 출력되는 값이 다르다. (맵은 키를 문자형으로 변환 ❌)
console.log(map.get(1)); // 'num1'
console.log(map.get("1")); // 'str1'

console.log(map.size); // 3
```

⭐️ `Map`은 객체와 달리 `key`를 문자형으로 변환하지 않는다. `key`에는 자료형 제약이 없다.

객체에서 대괄호를 사용했었는데 `Map`에서도 `map[key] = 2` 처럼 사용할 수 있긴 하지만, 이 방법은 **`map` 을 일반 객체처럼 취급**하게 된다. 여러 제약이 생기게 되므로 **`map`의 전용 메서드 `set`, `get` 등을 사용하도록 하자**

<br>

**✅** `Map`**의 `key`로 객체 사용하기**

```jsx
let john = { name: "John" };

// 고객의 가게 방문 횟수를 세본다고 가정
let visitsCountMap = new Map();

// john을 맵의 키로 사용
visitsCountMap.set(john, 123);

console.log(visitsCountMap.get(john)); // 123
```

⭐️ 객체를 `key`로 사용할 수 있다는 점이 `Map`의 가장 중요한 기능!!!

**🚨 객체형 `key`를 객체에 사용하기**

```jsx
let john = { name: "John" };

let visitsCountObj = {}; // 객체 생성

visitsCountObj[john] = 123; // 객체(john)를 키로 해서 객체에 값(123)을 저장

// 원하는 값(123)을 얻으려면 아래와 같이 키가 들어갈 자리에 `object Object`를 써줘야한다.
console.log(visitsCountObj["[object Object]"]); // 123
```

객체 `visitsCountObj`는 모든 `key`를 **문자형으로 변환**하는데, 이 때 `john`이 문자형으로 바뀌어 `"[object Object]"`가 된다.

<br>

### map 체이닝

`map.set`을 호출할 때마다 `Map`자신이 반환된다. 이를 활용하여 `map.set`을 체이닝 하는 것도 가능하다.

단, 체이닝은 코드의 가독성을 높이지만, **사용 시 `undefined` 같은 값이 저장될 위험성이 있으므로 주의**해야한다.

```jsx
let map = new Map();
map
  .set("a", 1)
  .set("b", undefined) // 체이닝 중 undefined 저장 가능
  .set("c", null);

console.log(map.get("b")); // undefined
console.log(map.size); // 3
```

<br>

## 7-2. Map 요소에 반복 작업하기

### 반복작업 메서드

- `map.keys()` : 각 요소의 `키`를 모은 이터러블 객체 반환
- `map.values()` : 각 요소의 `값`을 모은 이터러블 객체 반환
- `map.entries()` : 요소의 `[키, 값]`을 한 쌍으로 하는 이터러블 객체 반환
  → 이 이터러블 객체는 `for..of` 반복문의 기초로 사용된다.

✅ `Map`**은 삽입 순서를 기억하여 삽입된 순서대로 순회를 실시한다.**

```jsx
let recipeMap = new Map([
  ["cucumber", 500],
  ["tomatoes", 350],
  ["onion", 50],
]);

// 키(vegetable)를 대상으로 순회
for (let vegetable of recipeMap.keys()) {
  console.log(vegetable); // cucumber, tomatoes, onion
}

// 값(amount)을 대상으로 순회
for (let amount of recipeMap.values()) {
  console.log(amount); // 500, 350, 50
}

// [키, 값] 쌍을 대상으로 순회
for (let entry of recipeMap) {
  // recipeMap.entries()와 동일
  console.log(entry); // cucumber,500 ...
}
```

### 7-2-1. Map의 이터러블 특성

`Map` 은 기본적으로 이터러블 객체를 가지고 있어 `forEach`,`for…of` 문이나 스프레드 연산자를 활용할 수 있다.

```jsx
let map = new Map([
  ["apple", 10],
  ["banana", 20],
]);

for (let [key, value] of map) {
  console.log(`${key}: ${value}`);
}
// apple: 10
// banana: 20

console.log([...map]); // [["apple", 10], ["banana", 20]]
```

<br>

## 7-3. Object.entries: 객체 → Map

각 요소가 키-값 쌍인 배열이나 이터러블 객체를 초기화 용도로 `Map`에 전달해 새로운 `Map`을 만들 수 있다.

평범한 객체를 가지고 `Map`을 만들고 싶을 경우 `Object.entries(obj)`를 사용해야한다. \* (`[key, value]`로 가지는 배열을 반환함

```jsx
let obj = {
  name: "John",
  age: 30,
};

let map = new Map(Object.entries(obj));

console.log(map.get("name")); // John

// 1. Object.entries를 사용해 객체 obj를 배열 [ ["name","John"], ["age", 30] ]로 바꿈
// 2. 이 배열을 이용해 새로운 맵 생성
```

<br>

## 7-4. Object.fromEntries: Map → 객체

이 메서드는 각 요소가 `[키, 값]` 쌍인 배열을 객체로 바꿔준다.

`Object.fromEntries` 는 인수로 이터러블 객체를 받기 때문에 짧게 줄인 코드도 이전 코드와 동일하게 동작한다. 꼭 배열을 전달할 필요가 없다는 뜻!!

```jsx
let map = new Map();
map.set("banana", 1);
map.set("orange", 2);
map.set("meat", 4);

let obj = Object.fromEntries(map.entries()); // 맵을 일반 객체로 변환

// 맵이 객체가 되었습니다!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

`map.entries()` 를 호출하면 `Map`의 `[키, 값]`을 요소로 가지는 이터러블 반환한다.

**✅ `.entries()` 생략하여 짧게 줄이기 가능**

```jsx
let obj = Object.fromEntries(map.entries());
let obj = Object.fromEntries(map);

// 둘 다 같은 역할!
```

### 7-4-1. Object.entries()와 Object.fromEntries()의 활용

JSON 데이터를 처리하거나 변환하는 사례를 통해 조금 더 살펴보면 아래와 같다.

```jsx
// 서버에서 받은 JSON 데이터
let jsonData = {
  banana: 1,
  orange: 2,
  meat: 4,
};

// 객체 → 맵 변환
let map = new Map(Object.entries(jsonData));

// 맵 작업 수행
map.set("apple", 5);

// 맵 → 객체 변환 후 JSON으로 전송
let updatedJson = JSON.stringify(Object.fromEntries(map));
console.log(updatedJson); // {"banana":1,"orange":2,"meat":4,"apple":5}
```

## 7-5. 객체 vs Map 요약

| **특징**       | **객체(Object)**           | **맵(Map)**           |
| -------------- | -------------------------- | --------------------- |
| 키 타입        | 문자열, 심볼만 가능        | 모든 자료형           |
| 순서 유지      | 보장되지 않을 수 있음      | 삽입 순서 보장        |
| 크기 확인      | 직접 요소 개수 계산 필요   | `size` 프로퍼티 사용  |
| 반복 가능 여부 | 기본적으로 `Iterable` 아님 | 기본적으로 `Iterable` |

<br>

---

<br>

# 📝 08. Set

## 8-1. Set

`Set` 은 중복을 허용하지 않는 값을 모아놓은 컬렉션이다. `Set`에 `key`가 없는 값이 저장된다.

```jsx
let set = new Set();
set.add(1);
set.add(1); // 중복된 값은 무시됨
console.log(set.size); // 1 (값이 하나만 저장됨)
```

중복이 없기 때문에 `Set` 내에 동일한 값(`value`)이 있다면 `set.add(value)`을 아무리 많이 호출하더라도 아무런 반응이 없다.

<br>

### Set 메서드

- `new Set(iterable)` : `Set` 생성. 이터러블 객체를 전달받으면 그 안의 값을 복사하여 `Set`에 넣어준다.
- `set.add(value)`  : 값을 추가하고 `Set` 자신을 반환
- `set.delete(value)` : 값 제거. 호출 시점에 `Set` 내에 값이 있어 제거에 성공하면 `true`, 아니면 `false`를 반환
- `set.has(value)`  : `Set` 내에 값이 존재하면 `true`, 아니면 `false`를 반환
- `set.clear()` : `Set` 비우기
- `set.size` : `Set`에 몇 개의 값이 있는지 세준다.

✅ **사용예시**

```jsx
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// john, mary는 여러 번 방문할 수 있음
set.add(john); ✨
set.add(pete);
set.add(mary); ✨
set.add(john); ✨
set.add(mary); ✨

// 셋에는 중복되지 않은! 값만 저장된다 (중복해서 저장 ❌)
console.log( set.size ); // 3

for (let user of set) {
  console.log(user.name); // // John, Pete, Mary 순으로 출력됩니다.
}
```

<br>

## 8-2. Set 값에 반복 작업하기

### 반복작업 메서드

- `set.keys()` : `Set` 내의 모든 값을 포함하는 이터러블 객체를 반환
- `set.values()` : `set.keys`와 동일한 작업을 하며, `Map` 과 호환성을 위해 만들어진 메서드이다.
- `set.entries()` :  `Set` 내의 각 값을 이용해 만든 `[value, value]` 배열을 포함하는 이터러블 객체를 반환한다. 이 또한 `Map`과의 호환성을 위해 만들어졌다.

🤔 `set.keys()` 와 `set.values()`의 차이

두 메서드는 **실제로 같은 작업을 수행하지만 차이점은 “`Map`과의 호환성을 위해 설계되었는가?” 의 여부**에 따라 다른 점이 있다.

```jsx
let set = new Set(["apple", "banana", "cherry"]);
console.log([...set.keys()]); // ["apple", "banana", "cherry"]
console.log([...set.values()]); // ["apple", "banana", "cherry"]

// -> 하는 역할은 동일~!!
```

✅ `for..of`나 `forEach`를 사용하여 반복 작업 수행

```jsx
let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// forEach를 사용해도 동일하게 동작
set.forEach((value, valueAgain, set) => {
  console.log(value);
});
```

<br>

### set 체이닝

`set.add()`을 활용하여 `map.set` 처럼 체이닝이 가능하다.

```jsx
let set = new Set();
set.add("apple").add("banana").add("cherry");
console.log([...set]); // ["apple", "banana", "cherry"]
```

<br>

## 8-3. Set과 Array의 변환

`Set`과 `Array`는 상호 변환이 가능하다.

✅ 코드 예시

```jsx
// 배열 → Set 변환
let arr = [1, 2, 3, 3, 4];
let set = new Set(arr); // 중복 제거
console.log(set); // Set(4) { 1, 2, 3, 4 }

// Set → 배열 변환
let uniqueArray = [...set];
console.log(uniqueArray); // [1, 2, 3, 4]
```

<br>

---

<br>

# 📝 09. 위크**맵과 위크셋**

## 9-1. WeakMap과 WeakSet 개념

### WeakMap

- `WeakMap`은 `Map` 과 유사하지만 `key`가 반드시 **객체**여야한다.
- 해당 객체에 대한 참조가 약하게 유지되어 메모리 누수를 방지한다.
- 가비지 컬렉션 : `WeakMap`의 `key`는 약한 참조로, `key`에 해당하는 객체가 다른 곳에서 참조되지 않으면 메모리에서 자동으로 해제된다.
- 비공개 데이터 저장에 적합

### WeakSet

- `WeakSet`은 `Set`과 유사하지만, 값이 반드시 **객체**여야한다.
- 약한 참조로 유지되어 메모리 누수를 방지한다.
- 값으로 설정된 객체가 다른 곳에서 참조되지 않으면 가비지 컬렉션에 의해 제거된다.
- 객체 추적 및 중복 방지에 유용

<br>

## 9-2. WeakMap WeakSet 특징

| **특징**      | **WeakMap**                          | **WeakSet**                         |
| ------------- | ------------------------------------ | ----------------------------------- |
| `key` / 값    | 객체만 가능                          | 객체만 가능                         |
| 약한 참조     | `key`에 대한 약한 참조               | `값`에 대해 약한 참조               |
| 가비지 컬렉션 | `key`가 더이상 참조 되지 않으면 해제 | `값`이 더 이상 참조되지 않으면 해제 |
| 크기 확인     | `size` 프로퍼티 X                    | `size` 프로퍼티 X                   |
| 반복          | 반복 불가능                          | 반복 불가능                         |

### WeakMap과 WeakSet의 제한사항

1. **크기 확인 불가능** : `size` 프로퍼티가 없기 때문에 몇 개의 요소가 저장되어 있는지 알 수 없다.
2. **반복 불가능** : `forEach`, `for..of` 같은 반복 작업을 수행할 수 없다. 때문에 단순히 데이터 보관 용도로 사용된다.
3. **강한 참조와의 비교** : `Map`과 `Set`은 데이터를 강하게 참조하여 데이터가 명시적으로 삭제되지 않으면 메모리에서 해제되지 않는다.

<br>

## 9-3. 주요 메서드

### WeakMap 메서드

- **`weakMap.set(key, value)`**: 키-값 쌍을 추가
- **`weakMap.get(key)`**: 키에 해당하는 값을 반환, 키가 없으면 `undefined` 반환
- **`weakMap.delete(key)`**: 특정 키를 삭제
- **`weakMap.has(key)`**: 키가 존재하면 `true`를 반환

### **WeakSet 메서드**

- `weakSet.add(value)`: 객체를 추가
- `weakSet.has(value)`: 객체가 존재하면 `true` 반환
- `weakSet.delete(value)`: 특정 값을 삭제

<br>

## 9-4. 활용 예제

**✅ WeakMap 활용예제 - 객체와 추가 데이터 연결**

```jsx
let weakMap = new WeakMap();

let user = { name: "John" };
weakMap.set(user, "민감한 정보");

// weakMap.get()으로 데이터 접근
console.log(weakMap.get(user)); // 출력: "민감한 정보"

// user가 더 이상 참조되지 않으면 가비지 컬렉션에 의해 weakMap에서 제거됨
user = null;
```

<br>

**✅ DOM 요소와 데이터 연결**

DOM 요소에 데이터를 연결할 때 요소가 제거되면 자동으로 메모리가 해제된다.

```jsx
let weakMap = new WeakMap();

let button = document.querySelector("button");
weakMap.set(button, "Clicked");

// 버튼 제거 후 메모리에서 자동 해제
button.remove();
```

<br>

**✅ WeakSet 활용예제 - 객체 추적**

```jsx
let visitedSet = new WeakSet();

let john = { name: "John" };
let mary = { name: "Mary" };

visitedSet.add(john);
visitedSet.add(mary);

console.log(visitedSet.has(john)); // true
console.log(visitedSet.has(mary)); // true

// john이 참조되지 않으면 가비지 컬렉션으로 제거
john = null;
```

<br>

**✅ 중복 방지**

`WeakSet`은 중복된 객체를 자동으로 무시된다.

```jsx
let weakSet = new WeakSet();

let obj1 = {};
let obj2 = obj1;

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true
console.log(weakSet.has(obj2)); // true (같은 객체)
```

### **WeakMap과 WeakSet의 주요 활용 사례**

1. 메모리 누수 방지 : 약한 참조를 하기 때문에 참조되지 않는 데이터는 자동으로 메모리에서 해제
2. 비공개 데이터 저장 : 객체의 외부에서 접근할 수 없는 비공개 데이터를 저장하는데 적합
3. DOM 요소와 데이터 연결 : DOM 요소와 추가 데이터를 연결하여 DOM 요소가 제거되면 자동으로 데이터도 해제된다.

<br>

---

<br>

# 📝 10. Object.keys, values, entries

`key()`, `values()`, `entries()` 를 사용할 수 있는 자료구조는 `Map`, `Set`, `Array` 이다.

일반 객체에도 순회 관련 메서드가 있지만 문법에 차이가 있다.

- **Object.keys(obj)** : 객체의 `키`만 담은 배열을 반환
- **Object.values(obj)** : 객체의 `값`만 담은 배열을 반환
- **Object.entries(obj)** : `[키, 값]` 쌍을 담은 배열을 반환

`Object.keys`, `Object.values`, `Object.entries` 는 객체의 프로퍼티와 값을 다룰 수 있는 메서드로 이 메서드들은 객체를 반복(`iterate`)하거나 변환할 때 자주 사용된다.

<br>

## 10-1. 각 메서드 예제 코드

### Object.keys(obj)

객체의 “키(프로퍼티 이름)”만 배열로 반환한다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

console.log(Object.keys(user));
// ["name", "age", "isAdmin"]
```

### Object.values(obj)

객체의 “값(value)”만 배열로 반환한다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

console.log(Object.values(user));
// ["John", 30, true]
```

### Object.entries(obj)

객체의 "키-값” 쌍을 배열로 반환한다. 각 배열의 요소는 `[key, value]` 형태이다.

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

console.log(Object.entries(user));
// [["name", "John"], ["age", 30], ["isAdmin", true]]
```

<br>

## 10-2. 반복문에 활용해보기

### Object.keys(obj) + for…of

객체의 “**키**”만 순회

```jsx
let user = {
  name: "John",
  age: 30,
};

for (let key of Object.keys(user)) {
  console.log(key); // "name", "age"
}
```

### Object.values(obj) + for…of

객체의 “**값(value)**”만 순회

```jsx
let user = {
  name: "John",
  age: 30,
};

for (let value of Object.values(user)) {
  console.log(value); // "John", 30
}
```

### Object.entries(obj) + for…of

객체의 **키-값** 쌍을 순회

```jsx
let user = {
  name: "John",
  age: 30,
};

for (let [key, value] of Object.entries(user)) {
  console.log(`${key}: ${value}`);
}
// name: John
// age: 30
```

### 객체 변환에 활용하기

**✅ Object.values 를 사용하여 값의 총합 계산하기**

```jsx
let salaries = {
  John: 1000,
  Pete: 1200,
  Mary: 3000,
};

let total = Object.values(salaries).reduce((sum, salary) => sum + salary, 0);
console.log(total); // 5200
```

**✅ Object.entries 를 사용하여 객체를 배열로 변환하기**

```jsx
let user = {
  name: "John",
  age: 30,
};

// [key, value] 배열로 변환
let entries = Object.entries(user);

// 배열 정렬
let sorted = entries.sort(([key1], [key2]) => key1.localeCompare(key2)); // *localeCompare

console.log(sorted);
// [["age", 30], ["name", "John"]]
```

객체를 배열로 변환하였기 때문에 당연히 배열 메서드도 사용할 수 있다.

**\*`localeCompare()`** : 참조 문자열이 정렬 순으로 지정된 문자열 앞 혹은 뒤에 오는지 또는 동일한 문자열인지 나타내는 수치를 반환 ([MDN - localeCompare 참조 링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare))

✅ **Object.fromEntries 를 사용하여 배열을 객체로 변환하기**

```jsx
let entries = [
  ["name", "John"],
  ["age", 30],
];

// 배열 → 객체 변환
let user = Object.fromEntries(entries);

console.log(user);
// { name: "John", age: 30 }
```

### **객체 변환 메서드 간의 관계**

1. **객체 → 배열**
   - `Object.keys`, `Object.values`, `Object.entries`를 사용하여 객체를 배열로 변환
2. **배열 → 객체**
   - `Object.fromEntries`를 사용하여 `[key, value]` 배열을 객체로 변환

#### 💡Tip!

- 정렬된 결과가 필요하다면? → `Object.entries`를 사용해 배열로 변환 후, 정렬하여 사용
- 객체의 특정 프로퍼티 필터링 한다면? → `Object.entries`와 `filter`를 조합하여 특정 키-값만 필터링

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

// isAdmin을 제외한 객체 생성
let filteredEntries = Object.entries(user).filter(([key]) => key !== "isAdmin");

let filteredUser = Object.fromEntries(filteredEntries);

console.log(filteredUser);
// { name: "John", age: 30 }
```

<br>

---

<br>

# 📝 11. 구조 분해 할당

객체나 배열을 변수로 분해할 수 있는 특별한 문법으로 함수의 매개변수가 많거나 매개변수 기본값이 필요한 경우에 구조 분해 할당을 유용하게 사용할 수 있다.

## 11-1. 배열 분해하기

```jsx
let arr = ["Bora", "Lee"];

// firstName엔 arr[0]을 , surname엔 arr[1]을 할당
let [firstName, surname] = arr;

console.log(firstName); // Bora
console.log(surname); // Lee
```

인덱스를 이용해서 배열에 접근하지 않고 변수로 이름과 성을 사용할 수 있다.

```jsx
let [firstName, surname] = "Bora Lee".split(" ");
```

이 코드처럼 `split` 같은 배열을 반환하는 메서드를 함께 사용할 수 있다.

**✏️ 쉼표를 사용하여 요소 무시하기**

```jsx
// 두 번째 요소는 필요하지 않음
let [firstName, , title] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];

console.log(title); // Consul
```

만약에 두 번째 요소 (”Caesar”)를 사용하지 않고 값을 출력하려 한다면 쉼표를 사용하여 필요하지 않은 배열 요소를 버릴 수 있다.

- 쉼표로 두 번째 요소 Caesar 생략 → title 변수에 Consul 할당
- 네 번째 요소는 할당될 변수가 없기 때문에 생략

**✏️ 할당 연산자 우측엔 모든 이터러블이 올 수 있다**

```jsx
let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
```

배열 뿐만 아니라 모든 이터러블에 구조 분해 할당을 적용할 수 있다.

**✏️ 할당 연산자 좌측엔 뭐든지 올 수 있다**

```jsx
let user = {};
[user.name, user.surname] = "Bora Lee".split(" ");

console.log(user.name); // Bora
```

할당 연산자 좌측에는 할당할 수 있는 것이라면 객체 프로퍼티 마저도 가능하다.

**✏️ .entries()로 반복하기**

```jsx
let user = {
  name: "John",
  age: 30,
};

// 객체의 키와 값 순회하기
for (let [key, value] of Object.entries(user)) {
  console.log(`${key}:${value}`); // name:John, age:30이 차례대로 출력
}

// Map에서도 사용 가능!
let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user) {
  console.log(`${key}:${value}`); // name:John, then age:30
}
```

지난 챕터에서 정리한 `Object.entries(obj)` 메서드와 구조 분해를 조합하면 객체의 키와 값을 순회해 변수로 분해 할당할 수 있다.

**✏️ 두 변수에 저장된 값 교환하기**

```jsx
let guest = "Jane";
let admin = "Pete";

// 변수 guest엔 Pete, 변수 admin엔 Jane이 저장되도록 값을 교환함
[guest, admin] = [admin, guest];

console.log(`${guest} ${admin}`); // Pete Jane
```

두 개의 변수에 저장된 값을 교환할 때도 구조 분해 할당을 사용하면 편리하게 바꿀 수 있다.

<br>

### 11-1-1. ‘`…`’ 로 나머지 요소 가져오기

배열 앞쪽에 위치한 값 일부만 사용하고 나머지 값들은 따로 모아 저장하고 싶을 때, 점 세 개 ‘`…`’ 를 붙인 매개변수 하나를 추가하면 나머지(`rest`) 요소를 가져올 수 있다.

```jsx
let [name1, name2, ...rest] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];

console.log(name1); // Julius
console.log(name2); // Caesar

// `rest`는 배열
console.log(rest[0]); // Consul
console.log(rest[1]); // of the Roman Republic
console.log(rest.length); // 2
```

- `rest`는 나머지 배열 요소가 저장된 **새로운 배열**이 된다.
- **⚠️ 변수 앞의 점 세 개(`…`)와 변수가 가장 마지막에 위치**해야한다.

### 11-1-2. 기본값

할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 커서, 할당할 값이 없으면 `undefined`로 취급되어 에러가 발생하지 않는다.

```jsx
let [firstName, surname] = [];

console.log(firstName); // undefined
console.log(surname); // undefined
```

✅ `=` 이용하여 기본값(`default value`) 설정하기

```jsx
// 기본값
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

console.log(name); // Julius (배열에서 받아온 값)
console.log(surname); // Anonymous (기본값)
```

이렇게 기본식으로 표현식이나 함수를 설정하면 할당할 값이 없을 때 표현식이나 함수가 호출된다.

```jsx
// name의 prompt만 실행됨
let [
  surname = prompt("성을 입력하세요."),
  name = prompt("이름을 입력하세요."),
] = ["김"];

console.log(surname); // 김 (배열에서 받아온 값)
console.log(name); // prompt에서 받아온 값
```

위 예시는 기본값으로 두 개의 `prompt` 함수를 할당한 예시이다.

값이 제공되지 않았을 때만 함수가 호출되기 때문에, `prompt` 는 한 번만 호출된다.

<br>

## 11-2. 객체 분해하기

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};

let { title, width, height } = options;

console.log(title); // Menu
console.log(width); // 100
console.log(height); // 200

// ⭐️ 이렇게 작성해도 동일하게 작동함!
let { height, width, title } = { title: "Menu", height: 200, width: 100 };
```

할당 연산자 우측에는 분해하고자 하는 객체를 적고, 좌측에는 상응하는 객체 프로퍼티 패턴을 넣는다.

순서는 중요하지 않고 ⭐️ 표시처럼 작성해도 동일하게 동작한다.

**✅ 조금 더 복잡한 패턴의 코드 살펴보기**

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { 객체 프로퍼티: 목표 변수 }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

console.log((title);  // Menu
console.log((w);      // 100
console.log((h);      // 200
```

`options.width` 를 `w` 라는 변수에 저장하는 방식의 코드인데, 좌측 패턴에 콜론 `:` 을 사용하면 된다.

- 콜론은 `분해하고자 하는 객체의 프로퍼티 : 목표 변수` 같은 형태로 사용한다.
- 프로퍼티가 없는 경우에는 `=` 을 사용하여 설정할 수 있다. (ex. `*let {width = 100, height = 200, title} = options;`)\*

**✅ 콜론 + 할당연산자 동시에 사용하기**

```jsx
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

console.log((title);  // Menu
console.log((w);      // 100
console.log((h);      // 200
```

**✅ 프로퍼티가 많은 복잡한 객체에서 원하는 정보만 뽑아오기**

```jsx
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};

// title만 변수로 뽑아내기
let { title } = options;

console.log(title); // Menu
```

### 11-2-1. 나머지 패턴 ‘`…`’

나머지 패턴(rest pattern)을 사용하면 나머지 프로퍼티를 다른 곳에 할당하는 것이 가능하다. 단, IE를 비롯한 일부 브라우저에서는 나머지 패턴을 지원하지 않으므로 주의해야한다.

```jsx
let options = {
  title: "Menu",
  height: 200,
  width: 100,
};

// title = 이름이 title인 프로퍼티
// rest = 나머지 프로퍼티들
let { title, ...rest } = options;

// title엔 "Menu", rest엔 {height: 200, width: 100}이 할당
console.log(rest.height); // 200
console.log(rest.width); // 100
```

**✏️ `let` 없이 사용하기**

자바스크립트는 표현식 안에 있지 않으면서 주요 코드 흐름상에 있는 `{…}` 를 코드 블록으로 인식한다. 코드 블록의 본래 용도는 아래와 같이 문(statement)을 묶는 것이다.

```jsx
// ✅ 정상 작동 코드
{
  // 코드 블록
  let message = "Hello";
  // ...
  console.log( message );
}

// ===========================================================================

// 🚨 에러 발생 코드 - SyntaxError: Unexpected token '='
let title, width, height;

{title, width, height} = {title: "Menu", width: 200, height: 100};

// ===========================================================================

// 🚧 표현식으로 해석하게 만들기
let title, width, height;

// 에러가 발생하지 않음!
({title, width, height} = {title: "Menu", width: 200, height: 100}); ⭐️

console.log( title );
```

이 에러를 해결하기 위해서는 할당문을 괄호 `(…)`로 감싸서 자바스크립트가 `{…}`를 표현식으로 해석하기 만들면 된다.

<br>

## 11-3. 중첩 구조 분해(nested destructuring)

### 11-3-1. 중첩 객체 분해

객체 안에 또 다른 객체가 있는 경우, 중첩된 객체의 프로퍼티를 분해하여 변수에 할당할 수 있다.

```jsx
let options = {
  size: {
    width: 100,
    height: 200,
  },
  items: ["Cake", "Donut"],
  extra: true,
};

let {
  size: { width, height }, // size 내부의 width와 height
  items: [item1, item2], // items 배열의 첫 번째와 두 번째 요소
  title = "Menu", // 기본값 설정
} = options;

console.log(title); // Menu (기본값)
console.log(width); // 100
console.log(height); // 200
console.log(item1); // Cake
console.log(item2); // Donut
```

⚠️ `size`와 `items`는 변수로 선언되지 않는다. 대신 내부 프로퍼티만 분해된다.

### 11-3-2. 배열과 객체 조합

배열과 객체를 조합한 복잡한 구조도 분해 가능하다.

```jsx
let data = {
  title: "Sample Data",
  values: [
    { id: 1, name: "A" },
    { id: 2, name: "B" },
  ],
};

let {
  title,
  values: [
    { id: firstId }, // 첫 번째 객체의 id
    { name: secondName }, // 두 번째 객체의 name
  ],
} = data;

console.log(title); // "Sample Data"
console.log(firstId); // 1
console.log(secondName); // "B"
```

### 11-3-3. 중첩 구조 분해의 장점

1. 객체나 배열의 복잡한 구조를 쉽게 분해하여 필요한 데이터만 추출할 수 있다.
2. 기본값 설정과 변수 이름을 변경할 수 있다.

<br>

## 11-4. 똑똑한 함수 매개변수 (Smart Function Parameters)

### 11-4-1. 객체를 매개변수로 받아 구조분해 하기

함수의 매개변수로 객체를 받아 필요한 값만 구조분해 할 수 있다.

```jsx
function showMenu({
  title = "Untitled",
  width = 200,
  height = 100,
  items = [],
}) {
  console.log(`${title} - ${width}x${height}`);
  console.log(`Items: ${items.join(", ")}`);
}

let options = {
  title: "Menu",
  items: ["Item1", "Item2"],
};

showMenu(options);
// "Menu - 200x100"
// "Items: Item1, Item2"
```

### 11-4-2. 매개변수 이름 변경과 기본값 설정하기

객체의 프로퍼티 이름과 다른 변수명으로 할당하거나 기본값을 설정할 수 있다.

```jsx
function showMenu({
  title = "Untitled",
  width: w = 100, // width를 w로 바꿔서 사용
  height: h = 200, // height를 h로 바꿔서 사용
  items: [item1, item2], // 배열 구조 분해
}) {
  console.log(`${title} - ${w}x${h}`);
  console.log(`Items: ${item1}, ${item2}`);
}

let options = {
  title: "My Menu",
  items: ["Cake", "Donut"],
};

showMenu(options);
// "My Menu - 100x200"
// "Items: Cake, Donut"
```

### 11-4-3. 매개변수 기본값으로 빈 객체 사용하기

매개변수로 아무 것도 전달되지 않아도 에러가 발생하지 않도록, 기본값으로 빈 객체 `{}`를 설정할 수 있다.

```jsx
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  console.log(`${title} - ${width}x${height}`);
}

showMenu(); // "Menu - 100x200"
```

### 11-4-4. 똑똑한 함수 매개변수의 장점

1. 많은 매개변수를 한 번에 객체로 받아 관리 가능히다.
2. 기본값 설정과 객체 구조 분해를 통해 코드 가독성 향상된다.

<br>

---

<br>

# 📝 12. Date 객체와 날짜

## 12-1. Date 객체 생성하기

`new Date()`를 호출하면 새로운 `Date` 객체를 만들 수 있다.

```jsx
let now = new Date();
console.log(now); // 현재 날짜 및 시간이 출력

let Jan01_1970 = new Date(0);
console.log(Jan01_1970); // 1970년 1월 1일 0시 0분 0초(UTC+0)를 나타내는 객체

let Jan02_1970 = new Date(24 * 3600 * 1000);
console.log(Jan02_1970); // 1970년 1월 1일의 24시간 후는 1970년 1월 2일(UTC+0)
```

1970년의 첫날을 기준으로 이 이후의 밀리초를 나타내는 정수는 **타임스탬프(timestamp)** 라고 부른다.

1970년 1월 1일 이전의 날짜의 타임스탬프는 음수를 가진다.

타임스탬프를 사용하면 날짜를 숫자형태로 간편하게 나타낼 수 있는데 `new Date(timestamp)` 또는 `date.getTime()` 메서드를 사용해서 `Date` 객체에서 타임스탬프를 추출하는 것도 가능하다.

### **✅ new Date(datestring)**

하나뿐인 인수가 문자열이라면, 해당 문자열은 자동으로 구문 분석(parsed) 된다.

**`new Date(year, month, date, hours, minutes, seconds, ms)`**

주어진 인수를 조합해 만들 수 있는 날짜가 저장된 객체가 반환된다. 여기서 첫 번째와 두 번째 인수만 필수값이다. (지역 시간대 기준)

- `year`는 반드시 네 자리 숫자여야 한다.
- `month`는 `0`(1월)부터 `11`(12월) 사이의 숫자여야한다.
  - 자바스크립트에서는 `0`이 첫번째 요소이므로 이를 주의해서 로직을 작성해야한다.
- `date`는 값이 없는 경우엔 1일로 처리된다.
- `hours/minutes/seconds/ms`에 값이 없는 경우엔 `0`으로 처리된다.

<br>

## 12-2. 날짜 구성요소 얻기

### Date 객체 메서드 정리

이 메서드는 모두 현지 시간 기준 날짜 구성요소를 반환한다.

⭐️ `'UTC’`를 붙여주면 표준시(UTC+0) 기준의 날짜 구성 요소를 반환해주는 메서드 `getUTCFullYear()`, `getUTCMonth()`, `getUTCDay()`를 만들 수 있다.

⭐️ 다만 `getTime()`과 `getTimezoneOffset()` 는 변환할 수 없다.

| **메서드**                                                        | **반환값**                                                                 |
| ----------------------------------------------------------------- | -------------------------------------------------------------------------- |
| `getFullYear()`                                                   | 연도 반환 (네자리)                                                         |
| `getMonth()`                                                      | 월을 반환 (0 이상 11 이하)                                                 |
| `getDate()`                                                       | 일을 반환 (1 이상 31 이하)                                                 |
| `getHours()`, `getMinutes()`, `getSeconds()`, `getMilliseconds()` | 시, 분, 초, 밀리초를 반환                                                  |
| `getDay()`                                                        | 요일 반환 (일요일 = 0. 토요일 = 6)                                         |
| `getTime()` ⭐️                                                   | 주어진 일시와 1970년 1월 11일 00시 00분 00초 사이의 간격인 타임스탬프 반환 |
| `getTimezoneOffset()` ⭐️                                         | 현지 시간과 표준 시간의 차이(분) 반환                                      |

<br>

## 12-3. 날짜 구성요소 설정하기

### 메서드 종류

날짜 구성요소를 설정해주는 메서드들이다.

- `setFullYear(year, [month], [date])`
- `setMonth(month, [date])`
- `setDate(date)`
- `setHours(hour, [min], [sec], [ms])` : 날짜 구성요소를 동시에 설정 가능, 메서드 인수에 없는 구성요소는 변경되지 않는다.

  ```jsx
  let today = new Date();

  today.setHours(0);
  console.log(today); // 날짜는 변경되지 않고 시만 0으로 변경

  today.setHours(0, 0, 0, 0);
  console.log(today); // 날짜는 변경되지 않고 시, 분, 초가 모두 변경된다(00시 00분 00초)
  ```

- `setMinutes(min, [sec], [ms])`
- `setSeconds(sec, [ms])`
- `setMilliseconds(ms)`
- `setTime(milliseconds)` (1970년 1월 1일 00:00:00 UTC부터 밀리초 이후를 나타내는 날짜를 설정) : 유일하게 이 메서드만 UTC를 추가하여 표준시에 따라 날짜 구성 요소를 설정하는 메서드 없음!

<br>

## 12-4. 자동 고침

`Date` 객체는 범위를 벗어난 날짜를 입력하면 자동으로 조정된다. (ex. 1월 32일 입력하면 → 2월 1일로 수정)

✅ 예시 코드

```jsx
let date = new Date(2013, 0, 32); // 2013년 1월 32일은 없는 날짜
console.log(date); // 2013년 2월 1일 출력
```

**✅ 활용 예시**

- 윤년 계산 없이 간단히 날짜를 더하고 뺄 때 사용함

```jsx
let date = new Date(2016, 1, 28); // 2016년 2월 28일
date.setDate(date.getDate() + 2); // 이틀 추가
console.log(date); // 2016-03-01
```

- 시간을 더하거나 뺄 때도 사용 가능

```jsx
let date = new Date();
date.setSeconds(date.getSeconds() + 70); // 70초 추가
console.log(date); // 70초 후의 시간
```

- 음수 값을 입력하면 이전 날짜로 자동 조정

```jsx
let date = new Date(2016, 0, 2); // 2016년 1월 2일
date.setDate(0); // 0은 이전 달의 마지막 날
console.log(date); // 2015-12-31
```

<br>

## 12-5. 날짜 차이 계산하기

`Date` 객체는 숫자형으로 변환될 수 있고, 숫자로 변환하면 타임스탬프가 반환된다. 이를 사용하여 두 날짜 간의 차이를 계산할 수 있다.

```jsx
let start = new Date(); // 시작 시간

// 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // 종료 시간

console.log(`작업 완료에 걸린 시간: ${end - start}ms`); // 밀리초 단위 시간 차이
```

<br>

## 12-6. Date.now()

이 메서드는 현재 타임스탬프를 반환한다. `new Date()` ,`.getTime()`과 동일한 역할을 하지만, 더 빠르고 효율적이다.

```jsx
let start = Date.now(); // 시작 시간 (타임스탬프)

// 작업 수행
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // 종료 시간

console.log(`작업 완료에 걸린 시간: ${end - start}ms`);
```

<br>

## 12-7. 벤치마크 테스트

벤치마크 테스트는 함수의 성능을 비교하는 데 사용된다. 두 함수가 동일한 작업을 수행하더라도, 성능 차이를 확인할 수 있다.

**✅ 코드 예시**

```jsx
function diffSubtract(date1, date2) {
  return date2 - date1; // 객체를 숫자형으로 변환 후 연산
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime(); // getTime()으로 숫자값 반환 후 연산
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

console.log(`diffSubtract 실행 시간: ${bench(diffSubtract)}ms`);
console.log(`diffGetTime 실행 시간: ${bench(diffGetTime)}ms`);
```

⚠️ **주의할 점** : CPU 상황에 따라 결과가 달라질 수 있기 때문에 **여러 번 실행하여 평균값을 구해 신뢰성**을 높인다.

```jsx
let time1 = 0,
  time2 = 0;

for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

console.log(`diffSubtract 평균 시간: ${time1 / 10}ms`);
console.log(`diffGetTime 평균 시간: ${time2 / 10}ms`);
```

<br>

## 12-8. Date.parse()로 문자열 파싱

`Date.parse(str)` 를 사용하면 문자열을 날짜 객체로 변환할 수 있다.

이 문자열 형식은 `YYYY-MM-DDTHH:mm:ss.sssZ`처럼 생겨야한다.

### YYYY-MM-DDTHH:mm:ss.sssZ 형식 설명 및 코드 예시

- `YYYY-MM-DD`: 날짜 (필수)
- `T`: 날짜와 시간을 구분하는 문자
- `HH:mm:ss.sss`: 시간 (선택)
- `Z`: UTC 시간대 표시 (옵션)

✅ **코드 예시**

```jsx
let timestamp = Date.parse("2012-01-26T13:51:50.417-07:00");
console.log(timestamp); // 1327611110417 (타임스탬프)

let date = new Date(timestamp);
console.log(date); // 2012-01-26T20:51:50.417Z
```

**✅ 유용하게 활용하는 방법**

- `Date.parse()`로 타임스탬프를 받아 새로운 날짜 생성

```jsx
let date = new Date(Date.parse("2023-12-31T23:59:59Z"));
console.log(date); // 2023-12-31T23:59:59.000Z
```

<br>

---

<br>

# 📝 13. JSON과 메서드

## 13-1. JSON

JavaScript Object Notation의 약자로 값이나 객체를 나타내주는 범용 포맷이다. JSON은 자바스크립트에서 사용할 목적으로 만들어진 포맷이지만 라이브러리를 사용하면 자바스크립트가 아닌 언어에서도 JSON을 충분히 다룰 수 있다. 때문에 JSON을 데이터 교환 목적으로 사용하는 경우가 많으며 서버 측 언어가 무엇이든 상관없다.

### JSON 관련 메서드

`JSON.stringify` : 객체를 JSON으로 바꿔주는 메서드

`JSON.parse` : JSON을 객체로 바꿔주는 메서드

<br>

## 13-2. JSON.stringify

### `JSON.stringify`의 전체 문법

```jsx
let json = JSON.stringify(value, [replacer, space]);
```

- `value` : JSON으로 변환할 객체
- `repalcer` : JSON으로 변환할 프로퍼티를 제어할 **배열** 또는 **함수**
- `space` : 가독성을 위해 JSON 문자열에 추가할 공백 문자 수

**✅ 코드 예시**

```jsx
let student = {
  name: "John",
  age: 30,
  isAdmin: false,
  courses: ["html", "css", "js"],
  wife: null,
};

let json = JSON.stringify(student);

console.log(typeof json); // 문자열

console.log(json);

/* JSON으로 인코딩된 객체:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
```

`student`는 문자열로 바뀌었는데 이렇게 문자열로 변환된 후에야 네트워크를 통해 전송하거나 저장소에 저장할 수 있다.

변경된 문자열은 `*JSON으로 인코딩된(JSON-encoded)`, `직렬화 처리된(serialized)`, `문자열로 변환된(stringified)`, `결집된(marshalled)`\*객체라고 부른다.

### 13-2-1. JSON으로 인코딩 된 객체의 특징

- 문자열은 큰따옴표로 감싸야한다.
  → 작은 따옴표, 백틱을 사용할 수 없다.
- 객체 프로퍼티 이름은 큰따옴표로 감싸야한다.
  → `age : 30` 이 `“age” : 30` 으로 변한 것 확인

### 13-2-2. 원시값에 적용하기

적용할 수 있는 자료형

- 객체
- 배열
- 원시형
  - 문자형
  - 숫자형
  - 불린형
  - `null`

JSON은 데이터 교환을 목적으로 만들어진 언어에 종속되지 않는 포맷이다.
<br>따라서 자바스크립트 특유의 객체 프로퍼티는 `JSON.stringify` 로 처리할 수 없다.

### 13-2-3. JSON.stringify 호출 시 무시되는 프로퍼티

- 함수 프로퍼티 (메서드)
- 심볼형 프로퍼티 (키가 심볼인 프로퍼티)
- 값이 `undefined`인 프로퍼티

```jsx
let user = {
  sayHi() {
    // 무시
    console.log("Hello");
  },
  [Symbol("id")]: 123, // 무시
  something: undefined, // 무시
};

console.log(JSON.stringify(user)); // 빈 객체 출력
```

### 13-2-4. JSON.stringify 장점과 주의사항

**👏 중첩 객체도 알아서 문자열로 바꿔주는 장점이 있다.**

```jsx
let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"],
  },
};

console.log(JSON.stringify(meetup));

/* 
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
```

⚠️ **순환 참조시 주의하기**

**순환 참조**: 객체의 프로퍼티가 자기 자신을 참조하거나 다른 객체를 참조하다가 **결국 다시 자기 자신으로 돌아오는 경우**를 말한다. 이 경우 `JSON.stringify`는 **에러**를 발생시킨다.

```jsx
let room = {
  number: 23,
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"],
};

meetup.place = room; // meetup은 room을 참조
room.occupiedBy = meetup; // room은 meetup을 참조

JSON.stringify(meetup); // Error: Converting circular structure to JSON
```

**✅ 간단한 코드로 복습하기**

```jsx
let obj = {};
obj.self = obj; // obj가 자기 자신을 참조

JSON.stringify(obj);
// TypeError: Converting circular structure to JSON
```

**🚧 해결방법**

1. **객체를 직렬화 하기 전에 순환 참조 제거하기**

```jsx
let obj = {};
obj.name = "Example";
obj.self = obj; // 순환 참조

// 순환 참조 제거
obj.self = null;

console.log(JSON.stringify(obj));
// {"name":"Example","self":null}
```

2. **`replacer` 함수 사용하기 → 13-3 챕터에서 정리 예정**

```jsx
let obj = {};
obj.name = "Example";
obj.self = obj;

let json = JSON.stringify(obj, (key, value) => {
  if (value === obj) return undefined; // 순환 참조 제거
  return value;
});

console.log(json);
// {"name":"Example"}
```

3. **외부 라이브러리 사용하기 (ex. circular-json, flatted)**

```jsx
// npm install flatted
const { stringify } = require("flatted");

let obj = {};
obj.name = "Example";
obj.self = obj;

console.log(stringify(obj));
// {"name":"Example","self":"~"}
```

- [circular 라이브러리](https://www.npmjs.com/package/circular-json)
- [flatted 라이브러리](https://www.npmjs.com/package/flatted)

<br>

## 13-3. replacer로 원하는 프로퍼티만 직렬화하기

앞에서 살짝 다뤘지만 순환 참조를 다뤄야하는 경우처럼, 전환 프로세스를 정교하게 조정하려면 `replacer` 라는 두 번째 인수를 사용해야한다.

### 13-3-1. replacer에 배열 전달

- JSON으로 변환할 **프로퍼티 이름을 배열로 전달**하여 선택적으로 직렬화할 수 있다.

```jsx
let meetup = {
  title: "Conference",
  participants: [{ name: "John" }, { name: "Alice" }],
  location: "Online",
};

console.log(JSON.stringify(meetup, ["title", "participants"]));
// {"title":"Conference","participants":[{},{}]}
```

**문제점:** 중첩 객체나 배열의 프로퍼티는 명시적으로 포함하지 않으면 비어 있는 객체(`{}`)로 출력된다.

### 15-3-2. replacer에 함수 전달

- 함수를 전달하면 객체의 모든 프로퍼티를 재귀적으로 처리할 수 있다.
- 반환 값이 `undefined`인 프로퍼티는 직렬화되지 않는다.

```jsx
let room = { number: 23 };
let meetup = {
  title: "Conference",
  participants: [{ name: "John" }, { name: "Alice" }],
  place: room,
};
room.occupiedBy = meetup; // 순환 참조

let json = JSON.stringify(meetup, function replacer(key, value) {
  // 순환 참조 제거
  return key === "occupiedBy" ? undefined : value;
});

console.log(json);
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
```

코드 설명:

1. `replacer` 함수는 객체의 모든 프로퍼티를 `키-값` 쌍으로 처리한다.
2. 반환된 값만 JSON에 포함된다.
3. 첫 번째 호출에서는 키가 `“”` 이고 값이 객체 전체이다.

<br>

## 13-4. space로 가독성 높이기

space 매개변수를 사용하면 JSON 문자열에 공백, 들여쓰기를 추가할 수 있다.

숫자를 전달하면 해당 공백 문자 수로 들여쓰기 된다.

**✅ 코드 예시 - 숫자 전달**

```jsx
let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
};

console.log(JSON.stringify(user, null, 2));
/*
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/
```

**✅ 다양한 공백 추가하기 - 문자열 전달**

```jsx
// 📚 "--"로 들여쓰기
console.log(JSON.stringify(user, null, "--"));

/*
{
--"name": "John",
--"age": 25,
--"roles": {
----"isAdmin": false,
----"isEditor": true
--}
}
*/
```

## 13-5. replacer + space 조합하여 사용해보기

✅ 특정 프로퍼티 선택 후 가독성 높이기

```jsx
let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true,
  },
  password: "secret",
};

let json = JSON.stringify(
  user,
  (key, value) => (key === "password" ? undefined : value), // password 제거
  4 // 들여쓰기
);

console.log(json);

/*
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
```

### 요약 및 Tip

| **매개변수** | **역할**                              | **사용예시**                                      |
| ------------ | ------------------------------------- | ------------------------------------------------- |
| replacer     | 선택적으로 프로퍼티를 직렬화 or 제거  | 배열로 포함할 프로퍼티 지정, 함수로 조건 처리하기 |
| space        | JSON 문자열의 가독성을 위한 공백 추가 | 들여쓰기 숫자 or 문자열 전달                      |

- **순환참조 처리** : `replacer` 활용하여 순환 참조 제거
- **데이터 필터링** : `replacer`를 사용해 민감한 데이터를 직렬화에서 제외시키기
- **가독성** : 디버깅 시 `space` 매개변수를 사용해 직렬화 된 JSON을 읽기 쉽게 출력하기

## 13-4. JSON.parse

JSON 형식의 문자열을 JavaScript 객체로 변환하는 메서드이다. `JSON.parse()`를 사용하면 JSON으로 인코딩 된 객체를 다시 디코딩 할 수 있다.

### `JSON.parse`의 전체 문법

```jsx
let value = JSON.parse(str, [reviver]);
```

- `str` : JSON 형식의 문자열
  - 유효한 JSON 형식이어야 함
  - 큰따옴표(`"`)로 감싸야 하며, 작은따옴표(`'`)는 허용되지 않음
- `reviver` : 변환된 객체의 각 키-값 쌍을 처리하는 함수

**✅ 기본 변환 코드 예시**

```jsx
let jsonString = '{"name": "John", "age": 30, "isAdmin": false}';
let user = JSON.parse(jsonString);

console.log(user.name); // "John"
console.log(user.age); // 30
console.log(user.isAdmin); // false
```

**✅ 중첩 객체 변환**

```jsx
let jsonString = `{
  "name": "John",
  "age": 30,
  "address": {
    "city": "New York",
    "zip": "10001"
  }
}`;
let user = JSON.parse(jsonString);

console.log(user.address.city); // "New York"
console.log(user.address.zip); // "10001"
```

**✅ 배열 변환**

```jsx
let jsonString = "[1, 2, 3, 4, 5]";
let numbers = JSON.parse(jsonString);

console.log(numbers[0]); // 1
console.log(numbers[4]); // 5
```

## 13-5. reviver 사용하기

- `reviver` 함수를 사용하면 변환된 객체의 각 `키-값` 쌍을 조작할 수 있다.
- `key` 와 `value` 를 매개변수로 받아 새로운 값을 반환한다.

### 13-5-1. 특정 값 필터링

```jsx
let jsonString = '{"name": "John", "age": 30, "isAdmin": false}';

let user = JSON.parse(jsonString, (key, value) => {
  // "age" 필드는 값을 2배로 변경
  if (key === "age") return value * 2;
  return value; // 다른 값은 그대로 반환
});

console.log(user.age); // 60
```

### 13-5-2. 날짜 변환

```jsx
let jsonString = '{"name": "John", "birthDate": "1990-01-01T00:00:00.000Z"}';

let user = JSON.parse(jsonString, (key, value) => {
  if (key === "birthDate") return new Date(value);
  return value;
});

console.log(user.birthDate); // Date 객체
console.log(user.birthDate.getFullYear()); // 1990
```

JSON은 날짜를 문자열로 저장하기 때문에 객체로 변환하려면 `reviver`를 사용해야한다.

<br>

## 13-6. JSON.parse 에러 처리하기

`JSON.parse`는 유효하지 않은 JSON 문자열을 만나면 에러를 발생시킨다. 이를 방지하기 위해 `try…catch` 문을 사용해준다.

**✅ 코드 예시**

```jsx
let invalidJson = "{name: 'John'}"; // JSON 형식 오류 (큰따옴표가 없음)

try {
  let user = JSON.parse(invalidJson);
} catch (error) {
  console.error("JSON parsing error:", error.message);
  // SyntaxError: Unexpected token n
}
```
